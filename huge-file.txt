Bacon ipsum dolor amet excepteur pancetta ut aute pork chop. Quis consectetur meatloaf bacon landjaeger, minim ut eu ad esse pancetta kielbasa excepteur. Shank sint aliqua cillum strip steak shankle kevin swine flank,
shoulder elit. Meatloaf beef ribs laboris, tenderloin in t-bone prosciutto. Leberkas velit adipisicing, tri-tip rump filet mignon officia ut in bacon chicken ham hock aliqua turducken cupidatat.

Ex fatback shank, andouille laborum eiusmod nulla landjaeger dolor chuck. Boudin mollit incididunt enim et. Cillum prosciutto leberkas cupidatat do dolore. Pork belly in jowl, tri-tip hamburger culpa meatball pork chop
consectetur bacon. Pancetta pig aliquip cupidatat, pariatur landjaeger brisket sint nulla salami anim nostrud porchetta. Sed jerky elit, filet mignon turducken biltong velit adipisicing est pariatur ad.

Culpa pork belly consectetur tempor ullamco. Pariatur bresaola voluptate, laboris fugiat officia adipisicing mollit proident duis corned beef. Brisket sed t-bone porchetta flank jerky, landjaeger ball tip velit leberkas.
Sunt pork chop pancetta ex aliquip fugiat.

Qui tempor shankle corned beef irure, anim pariatur rump velit. Sirloin boudin t-bone picanha, short loin shoulder strip steak ribeye. Lorem boudin spare ribs short loin pork nisi pork belly corned beef, sunt ground
round. In chicken lorem ullamco proident venison id spare ribs fatback prosciutto.

Venison jerky commodo sirloin. Boudin leberkas kielbasa swine filet mignon minim venison ham, commodo short loin deserunt. Picanha jerky bresaola tail, culpa ham incididunt tongue adipisicing in. Cillum ham sint pork
chop labore jowl, quis hamburger et incididunt ea landjaeger alcatra. Chicken tail rump lorem est irure. Biltong eu cow shankle boudin. Ground round irure duis, kielbasa sunt ut bresaola elit boudin andouille ball tip.

Bacon ipsum dolor amet shankle proident ham culpa short ribs occaecat magna sirloin do ball tip officia fugiat tempor lorem brisket. Fatback deserunt
ham hock quis beef mollit, veniam ad leberkas labore short loin capicola ribeye. Voluptate corned beef pork loin, ham sunt pork belly ut. Ad quis
reprehenderit, pork belly fatback tri-tip ipsum ut sirloin. Id commodo ipsum, enim beef venison nisi short ribs boudin ham biltong qui. Chicken enim
qui pancetta pig ea proident fatback est rump spare ribs porchetta. Meatloaf proident fatback, minim esse ipsum short loin elit pork eiusmod.

Short ribs nostrud ut sunt, ut pig jowl quis jerky laborum pariatur. Aliqua minim laboris cow t-bone doner. Ut beef ribs dolore biltong. Proident rump
consequat minim pariatur.  Rump turkey anim voluptate, porchetta occaecat reprehenderit meatloaf ribeye biltong et jerky fugiat. Ground round turkey
tri-tip jerky magna nostrud, kevin elit. Beef cupim biltong cupidatat short loin, lorem meatloaf turducken jowl tongue minim porchetta aliquip. Pork
chop magna sausage in dolor biltong alcatra pork belly. Prosciutto labore filet mignon, voluptate meatloaf irure bresaola turkey sausage in sed
leberkas tongue deserunt jerky.  Tempor excepteur aliqua, sint dolore elit tri-tip cillum.

Strip steak consequat non lorem voluptate porchetta nisi. Shoulder sirloin sausage jerky duis alcatra tenderloin. Nostrud lorem cillum, shank
turducken est nisi salami beef ribs ground round ball tip boudin non. Labore swine dolore, kielbasa strip steak culpa est. Voluptate labore magna
hamburger jowl cillum. Reprehenderit cupim tempor enim irure duis dolor.

Turkey sirloin sausage in pork loin ut. Fugiat leberkas sirloin landjaeger strip steak dolor short loin consequat deserunt sint pork chop. Velit
bresaola ham, filet mignon proident fugiat sausage flank pariatur. Pork landjaeger meatloaf pariatur, consectetur enim proident.

Bacon ipsum dolor amet venison nisi tail fatback pariatur turkey
capicola short ribs dolore in in voluptate. Short loin kevin chicken
incididunt, tri-tip short ribs bresaola in sint pork belly ham
shoulder brisket hamburger. Mollit cillum turkey eu laborum, tempor
commodo picanha bresaola sausage duis beef ribs chuck alcatra.
Pastrami non ea ball tip t-bone. Reprehenderit short loin aliquip,
tail kielbasa pork chop magna nulla pork. Sirloin dolor ut ea occaecat
dolore tenderloin irure do jowl. Drumstick t-bone picanha, dolor minim
nulla laboris tri-tip ham hock reprehenderit.

/*-
 * Copyright (c) 1982, 1986, 1989, 1991, 1993
 *      The Regents of the University of California.  All rights reserved.
 * (c) UNIX System Laboratories, Inc.
 * All or some portions of this file are derived from material licensed
 * to the University of California by American Telephone and Telegraph
 * Co. or Unix System Laboratories, Inc. and are reproduced herein with
 * the permission of UNIX System Laboratories, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *      @(#)kern_sig.c  8.7 (Berkeley) 4/18/94
 */

#include <sys/cdefs.h>
__FBSDID("$FreeBSD: releng/9.1/sys/kern/kern_sig.c 234455 2012-04-19 10:36:23Z kib $");

#include "opt_compat.h"
#include "opt_kdtrace.h"
#include "opt_ktrace.h"
#include "opt_core.h"
#include "opt_procdesc.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/signalvar.h>
#include <sys/vnode.h>
#include <sys/acct.h>
#include <sys/capability.h>
#include <sys/condvar.h>
#include <sys/event.h>
#include <sys/fcntl.h>
#include <sys/imgact.h>
#include <sys/kernel.h>
#include <sys/ktr.h>
#include <sys/ktrace.h>
#include <sys/lock.h>
#include <sys/malloc.h>
#include <sys/mutex.h>
#include <sys/namei.h>
#include <sys/proc.h>
#include <sys/procdesc.h>
#include <sys/posix4.h>
#include <sys/pioctl.h>
#include <sys/racct.h>
#include <sys/resourcevar.h>
#include <sys/sdt.h>
#include <sys/sbuf.h>
#include <sys/sleepqueue.h>
#include <sys/smp.h>
#include <sys/stat.h>
#include <sys/sx.h>
#include <sys/syscallsubr.h>
#include <sys/sysctl.h>
#include <sys/sysent.h>
#include <sys/syslog.h>
#include <sys/sysproto.h>
#include <sys/timers.h>
#include <sys/unistd.h>
#include <sys/wait.h>
#include <vm/vm.h>
#include <vm/vm_extern.h>
#include <vm/uma.h>

#include <sys/jail.h>

#include <machine/cpu.h>

#include <security/audit/audit.h>

#define ONSIG   32              /* NSIG for osig* syscalls.  XXX. */

SDT_PROVIDER_DECLARE(proc);
SDT_PROBE_DEFINE(proc, kernel, , signal_send, signal-send);
SDT_PROBE_ARGTYPE(proc, kernel, , signal_send, 0, "struct thread *");
SDT_PROBE_ARGTYPE(proc, kernel, , signal_send, 1, "struct proc *");
SDT_PROBE_ARGTYPE(proc, kernel, , signal_send, 2, "int");
SDT_PROBE_DEFINE(proc, kernel, , signal_clear, signal-clear);
SDT_PROBE_ARGTYPE(proc, kernel, , signal_clear, 0, "int");
SDT_PROBE_ARGTYPE(proc, kernel, , signal_clear, 1, "ksiginfo_t *");
SDT_PROBE_DEFINE(proc, kernel, , signal_discard, signal-discard);
SDT_PROBE_ARGTYPE(proc, kernel, , signal_discard, 0, "struct thread *");
SDT_PROBE_ARGTYPE(proc, kernel, , signal_discard, 1, "struct proc *");
SDT_PROBE_ARGTYPE(proc, kernel, , signal_discard, 2, "int");

static int      coredump(struct thread *);
static char     *expand_name(const char *, uid_t, pid_t, struct thread *, int);
static int      killpg1(struct thread *td, int sig, int pgid, int all,
                    ksiginfo_t *ksi);
static int      issignal(struct thread *td, int stop_allowed);
static int      sigprop(int sig);
static void     tdsigwakeup(struct thread *, int, sig_t, int);
static void     sig_suspend_threads(struct thread *, struct proc *, int);
static int      filt_sigattach(struct knote *kn);
static void     filt_sigdetach(struct knote *kn);
static int      filt_signal(struct knote *kn, long hint);
static struct thread *sigtd(struct proc *p, int sig, int prop);
static void     sigqueue_start(void);

static uma_zone_t       ksiginfo_zone = NULL;
struct filterops sig_filtops = {
        .f_isfd = 0,
        .f_attach = filt_sigattach,
        .f_detach = filt_sigdetach,
        .f_event = filt_signal,
};

static int      kern_logsigexit = 1;
SYSCTL_INT(_kern, KERN_LOGSIGEXIT, logsigexit, CTLFLAG_RW, 
    &kern_logsigexit, 0, 
    "Log processes quitting on abnormal signals to syslog(3)");

static int      kern_forcesigexit = 1;
SYSCTL_INT(_kern, OID_AUTO, forcesigexit, CTLFLAG_RW,
    &kern_forcesigexit, 0, "Force trap signal to be handled");

SYSCTL_NODE(_kern, OID_AUTO, sigqueue, CTLFLAG_RW, 0, "POSIX real time signal");

static int      max_pending_per_proc = 128;
SYSCTL_INT(_kern_sigqueue, OID_AUTO, max_pending_per_proc, CTLFLAG_RW,
    &max_pending_per_proc, 0, "Max pending signals per proc");

static int      preallocate_siginfo = 1024;
TUNABLE_INT("kern.sigqueue.preallocate", &preallocate_siginfo);
SYSCTL_INT(_kern_sigqueue, OID_AUTO, preallocate, CTLFLAG_RD,
    &preallocate_siginfo, 0, "Preallocated signal memory size");

static int      signal_overflow = 0;
SYSCTL_INT(_kern_sigqueue, OID_AUTO, overflow, CTLFLAG_RD,
    &signal_overflow, 0, "Number of signals overflew");

static int      signal_alloc_fail = 0;
SYSCTL_INT(_kern_sigqueue, OID_AUTO, alloc_fail, CTLFLAG_RD,
    &signal_alloc_fail, 0, "signals failed to be allocated");

SYSINIT(signal, SI_SUB_P1003_1B, SI_ORDER_FIRST+3, sigqueue_start, NULL);

/*
 * Policy -- Can ucred cr1 send SIGIO to process cr2?
 * Should use cr_cansignal() once cr_cansignal() allows SIGIO and SIGURG
 * in the right situations.
 */
#define CANSIGIO(cr1, cr2) \
        ((cr1)->cr_uid == 0 || \
            (cr1)->cr_ruid == (cr2)->cr_ruid || \
            (cr1)->cr_uid == (cr2)->cr_ruid || \
            (cr1)->cr_ruid == (cr2)->cr_uid || \
            (cr1)->cr_uid == (cr2)->cr_uid)

static int      sugid_coredump;
SYSCTL_INT(_kern, OID_AUTO, sugid_coredump, CTLFLAG_RW, 
    &sugid_coredump, 0, "Allow setuid and setgid processes to dump core");

static int      do_coredump = 1;
SYSCTL_INT(_kern, OID_AUTO, coredump, CTLFLAG_RW,
        &do_coredump, 0, "Enable/Disable coredumps");

static int      set_core_nodump_flag = 0;
SYSCTL_INT(_kern, OID_AUTO, nodump_coredump, CTLFLAG_RW, &set_core_nodump_flag,
        0, "Enable setting the NODUMP flag on coredump files");

/*
 * Signal properties and actions.
 * The array below categorizes the signals and their default actions
 * according to the following properties:
 */
#define SA_KILL         0x01            /* terminates process by default */
#define SA_CORE         0x02            /* ditto and coredumps */
#define SA_STOP         0x04            /* suspend process */
#define SA_TTYSTOP      0x08            /* ditto, from tty */
#define SA_IGNORE       0x10            /* ignore by default */
#define SA_CONT         0x20            /* continue if suspended */
#define SA_CANTMASK     0x40            /* non-maskable, catchable */
#define SA_PROC         0x80            /* deliverable to any thread */

static int sigproptbl[NSIG] = {
        SA_KILL|SA_PROC,                /* SIGHUP */
        SA_KILL|SA_PROC,                /* SIGINT */
        SA_KILL|SA_CORE|SA_PROC,        /* SIGQUIT */
        SA_KILL|SA_CORE,                /* SIGILL */
        SA_KILL|SA_CORE,                /* SIGTRAP */
        SA_KILL|SA_CORE,                /* SIGABRT */
        SA_KILL|SA_CORE|SA_PROC,        /* SIGEMT */
        SA_KILL|SA_CORE,                /* SIGFPE */
        SA_KILL|SA_PROC,                /* SIGKILL */
        SA_KILL|SA_CORE,                /* SIGBUS */
        SA_KILL|SA_CORE,                /* SIGSEGV */
        SA_KILL|SA_CORE,                /* SIGSYS */
        SA_KILL|SA_PROC,                /* SIGPIPE */
        SA_KILL|SA_PROC,                /* SIGALRM */
        SA_KILL|SA_PROC,                /* SIGTERM */
        SA_IGNORE|SA_PROC,              /* SIGURG */
        SA_STOP|SA_PROC,                /* SIGSTOP */
        SA_STOP|SA_TTYSTOP|SA_PROC,     /* SIGTSTP */
        SA_IGNORE|SA_CONT|SA_PROC,      /* SIGCONT */
        SA_IGNORE|SA_PROC,              /* SIGCHLD */
        SA_STOP|SA_TTYSTOP|SA_PROC,     /* SIGTTIN */
        SA_STOP|SA_TTYSTOP|SA_PROC,     /* SIGTTOU */
        SA_IGNORE|SA_PROC,              /* SIGIO */
        SA_KILL,                        /* SIGXCPU */
        SA_KILL,                        /* SIGXFSZ */
        SA_KILL|SA_PROC,                /* SIGVTALRM */
        SA_KILL|SA_PROC,                /* SIGPROF */
        SA_IGNORE|SA_PROC,              /* SIGWINCH  */
        SA_IGNORE|SA_PROC,              /* SIGINFO */
        SA_KILL|SA_PROC,                /* SIGUSR1 */
        SA_KILL|SA_PROC,                /* SIGUSR2 */
};

static void reschedule_signals(struct proc *p, sigset_t block, int flags);

static void
sigqueue_start(void)
{
        ksiginfo_zone = uma_zcreate("ksiginfo", sizeof(ksiginfo_t),
                NULL, NULL, NULL, NULL, UMA_ALIGN_PTR, 0);
        uma_prealloc(ksiginfo_zone, preallocate_siginfo);
        p31b_setcfg(CTL_P1003_1B_REALTIME_SIGNALS, _POSIX_REALTIME_SIGNALS);
        p31b_setcfg(CTL_P1003_1B_RTSIG_MAX, SIGRTMAX - SIGRTMIN + 1);
        p31b_setcfg(CTL_P1003_1B_SIGQUEUE_MAX, max_pending_per_proc);
}

ksiginfo_t *
ksiginfo_alloc(int wait)
{
        int flags;

        flags = M_ZERO;
        if (! wait)
                flags |= M_NOWAIT;
        if (ksiginfo_zone != NULL)
                return ((ksiginfo_t *)uma_zalloc(ksiginfo_zone, flags));
        return (NULL);
}

void
ksiginfo_free(ksiginfo_t *ksi)
{
        uma_zfree(ksiginfo_zone, ksi);
}

static __inline int
ksiginfo_tryfree(ksiginfo_t *ksi)
{
        if (!(ksi->ksi_flags & KSI_EXT)) {
                uma_zfree(ksiginfo_zone, ksi);
                return (1);
        }
        return (0);
}

void
sigqueue_init(sigqueue_t *list, struct proc *p)
{
        SIGEMPTYSET(list->sq_signals);
        SIGEMPTYSET(list->sq_kill);
        TAILQ_INIT(&list->sq_list);
        list->sq_proc = p;
        list->sq_flags = SQ_INIT;
}

/*
 * Get a signal's ksiginfo.
 * Return:
 *      0       -       signal not found
 *      others  -       signal number
 */ 
static int
sigqueue_get(sigqueue_t *sq, int signo, ksiginfo_t *si)
{
        struct proc *p = sq->sq_proc;
        struct ksiginfo *ksi, *next;
        int count = 0;

        KASSERT(sq->sq_flags & SQ_INIT, ("sigqueue not inited"));

        if (!SIGISMEMBER(sq->sq_signals, signo))
                return (0);

        if (SIGISMEMBER(sq->sq_kill, signo)) {
                count++;
                SIGDELSET(sq->sq_kill, signo);
        }

        TAILQ_FOREACH_SAFE(ksi, &sq->sq_list, ksi_link, next) {
                if (ksi->ksi_signo == signo) {
                        if (count == 0) {
                                TAILQ_REMOVE(&sq->sq_list, ksi, ksi_link);
                                ksi->ksi_sigq = NULL;
                                ksiginfo_copy(ksi, si);
                                if (ksiginfo_tryfree(ksi) && p != NULL)
                                        p->p_pendingcnt--;
                        }
                        if (++count > 1)
                                break;
                }
        }

        if (count <= 1)
                SIGDELSET(sq->sq_signals, signo);
        si->ksi_signo = signo;
        return (signo);
}

void
sigqueue_take(ksiginfo_t *ksi)
{
        struct ksiginfo *kp;
        struct proc     *p;
        sigqueue_t      *sq;

        if (ksi == NULL || (sq = ksi->ksi_sigq) == NULL)
                return;

        p = sq->sq_proc;
        TAILQ_REMOVE(&sq->sq_list, ksi, ksi_link);
        ksi->ksi_sigq = NULL;
        if (!(ksi->ksi_flags & KSI_EXT) && p != NULL)
                p->p_pendingcnt--;

        for (kp = TAILQ_FIRST(&sq->sq_list); kp != NULL;
             kp = TAILQ_NEXT(kp, ksi_link)) {
                if (kp->ksi_signo == ksi->ksi_signo)
                        break;
        }
        if (kp == NULL && !SIGISMEMBER(sq->sq_kill, ksi->ksi_signo))
                SIGDELSET(sq->sq_signals, ksi->ksi_signo);
}

static int
sigqueue_add(sigqueue_t *sq, int signo, ksiginfo_t *si)
{
        struct proc *p = sq->sq_proc;
        struct ksiginfo *ksi;
        int ret = 0;

        KASSERT(sq->sq_flags & SQ_INIT, ("sigqueue not inited"));
        
        if (signo == SIGKILL || signo == SIGSTOP || si == NULL) {
                SIGADDSET(sq->sq_kill, signo);
                goto out_set_bit;
        }

        /* directly insert the ksi, don't copy it */
        if (si->ksi_flags & KSI_INS) {
                if (si->ksi_flags & KSI_HEAD)
                        TAILQ_INSERT_HEAD(&sq->sq_list, si, ksi_link);
                else
                        TAILQ_INSERT_TAIL(&sq->sq_list, si, ksi_link);
                si->ksi_sigq = sq;
                goto out_set_bit;
        }

        if (__predict_false(ksiginfo_zone == NULL)) {
                SIGADDSET(sq->sq_kill, signo);
                goto out_set_bit;
        }
        
        if (p != NULL && p->p_pendingcnt >= max_pending_per_proc) {
                signal_overflow++;
                ret = EAGAIN;
        } else if ((ksi = ksiginfo_alloc(0)) == NULL) {
                signal_alloc_fail++;
                ret = EAGAIN;
        } else {
                if (p != NULL)
                        p->p_pendingcnt++;
                ksiginfo_copy(si, ksi);
                ksi->ksi_signo = signo;
                if (si->ksi_flags & KSI_HEAD)
                        TAILQ_INSERT_HEAD(&sq->sq_list, ksi, ksi_link);
                else
                        TAILQ_INSERT_TAIL(&sq->sq_list, ksi, ksi_link);
                ksi->ksi_sigq = sq;
        }

        if ((si->ksi_flags & KSI_TRAP) != 0 ||
            (si->ksi_flags & KSI_SIGQ) == 0) {
                if (ret != 0)
                        SIGADDSET(sq->sq_kill, signo);
                ret = 0;
                goto out_set_bit;
        }

        if (ret != 0)
                return (ret);
        
out_set_bit:
        SIGADDSET(sq->sq_signals, signo);
        return (ret);
}

void
sigqueue_flush(sigqueue_t *sq)
{
        struct proc *p = sq->sq_proc;
        ksiginfo_t *ksi;

        KASSERT(sq->sq_flags & SQ_INIT, ("sigqueue not inited"));

        if (p != NULL)
                PROC_LOCK_ASSERT(p, MA_OWNED);

        while ((ksi = TAILQ_FIRST(&sq->sq_list)) != NULL) {
                TAILQ_REMOVE(&sq->sq_list, ksi, ksi_link);
                ksi->ksi_sigq = NULL;
                if (ksiginfo_tryfree(ksi) && p != NULL)
                        p->p_pendingcnt--;
        }

        SIGEMPTYSET(sq->sq_signals);
        SIGEMPTYSET(sq->sq_kill);
}

static void
sigqueue_move_set(sigqueue_t *src, sigqueue_t *dst, const sigset_t *set)
{
        sigset_t tmp;
        struct proc *p1, *p2;
        ksiginfo_t *ksi, *next;

        KASSERT(src->sq_flags & SQ_INIT, ("src sigqueue not inited"));
        KASSERT(dst->sq_flags & SQ_INIT, ("dst sigqueue not inited"));
        p1 = src->sq_proc;
        p2 = dst->sq_proc;
        /* Move siginfo to target list */
        TAILQ_FOREACH_SAFE(ksi, &src->sq_list, ksi_link, next) {
                if (SIGISMEMBER(*set, ksi->ksi_signo)) {
                        TAILQ_REMOVE(&src->sq_list, ksi, ksi_link);
                        if (p1 != NULL)
                                p1->p_pendingcnt--;
                        TAILQ_INSERT_TAIL(&dst->sq_list, ksi, ksi_link);
                        ksi->ksi_sigq = dst;
                        if (p2 != NULL)
                                p2->p_pendingcnt++;
                }
        }

        /* Move pending bits to target list */
        tmp = src->sq_kill;
        SIGSETAND(tmp, *set);
        SIGSETOR(dst->sq_kill, tmp);
        SIGSETNAND(src->sq_kill, tmp);

        tmp = src->sq_signals;
        SIGSETAND(tmp, *set);
        SIGSETOR(dst->sq_signals, tmp);
        SIGSETNAND(src->sq_signals, tmp);
}

#if 0
static void
sigqueue_move(sigqueue_t *src, sigqueue_t *dst, int signo)
{
        sigset_t set;

        SIGEMPTYSET(set);
        SIGADDSET(set, signo);
        sigqueue_move_set(src, dst, &set);
}
#endif

static void
sigqueue_delete_set(sigqueue_t *sq, const sigset_t *set)
{
        struct proc *p = sq->sq_proc;
        ksiginfo_t *ksi, *next;

        KASSERT(sq->sq_flags & SQ_INIT, ("src sigqueue not inited"));

        /* Remove siginfo queue */
        TAILQ_FOREACH_SAFE(ksi, &sq->sq_list, ksi_link, next) {
                if (SIGISMEMBER(*set, ksi->ksi_signo)) {
                        TAILQ_REMOVE(&sq->sq_list, ksi, ksi_link);
                        ksi->ksi_sigq = NULL;
                        if (ksiginfo_tryfree(ksi) && p != NULL)
                                p->p_pendingcnt--;
                }
        }
        SIGSETNAND(sq->sq_kill, *set);
        SIGSETNAND(sq->sq_signals, *set);
}

void
sigqueue_delete(sigqueue_t *sq, int signo)
{
        sigset_t set;

        SIGEMPTYSET(set);
        SIGADDSET(set, signo);
        sigqueue_delete_set(sq, &set);
}

/* Remove a set of signals for a process */
static void
sigqueue_delete_set_proc(struct proc *p, const sigset_t *set)
{
        sigqueue_t worklist;
        struct thread *td0;

        PROC_LOCK_ASSERT(p, MA_OWNED);

        sigqueue_init(&worklist, NULL);
        sigqueue_move_set(&p->p_sigqueue, &worklist, set);

        FOREACH_THREAD_IN_PROC(p, td0)
                sigqueue_move_set(&td0->td_sigqueue, &worklist, set);

        sigqueue_flush(&worklist);
}

void
sigqueue_delete_proc(struct proc *p, int signo)
{
        sigset_t set;

        SIGEMPTYSET(set);
        SIGADDSET(set, signo);
        sigqueue_delete_set_proc(p, &set);
}

static void
sigqueue_delete_stopmask_proc(struct proc *p)
{
        sigset_t set;

        SIGEMPTYSET(set);
        SIGADDSET(set, SIGSTOP);
        SIGADDSET(set, SIGTSTP);
        SIGADDSET(set, SIGTTIN);
        SIGADDSET(set, SIGTTOU);
        sigqueue_delete_set_proc(p, &set);
}

/*
 * Determine signal that should be delivered to process p, the current
 * process, 0 if none.  If there is a pending stop signal with default
 * action, the process stops in issignal().
 */
int
cursig(struct thread *td, int stop_allowed)
{
        PROC_LOCK_ASSERT(td->td_proc, MA_OWNED);
        KASSERT(stop_allowed == SIG_STOP_ALLOWED ||
            stop_allowed == SIG_STOP_NOT_ALLOWED, ("cursig: stop_allowed"));
        mtx_assert(&td->td_proc->p_sigacts->ps_mtx, MA_OWNED);
        THREAD_LOCK_ASSERT(td, MA_NOTOWNED);
        return (SIGPENDING(td) ? issignal(td, stop_allowed) : 0);
}

/*
 * Arrange for ast() to handle unmasked pending signals on return to user
 * mode.  This must be called whenever a signal is added to td_sigqueue or
 * unmasked in td_sigmask.
 */
void
signotify(struct thread *td)
{
        struct proc *p;

        p = td->td_proc;

        PROC_LOCK_ASSERT(p, MA_OWNED);

        if (SIGPENDING(td)) {
                thread_lock(td);
                td->td_flags |= TDF_NEEDSIGCHK | TDF_ASTPENDING;
                thread_unlock(td);
        }
}

int
sigonstack(size_t sp)
{
        struct thread *td = curthread;

        return ((td->td_pflags & TDP_ALTSTACK) ?
#if defined(COMPAT_43)
            ((td->td_sigstk.ss_size == 0) ?
                (td->td_sigstk.ss_flags & SS_ONSTACK) :
                ((sp - (size_t)td->td_sigstk.ss_sp) < td->td_sigstk.ss_size))
#else
            ((sp - (size_t)td->td_sigstk.ss_sp) < td->td_sigstk.ss_size)
#endif
            : 0);
}

static __inline int
sigprop(int sig)
{

        if (sig > 0 && sig < NSIG)
                return (sigproptbl[_SIG_IDX(sig)]);
        return (0);
}

int
sig_ffs(sigset_t *set)
{
        int i;

        for (i = 0; i < _SIG_WORDS; i++)
                if (set->__bits[i])
                        return (ffs(set->__bits[i]) + (i * 32));
        return (0);
}

/*
 * kern_sigaction
 * sigaction
 * freebsd4_sigaction
 * osigaction
 */
int
kern_sigaction(td, sig, act, oact, flags)
        struct thread *td;
        register int sig;
        struct sigaction *act, *oact;
        int flags;
{
        struct sigacts *ps;
        struct proc *p = td->td_proc;

        if (!_SIG_VALID(sig))
                return (EINVAL);

        PROC_LOCK(p);
        ps = p->p_sigacts;
        mtx_lock(&ps->ps_mtx);
        if (oact) {
                oact->sa_mask = ps->ps_catchmask[_SIG_IDX(sig)];
                oact->sa_flags = 0;
                if (SIGISMEMBER(ps->ps_sigonstack, sig))
                        oact->sa_flags |= SA_ONSTACK;
                if (!SIGISMEMBER(ps->ps_sigintr, sig))
                        oact->sa_flags |= SA_RESTART;
                if (SIGISMEMBER(ps->ps_sigreset, sig))
                        oact->sa_flags |= SA_RESETHAND;
                if (SIGISMEMBER(ps->ps_signodefer, sig))
                        oact->sa_flags |= SA_NODEFER;
                if (SIGISMEMBER(ps->ps_siginfo, sig)) {
                        oact->sa_flags |= SA_SIGINFO;
                        oact->sa_sigaction =
                            (__siginfohandler_t *)ps->ps_sigact[_SIG_IDX(sig)];
                } else
                        oact->sa_handler = ps->ps_sigact[_SIG_IDX(sig)];
                if (sig == SIGCHLD && ps->ps_flag & PS_NOCLDSTOP)
                        oact->sa_flags |= SA_NOCLDSTOP;
                if (sig == SIGCHLD && ps->ps_flag & PS_NOCLDWAIT)
                        oact->sa_flags |= SA_NOCLDWAIT;
        }
        if (act) {
                if ((sig == SIGKILL || sig == SIGSTOP) &&
                    act->sa_handler != SIG_DFL) {
                        mtx_unlock(&ps->ps_mtx);
                        PROC_UNLOCK(p);
                        return (EINVAL);
                }

                /*
                 * Change setting atomically.
                 */

                ps->ps_catchmask[_SIG_IDX(sig)] = act->sa_mask;
                SIG_CANTMASK(ps->ps_catchmask[_SIG_IDX(sig)]);
                if (act->sa_flags & SA_SIGINFO) {
                        ps->ps_sigact[_SIG_IDX(sig)] =
                            (__sighandler_t *)act->sa_sigaction;
                        SIGADDSET(ps->ps_siginfo, sig);
                } else {
                        ps->ps_sigact[_SIG_IDX(sig)] = act->sa_handler;
                        SIGDELSET(ps->ps_siginfo, sig);
                }
                if (!(act->sa_flags & SA_RESTART))
                        SIGADDSET(ps->ps_sigintr, sig);
                else
                        SIGDELSET(ps->ps_sigintr, sig);
                if (act->sa_flags & SA_ONSTACK)
                        SIGADDSET(ps->ps_sigonstack, sig);
                else
                        SIGDELSET(ps->ps_sigonstack, sig);
                if (act->sa_flags & SA_RESETHAND)
                        SIGADDSET(ps->ps_sigreset, sig);
                else
                        SIGDELSET(ps->ps_sigreset, sig);
                if (act->sa_flags & SA_NODEFER)
                        SIGADDSET(ps->ps_signodefer, sig);
                else
                        SIGDELSET(ps->ps_signodefer, sig);
                if (sig == SIGCHLD) {
                        if (act->sa_flags & SA_NOCLDSTOP)
                                ps->ps_flag |= PS_NOCLDSTOP;
                        else
                                ps->ps_flag &= ~PS_NOCLDSTOP;
                        if (act->sa_flags & SA_NOCLDWAIT) {
                                /*
                                 * Paranoia: since SA_NOCLDWAIT is implemented
                                 * by reparenting the dying child to PID 1 (and
                                 * trust it to reap the zombie), PID 1 itself
                                 * is forbidden to set SA_NOCLDWAIT.
                                 */
                                if (p->p_pid == 1)
                                        ps->ps_flag &= ~PS_NOCLDWAIT;
                                else
                                        ps->ps_flag |= PS_NOCLDWAIT;
                        } else
                                ps->ps_flag &= ~PS_NOCLDWAIT;
                        if (ps->ps_sigact[_SIG_IDX(SIGCHLD)] == SIG_IGN)
                                ps->ps_flag |= PS_CLDSIGIGN;
                        else
                                ps->ps_flag &= ~PS_CLDSIGIGN;
                }
                /*
                 * Set bit in ps_sigignore for signals that are set to SIG_IGN,
                 * and for signals set to SIG_DFL where the default is to
                 * ignore. However, don't put SIGCONT in ps_sigignore, as we
                 * have to restart the process.
                 */
                if (ps->ps_sigact[_SIG_IDX(sig)] == SIG_IGN ||
                    (sigprop(sig) & SA_IGNORE &&
                     ps->ps_sigact[_SIG_IDX(sig)] == SIG_DFL)) {
                        /* never to be seen again */
                        sigqueue_delete_proc(p, sig);
                        if (sig != SIGCONT)
                                /* easier in psignal */
                                SIGADDSET(ps->ps_sigignore, sig);
                        SIGDELSET(ps->ps_sigcatch, sig);
                } else {
                        SIGDELSET(ps->ps_sigignore, sig);
                        if (ps->ps_sigact[_SIG_IDX(sig)] == SIG_DFL)
                                SIGDELSET(ps->ps_sigcatch, sig);
                        else
                                SIGADDSET(ps->ps_sigcatch, sig);
                }
#ifdef COMPAT_FREEBSD4
                if (ps->ps_sigact[_SIG_IDX(sig)] == SIG_IGN ||
                    ps->ps_sigact[_SIG_IDX(sig)] == SIG_DFL ||
                    (flags & KSA_FREEBSD4) == 0)
                        SIGDELSET(ps->ps_freebsd4, sig);
                else
                        SIGADDSET(ps->ps_freebsd4, sig);
#endif
#ifdef COMPAT_43
                if (ps->ps_sigact[_SIG_IDX(sig)] == SIG_IGN ||
                    ps->ps_sigact[_SIG_IDX(sig)] == SIG_DFL ||
                    (flags & KSA_OSIGSET) == 0)
                        SIGDELSET(ps->ps_osigset, sig);
                else
                        SIGADDSET(ps->ps_osigset, sig);
#endif
        }
        mtx_unlock(&ps->ps_mtx);
        PROC_UNLOCK(p);
        return (0);
}

#ifndef _SYS_SYSPROTO_H_
struct sigaction_args {
        int     sig;
        struct  sigaction *act;
        struct  sigaction *oact;
};
#endif
int
sys_sigaction(td, uap)
        struct thread *td;
        register struct sigaction_args *uap;
{
        struct sigaction act, oact;
        register struct sigaction *actp, *oactp;
        int error;

        actp = (uap->act != NULL) ? &act : NULL;
        oactp = (uap->oact != NULL) ? &oact : NULL;
        if (actp) {
                error = copyin(uap->act, actp, sizeof(act));
                if (error)
                        return (error);
        }
        error = kern_sigaction(td, uap->sig, actp, oactp, 0);
        if (oactp && !error)
                error = copyout(oactp, uap->oact, sizeof(oact));
        return (error);
}

#ifdef COMPAT_FREEBSD4
#ifndef _SYS_SYSPROTO_H_
struct freebsd4_sigaction_args {
        int     sig;
        struct  sigaction *act;
        struct  sigaction *oact;
};
#endif
int
freebsd4_sigaction(td, uap)
        struct thread *td;
        register struct freebsd4_sigaction_args *uap;
{
        struct sigaction act, oact;
        register struct sigaction *actp, *oactp;
        int error;


        actp = (uap->act != NULL) ? &act : NULL;
        oactp = (uap->oact != NULL) ? &oact : NULL;
        if (actp) {
                error = copyin(uap->act, actp, sizeof(act));
                if (error)
                        return (error);
        }
        error = kern_sigaction(td, uap->sig, actp, oactp, KSA_FREEBSD4);
        if (oactp && !error)
                error = copyout(oactp, uap->oact, sizeof(oact));
        return (error);
}
#endif  /* COMAPT_FREEBSD4 */

#ifdef COMPAT_43        /* XXX - COMPAT_FBSD3 */
#ifndef _SYS_SYSPROTO_H_
struct osigaction_args {
        int     signum;
        struct  osigaction *nsa;
        struct  osigaction *osa;
};
#endif
int
osigaction(td, uap)
        struct thread *td;
        register struct osigaction_args *uap;
{
        struct osigaction sa;
        struct sigaction nsa, osa;
        register struct sigaction *nsap, *osap;
        int error;

        if (uap->signum <= 0 || uap->signum >= ONSIG)
                return (EINVAL);

        nsap = (uap->nsa != NULL) ? &nsa : NULL;
        osap = (uap->osa != NULL) ? &osa : NULL;

        if (nsap) {
                error = copyin(uap->nsa, &sa, sizeof(sa));
                if (error)
                        return (error);
                nsap->sa_handler = sa.sa_handler;
                nsap->sa_flags = sa.sa_flags;
                OSIG2SIG(sa.sa_mask, nsap->sa_mask);
        }
        error = kern_sigaction(td, uap->signum, nsap, osap, KSA_OSIGSET);
        if (osap && !error) {
                sa.sa_handler = osap->sa_handler;
                sa.sa_flags = osap->sa_flags;
                SIG2OSIG(osap->sa_mask, sa.sa_mask);
                error = copyout(&sa, uap->osa, sizeof(sa));
        }
        return (error);
}

#if !defined(__i386__)
/* Avoid replicating the same stub everywhere */
int
osigreturn(td, uap)
        struct thread *td;
        struct osigreturn_args *uap;
{

        return (nosys(td, (struct nosys_args *)uap));
}
#endif
#endif /* COMPAT_43 */

/*
 * Initialize signal state for process 0;
 * set to ignore signals that are ignored by default.
 */
void
siginit(p)
        struct proc *p;
{
        register int i;
        struct sigacts *ps;

        PROC_LOCK(p);
        ps = p->p_sigacts;
        mtx_lock(&ps->ps_mtx);
        for (i = 1; i <= NSIG; i++)
                if (sigprop(i) & SA_IGNORE && i != SIGCONT)
                        SIGADDSET(ps->ps_sigignore, i);
        mtx_unlock(&ps->ps_mtx);
        PROC_UNLOCK(p);
}

/*
 * Reset signals for an exec of the specified process.
 */
void
execsigs(struct proc *p)
{
        struct sigacts *ps;
        int sig;
        struct thread *td;

        /*
         * Reset caught signals.  Held signals remain held
         * through td_sigmask (unless they were caught,
         * and are now ignored by default).
         */
        PROC_LOCK_ASSERT(p, MA_OWNED);
        td = FIRST_THREAD_IN_PROC(p);
        ps = p->p_sigacts;
        mtx_lock(&ps->ps_mtx);
        while (SIGNOTEMPTY(ps->ps_sigcatch)) {
                sig = sig_ffs(&ps->ps_sigcatch);
                SIGDELSET(ps->ps_sigcatch, sig);
                if (sigprop(sig) & SA_IGNORE) {
                        if (sig != SIGCONT)
                                SIGADDSET(ps->ps_sigignore, sig);
                        sigqueue_delete_proc(p, sig);
                }
                ps->ps_sigact[_SIG_IDX(sig)] = SIG_DFL;
        }
        /*
         * Reset stack state to the user stack.
         * Clear set of signals caught on the signal stack.
         */
        td->td_sigstk.ss_flags = SS_DISABLE;
        td->td_sigstk.ss_size = 0;
        td->td_sigstk.ss_sp = 0;
        td->td_pflags &= ~TDP_ALTSTACK;
        /*
         * Reset no zombies if child dies flag as Solaris does.
         */
        ps->ps_flag &= ~(PS_NOCLDWAIT | PS_CLDSIGIGN);
        if (ps->ps_sigact[_SIG_IDX(SIGCHLD)] == SIG_IGN)
                ps->ps_sigact[_SIG_IDX(SIGCHLD)] = SIG_DFL;
        mtx_unlock(&ps->ps_mtx);
}

/*
 * kern_sigprocmask()
 *
 *      Manipulate signal mask.
 */
int
kern_sigprocmask(struct thread *td, int how, sigset_t *set, sigset_t *oset,
    int flags)
{
        sigset_t new_block, oset1;
        struct proc *p;
        int error;

        p = td->td_proc;
        if (!(flags & SIGPROCMASK_PROC_LOCKED))
                PROC_LOCK(p);
        if (oset != NULL)
                *oset = td->td_sigmask;

        error = 0;
        if (set != NULL) {
                switch (how) {
                case SIG_BLOCK:
                        SIG_CANTMASK(*set);
                        oset1 = td->td_sigmask;
                        SIGSETOR(td->td_sigmask, *set);
                        new_block = td->td_sigmask;
                        SIGSETNAND(new_block, oset1);
                        break;
                case SIG_UNBLOCK:
                        SIGSETNAND(td->td_sigmask, *set);
                        signotify(td);
                        goto out;
                case SIG_SETMASK:
                        SIG_CANTMASK(*set);
                        oset1 = td->td_sigmask;
                        if (flags & SIGPROCMASK_OLD)
                                SIGSETLO(td->td_sigmask, *set);
                        else
                                td->td_sigmask = *set;
                        new_block = td->td_sigmask;
                        SIGSETNAND(new_block, oset1);
                        signotify(td);
                        break;
                default:
                        error = EINVAL;
                        goto out;
                }

                /*
                 * The new_block set contains signals that were not previously
                 * blocked, but are blocked now.
                 *
                 * In case we block any signal that was not previously blocked
                 * for td, and process has the signal pending, try to schedule
                 * signal delivery to some thread that does not block the
                 * signal, possibly waking it up.
                 */
                if (p->p_numthreads != 1)
                        reschedule_signals(p, new_block, flags);
        }

out:
        if (!(flags & SIGPROCMASK_PROC_LOCKED))
                PROC_UNLOCK(p);
        return (error);
}

#ifndef _SYS_SYSPROTO_H_
struct sigprocmask_args {
        int     how;
        const sigset_t *set;
        sigset_t *oset;
};
#endif
int
sys_sigprocmask(td, uap)
        register struct thread *td;
        struct sigprocmask_args *uap;
{
        sigset_t set, oset;
        sigset_t *setp, *osetp;
        int error;

        setp = (uap->set != NULL) ? &set : NULL;
        osetp = (uap->oset != NULL) ? &oset : NULL;
        if (setp) {
                error = copyin(uap->set, setp, sizeof(set));
                if (error)
                        return (error);
        }
        error = kern_sigprocmask(td, uap->how, setp, osetp, 0);
        if (osetp && !error) {
                error = copyout(osetp, uap->oset, sizeof(oset));
        }
        return (error);
}

#ifdef COMPAT_43        /* XXX - COMPAT_FBSD3 */
#ifndef _SYS_SYSPROTO_H_
struct osigprocmask_args {
        int     how;
        osigset_t mask;
};
#endif
int
osigprocmask(td, uap)
        register struct thread *td;
        struct osigprocmask_args *uap;
{
        sigset_t set, oset;
        int error;

        OSIG2SIG(uap->mask, set);
        error = kern_sigprocmask(td, uap->how, &set, &oset, 1);
        SIG2OSIG(oset, td->td_retval[0]);
        return (error);
}
#endif /* COMPAT_43 */

int
sys_sigwait(struct thread *td, struct sigwait_args *uap)
{
        ksiginfo_t ksi;
        sigset_t set;
        int error;

        error = copyin(uap->set, &set, sizeof(set));
        if (error) {
                td->td_retval[0] = error;
                return (0);
        }

        error = kern_sigtimedwait(td, set, &ksi, NULL);
        if (error) {
                if (error == EINTR && td->td_proc->p_osrel < P_OSREL_SIGWAIT)
                        error = ERESTART;
                if (error == ERESTART)
                        return (error);
                td->td_retval[0] = error;
                return (0);
        }

        error = copyout(&ksi.ksi_signo, uap->sig, sizeof(ksi.ksi_signo));
        td->td_retval[0] = error;
        return (0);
}

int
sys_sigtimedwait(struct thread *td, struct sigtimedwait_args *uap)
{
        struct timespec ts;
        struct timespec *timeout;
        sigset_t set;
        ksiginfo_t ksi;
        int error;

        if (uap->timeout) {
                error = copyin(uap->timeout, &ts, sizeof(ts));
                if (error)
                        return (error);

                timeout = &ts;
        } else
                timeout = NULL;

        error = copyin(uap->set, &set, sizeof(set));
        if (error)
                return (error);

        error = kern_sigtimedwait(td, set, &ksi, timeout);
        if (error)
                return (error);

        if (uap->info)
                error = copyout(&ksi.ksi_info, uap->info, sizeof(siginfo_t));

        if (error == 0)
                td->td_retval[0] = ksi.ksi_signo;
        return (error);
}

int
sys_sigwaitinfo(struct thread *td, struct sigwaitinfo_args *uap)
{
        ksiginfo_t ksi;
        sigset_t set;
        int error;

        error = copyin(uap->set, &set, sizeof(set));
        if (error)
                return (error);

        error = kern_sigtimedwait(td, set, &ksi, NULL);
        if (error)
                return (error);

        if (uap->info)
                error = copyout(&ksi.ksi_info, uap->info, sizeof(siginfo_t));
        
        if (error == 0)
                td->td_retval[0] = ksi.ksi_signo;
        return (error);
}

int
kern_sigtimedwait(struct thread *td, sigset_t waitset, ksiginfo_t *ksi,
        struct timespec *timeout)
{
        struct sigacts *ps;
        sigset_t saved_mask, new_block;
        struct proc *p;
        int error, sig, timo, timevalid = 0;
        struct timespec rts, ets, ts;
        struct timeval tv;

        p = td->td_proc;
        error = 0;
        ets.tv_sec = 0;
        ets.tv_nsec = 0;

        if (timeout != NULL) {
                if (timeout->tv_nsec >= 0 && timeout->tv_nsec < 1000000000) {
                        timevalid = 1;
                        getnanouptime(&rts);
                        ets = rts;
                        timespecadd(&ets, timeout);
                }
        }
        ksiginfo_init(ksi);
        /* Some signals can not be waited for. */
        SIG_CANTMASK(waitset);
        ps = p->p_sigacts;
        PROC_LOCK(p);
        saved_mask = td->td_sigmask;
        SIGSETNAND(td->td_sigmask, waitset);
        for (;;) {
                mtx_lock(&ps->ps_mtx);
                sig = cursig(td, SIG_STOP_ALLOWED);
                mtx_unlock(&ps->ps_mtx);
                if (sig != 0 && SIGISMEMBER(waitset, sig)) {
                        if (sigqueue_get(&td->td_sigqueue, sig, ksi) != 0 ||
                            sigqueue_get(&p->p_sigqueue, sig, ksi) != 0) {
                                error = 0;
                                break;
                        }
                }

                if (error != 0)
                        break;

                /*
                 * POSIX says this must be checked after looking for pending
                 * signals.
                 */
                if (timeout != NULL) {
                        if (!timevalid) {
                                error = EINVAL;
                                break;
                        }
                        getnanouptime(&rts);
                        if (timespeccmp(&rts, &ets, >=)) {
                                error = EAGAIN;
                                break;
                        }
                        ts = ets;
                        timespecsub(&ts, &rts);
                        TIMESPEC_TO_TIMEVAL(&tv, &ts);
                        timo = tvtohz(&tv);
                } else {
                        timo = 0;
                }

                error = msleep(ps, &p->p_mtx, PPAUSE|PCATCH, "sigwait", timo);

                if (timeout != NULL) {
                        if (error == ERESTART) {
                                /* Timeout can not be restarted. */
                                error = EINTR;
                        } else if (error == EAGAIN) {
                                /* We will calculate timeout by ourself. */
                                error = 0;
                        }
                }
        }

        new_block = saved_mask;
        SIGSETNAND(new_block, td->td_sigmask);
        td->td_sigmask = saved_mask;
        /*
         * Fewer signals can be delivered to us, reschedule signal
         * notification.
         */
        if (p->p_numthreads != 1)
                reschedule_signals(p, new_block, 0);

        if (error == 0) {
                SDT_PROBE(proc, kernel, , signal_clear, sig, ksi, 0, 0, 0);
                
                if (ksi->ksi_code == SI_TIMER)
                        itimer_accept(p, ksi->ksi_timerid, ksi);

#ifdef KTRACE
                if (KTRPOINT(td, KTR_PSIG)) {
                        sig_t action;

                        mtx_lock(&ps->ps_mtx);
                        action = ps->ps_sigact[_SIG_IDX(sig)];
                        mtx_unlock(&ps->ps_mtx);
                        ktrpsig(sig, action, &td->td_sigmask, ksi->ksi_code);
                }
#endif
                if (sig == SIGKILL)
                        sigexit(td, sig);
        }
        PROC_UNLOCK(p);
        return (error);
}

#ifndef _SYS_SYSPROTO_H_
struct sigpending_args {
        sigset_t        *set;
};
#endif
int
sys_sigpending(td, uap)
        struct thread *td;
        struct sigpending_args *uap;
{
        struct proc *p = td->td_proc;
        sigset_t pending;

        PROC_LOCK(p);
        pending = p->p_sigqueue.sq_signals;
        SIGSETOR(pending, td->td_sigqueue.sq_signals);
        PROC_UNLOCK(p);
        return (copyout(&pending, uap->set, sizeof(sigset_t)));
}

#ifdef COMPAT_43        /* XXX - COMPAT_FBSD3 */
#ifndef _SYS_SYSPROTO_H_
struct osigpending_args {
        int     dummy;
};
#endif
int
osigpending(td, uap)
        struct thread *td;
        struct osigpending_args *uap;
{
        struct proc *p = td->td_proc;
        sigset_t pending;

        PROC_LOCK(p);
        pending = p->p_sigqueue.sq_signals;
        SIGSETOR(pending, td->td_sigqueue.sq_signals);
        PROC_UNLOCK(p);
        SIG2OSIG(pending, td->td_retval[0]);
        return (0);
}
#endif /* COMPAT_43 */

#if defined(COMPAT_43)
/*
 * Generalized interface signal handler, 4.3-compatible.
 */
#ifndef _SYS_SYSPROTO_H_
struct osigvec_args {
        int     signum;
        struct  sigvec *nsv;
        struct  sigvec *osv;
};
#endif
/* ARGSUSED */
int
osigvec(td, uap)
        struct thread *td;
        register struct osigvec_args *uap;
{
        struct sigvec vec;
        struct sigaction nsa, osa;
        register struct sigaction *nsap, *osap;
        int error;

        if (uap->signum <= 0 || uap->signum >= ONSIG)
                return (EINVAL);
        nsap = (uap->nsv != NULL) ? &nsa : NULL;
        osap = (uap->osv != NULL) ? &osa : NULL;
        if (nsap) {
                error = copyin(uap->nsv, &vec, sizeof(vec));
                if (error)
                        return (error);
                nsap->sa_handler = vec.sv_handler;
                OSIG2SIG(vec.sv_mask, nsap->sa_mask);
                nsap->sa_flags = vec.sv_flags;
                nsap->sa_flags ^= SA_RESTART;   /* opposite of SV_INTERRUPT */
        }
        error = kern_sigaction(td, uap->signum, nsap, osap, KSA_OSIGSET);
        if (osap && !error) {
                vec.sv_handler = osap->sa_handler;
                SIG2OSIG(osap->sa_mask, vec.sv_mask);
                vec.sv_flags = osap->sa_flags;
                vec.sv_flags &= ~SA_NOCLDWAIT;
                vec.sv_flags ^= SA_RESTART;
                error = copyout(&vec, uap->osv, sizeof(vec));
        }
        return (error);
}

#ifndef _SYS_SYSPROTO_H_
struct osigblock_args {
        int     mask;
};
#endif
int
osigblock(td, uap)
        register struct thread *td;
        struct osigblock_args *uap;
{
        sigset_t set, oset;

        OSIG2SIG(uap->mask, set);
        kern_sigprocmask(td, SIG_BLOCK, &set, &oset, 0);
        SIG2OSIG(oset, td->td_retval[0]);
        return (0);
}

#ifndef _SYS_SYSPROTO_H_
struct osigsetmask_args {
        int     mask;
};
#endif
int
osigsetmask(td, uap)
        struct thread *td;
        struct osigsetmask_args *uap;
{
        sigset_t set, oset;

        OSIG2SIG(uap->mask, set);
        kern_sigprocmask(td, SIG_SETMASK, &set, &oset, 0);
        SIG2OSIG(oset, td->td_retval[0]);
        return (0);
}
#endif /* COMPAT_43 */

/*
 * Suspend calling thread until signal, providing mask to be set in the
 * meantime. 
 */
#ifndef _SYS_SYSPROTO_H_
struct sigsuspend_args {
        const sigset_t *sigmask;
};
#endif
/* ARGSUSED */
int
sys_sigsuspend(td, uap)
        struct thread *td;
        struct sigsuspend_args *uap;
{
        sigset_t mask;
        int error;

        error = copyin(uap->sigmask, &mask, sizeof(mask));
        if (error)
                return (error);
        return (kern_sigsuspend(td, mask));
}

int
kern_sigsuspend(struct thread *td, sigset_t mask)
{
        struct proc *p = td->td_proc;
        int has_sig, sig;

        /*
         * When returning from sigsuspend, we want
         * the old mask to be restored after the
         * signal handler has finished.  Thus, we
         * save it here and mark the sigacts structure
         * to indicate this.
         */
        PROC_LOCK(p);
        kern_sigprocmask(td, SIG_SETMASK, &mask, &td->td_oldsigmask,
            SIGPROCMASK_PROC_LOCKED);
        td->td_pflags |= TDP_OLDMASK;

        /*
         * Process signals now. Otherwise, we can get spurious wakeup
         * due to signal entered process queue, but delivered to other
         * thread. But sigsuspend should return only on signal
         * delivery.
         */
        (p->p_sysent->sv_set_syscall_retval)(td, EINTR);
        for (has_sig = 0; !has_sig;) {
                while (msleep(&p->p_sigacts, &p->p_mtx, PPAUSE|PCATCH, "pause",
                        0) == 0)
                        /* void */;
                thread_suspend_check(0);
                mtx_lock(&p->p_sigacts->ps_mtx);
                while ((sig = cursig(td, SIG_STOP_ALLOWED)) != 0)
                        has_sig += postsig(sig);
                mtx_unlock(&p->p_sigacts->ps_mtx);
        }
        PROC_UNLOCK(p);
        td->td_errno = EINTR;
        td->td_pflags |= TDP_NERRNO;
        return (EJUSTRETURN);
}

#ifdef COMPAT_43        /* XXX - COMPAT_FBSD3 */
/*
 * Compatibility sigsuspend call for old binaries.  Note nonstandard calling
 * convention: libc stub passes mask, not pointer, to save a copyin.
 */
#ifndef _SYS_SYSPROTO_H_
struct osigsuspend_args {
        osigset_t mask;
};
#endif
/* ARGSUSED */
int
osigsuspend(td, uap)
        struct thread *td;
        struct osigsuspend_args *uap;
{
        sigset_t mask;

        OSIG2SIG(uap->mask, mask);
        return (kern_sigsuspend(td, mask));
}
#endif /* COMPAT_43 */

#if defined(COMPAT_43)
#ifndef _SYS_SYSPROTO_H_
struct osigstack_args {
        struct  sigstack *nss;
        struct  sigstack *oss;
};
#endif
/* ARGSUSED */
int
osigstack(td, uap)
        struct thread *td;
        register struct osigstack_args *uap;
{
        struct sigstack nss, oss;
        int error = 0;

        if (uap->nss != NULL) {
                error = copyin(uap->nss, &nss, sizeof(nss));
                if (error)
                        return (error);
        }
        oss.ss_sp = td->td_sigstk.ss_sp;
        oss.ss_onstack = sigonstack(cpu_getstack(td));
        if (uap->nss != NULL) {
                td->td_sigstk.ss_sp = nss.ss_sp;
                td->td_sigstk.ss_size = 0;
                td->td_sigstk.ss_flags |= nss.ss_onstack & SS_ONSTACK;
                td->td_pflags |= TDP_ALTSTACK;
        }
        if (uap->oss != NULL)
                error = copyout(&oss, uap->oss, sizeof(oss));

        return (error);
}
#endif /* COMPAT_43 */

#ifndef _SYS_SYSPROTO_H_
struct sigaltstack_args {
        stack_t *ss;
        stack_t *oss;
};
#endif
/* ARGSUSED */
int
sys_sigaltstack(td, uap)
        struct thread *td;
        register struct sigaltstack_args *uap;
{
        stack_t ss, oss;
        int error;

        if (uap->ss != NULL) {
                error = copyin(uap->ss, &ss, sizeof(ss));
                if (error)
                        return (error);
        }
        error = kern_sigaltstack(td, (uap->ss != NULL) ? &ss : NULL,
            (uap->oss != NULL) ? &oss : NULL);
        if (error)
                return (error);
        if (uap->oss != NULL)
                error = copyout(&oss, uap->oss, sizeof(stack_t));
        return (error);
}

int
kern_sigaltstack(struct thread *td, stack_t *ss, stack_t *oss)
{
        struct proc *p = td->td_proc;
        int oonstack;

        oonstack = sigonstack(cpu_getstack(td));

        if (oss != NULL) {
                *oss = td->td_sigstk;
                oss->ss_flags = (td->td_pflags & TDP_ALTSTACK)
                    ? ((oonstack) ? SS_ONSTACK : 0) : SS_DISABLE;
        }

        if (ss != NULL) {
                if (oonstack)
                        return (EPERM);
                if ((ss->ss_flags & ~SS_DISABLE) != 0)
                        return (EINVAL);
                if (!(ss->ss_flags & SS_DISABLE)) {
                        if (ss->ss_size < p->p_sysent->sv_minsigstksz)
                                return (ENOMEM);

                        td->td_sigstk = *ss;
                        td->td_pflags |= TDP_ALTSTACK;
                } else {
                        td->td_pflags &= ~TDP_ALTSTACK;
                }
        }
        return (0);
}

/*
 * Common code for kill process group/broadcast kill.
 * cp is calling process.
 */
static int
killpg1(struct thread *td, int sig, int pgid, int all, ksiginfo_t *ksi)
{
        struct proc *p;
        struct pgrp *pgrp;
        int nfound = 0;

        if (all) {
                /*
                 * broadcast
                 */
                sx_slock(&allproc_lock);
                FOREACH_PROC_IN_SYSTEM(p) {
                        PROC_LOCK(p);
                        if (p->p_pid <= 1 || p->p_flag & P_SYSTEM ||
                            p == td->td_proc || p->p_state == PRS_NEW) {
                                PROC_UNLOCK(p);
                                continue;
                        }
                        if (p_cansignal(td, p, sig) == 0) {
                                nfound++;
                                if (sig)
                                        pksignal(p, sig, ksi);
                        }
                        PROC_UNLOCK(p);
                }
                sx_sunlock(&allproc_lock);
        } else {
                sx_slock(&proctree_lock);
                if (pgid == 0) {
                        /*
                         * zero pgid means send to my process group.
                         */
                        pgrp = td->td_proc->p_pgrp;
                        PGRP_LOCK(pgrp);
                } else {
                        pgrp = pgfind(pgid);
                        if (pgrp == NULL) {
                                sx_sunlock(&proctree_lock);
                                return (ESRCH);
                        }
                }
                sx_sunlock(&proctree_lock);
                LIST_FOREACH(p, &pgrp->pg_members, p_pglist) {
                        PROC_LOCK(p);         
                        if (p->p_pid <= 1 || p->p_flag & P_SYSTEM ||
                            p->p_state == PRS_NEW) {
                                PROC_UNLOCK(p);
                                continue;
                        }
                        if (p_cansignal(td, p, sig) == 0) {
                                nfound++;
                                if (sig)
                                        pksignal(p, sig, ksi);
                        }
                        PROC_UNLOCK(p);
                }
                PGRP_UNLOCK(pgrp);
        }
        return (nfound ? 0 : ESRCH);
}

#ifndef _SYS_SYSPROTO_H_
struct kill_args {
        int     pid;
        int     signum;
};
#endif
/* ARGSUSED */
int
sys_kill(struct thread *td, struct kill_args *uap)
{
        ksiginfo_t ksi;
        struct proc *p;
        int error;

        AUDIT_ARG_SIGNUM(uap->signum);
        AUDIT_ARG_PID(uap->pid);
        if ((u_int)uap->signum > _SIG_MAXSIG)
                return (EINVAL);

        ksiginfo_init(&ksi);
        ksi.ksi_signo = uap->signum;
        ksi.ksi_code = SI_USER;
        ksi.ksi_pid = td->td_proc->p_pid;
        ksi.ksi_uid = td->td_ucred->cr_ruid;

        if (uap->pid > 0) {
                /* kill single process */
                if ((p = pfind(uap->pid)) == NULL) {
                        if ((p = zpfind(uap->pid)) == NULL)
                                return (ESRCH);
                }
                AUDIT_ARG_PROCESS(p);
                error = p_cansignal(td, p, uap->signum);
                if (error == 0 && uap->signum)
                        pksignal(p, uap->signum, &ksi);
                PROC_UNLOCK(p);
                return (error);
        }
        switch (uap->pid) {
        case -1:                /* broadcast signal */
                return (killpg1(td, uap->signum, 0, 1, &ksi));
        case 0:                 /* signal own process group */
                return (killpg1(td, uap->signum, 0, 0, &ksi));
        default:                /* negative explicit process group */
                return (killpg1(td, uap->signum, -uap->pid, 0, &ksi));
        }
        /* NOTREACHED */
}

int
sys_pdkill(td, uap)
        struct thread *td;
        struct pdkill_args *uap;
{
#ifdef PROCDESC
        struct proc *p;
        int error;

        AUDIT_ARG_SIGNUM(uap->signum);
        AUDIT_ARG_FD(uap->fd);
        if ((u_int)uap->signum > _SIG_MAXSIG)
                return (EINVAL);

        error = procdesc_find(td, uap->fd, CAP_PDKILL, &p);
        if (error)
                return (error);
        AUDIT_ARG_PROCESS(p);
        error = p_cansignal(td, p, uap->signum);
        if (error == 0 && uap->signum)
                kern_psignal(p, uap->signum);
        PROC_UNLOCK(p);
        return (error);
#else
        return (ENOSYS);
#endif
}

#if defined(COMPAT_43)
#ifndef _SYS_SYSPROTO_H_
struct okillpg_args {
        int     pgid;
        int     signum;
};
#endif
/* ARGSUSED */
int
okillpg(struct thread *td, struct okillpg_args *uap)
{
        ksiginfo_t ksi;

        AUDIT_ARG_SIGNUM(uap->signum);
        AUDIT_ARG_PID(uap->pgid);
        if ((u_int)uap->signum > _SIG_MAXSIG)
                return (EINVAL);

        ksiginfo_init(&ksi);
        ksi.ksi_signo = uap->signum;
        ksi.ksi_code = SI_USER;
        ksi.ksi_pid = td->td_proc->p_pid;
        ksi.ksi_uid = td->td_ucred->cr_ruid;
        return (killpg1(td, uap->signum, uap->pgid, 0, &ksi));
}
#endif /* COMPAT_43 */

#ifndef _SYS_SYSPROTO_H_
struct sigqueue_args {
        pid_t pid;
        int signum;
        /* union sigval */ void *value;
};
#endif
int
sys_sigqueue(struct thread *td, struct sigqueue_args *uap)
{
        ksiginfo_t ksi;
        struct proc *p;
        int error;

        if ((u_int)uap->signum > _SIG_MAXSIG)
                return (EINVAL);

        /*
         * Specification says sigqueue can only send signal to
         * single process.
         */
        if (uap->pid <= 0)
                return (EINVAL);

        if ((p = pfind(uap->pid)) == NULL) {
                if ((p = zpfind(uap->pid)) == NULL)
                        return (ESRCH);
        }
        error = p_cansignal(td, p, uap->signum);
        if (error == 0 && uap->signum != 0) {
                ksiginfo_init(&ksi);
                ksi.ksi_flags = KSI_SIGQ;
                ksi.ksi_signo = uap->signum;
                ksi.ksi_code = SI_QUEUE;
                ksi.ksi_pid = td->td_proc->p_pid;
                ksi.ksi_uid = td->td_ucred->cr_ruid;
                ksi.ksi_value.sival_ptr = uap->value;
                error = pksignal(p, ksi.ksi_signo, &ksi);
        }
        PROC_UNLOCK(p);
        return (error);
}

/*
 * Send a signal to a process group.
 */
void
gsignal(int pgid, int sig, ksiginfo_t *ksi)
{
        struct pgrp *pgrp;

        if (pgid != 0) {
                sx_slock(&proctree_lock);
                pgrp = pgfind(pgid);
                sx_sunlock(&proctree_lock);
                if (pgrp != NULL) {
                        pgsignal(pgrp, sig, 0, ksi);
                        PGRP_UNLOCK(pgrp);
                }
        }
}

/*
 * Send a signal to a process group.  If checktty is 1,
 * limit to members which have a controlling terminal.
 */
void
pgsignal(struct pgrp *pgrp, int sig, int checkctty, ksiginfo_t *ksi)
{
        struct proc *p;

        if (pgrp) {
                PGRP_LOCK_ASSERT(pgrp, MA_OWNED);
                LIST_FOREACH(p, &pgrp->pg_members, p_pglist) {
                        PROC_LOCK(p);
                        if (p->p_state == PRS_NORMAL &&
                            (checkctty == 0 || p->p_flag & P_CONTROLT))
                                pksignal(p, sig, ksi);
                        PROC_UNLOCK(p);
                }
        }
}

/*
 * Send a signal caused by a trap to the current thread.  If it will be
 * caught immediately, deliver it with correct code.  Otherwise, post it
 * normally.
 */
void
trapsignal(struct thread *td, ksiginfo_t *ksi)
{
        struct sigacts *ps;
        sigset_t mask;
        struct proc *p;
        int sig;
        int code;

        p = td->td_proc;
        sig = ksi->ksi_signo;
        code = ksi->ksi_code;
        KASSERT(_SIG_VALID(sig), ("invalid signal"));

        PROC_LOCK(p);
        ps = p->p_sigacts;
        mtx_lock(&ps->ps_mtx);
        if ((p->p_flag & P_TRACED) == 0 && SIGISMEMBER(ps->ps_sigcatch, sig) &&
            !SIGISMEMBER(td->td_sigmask, sig)) {
                td->td_ru.ru_nsignals++;
#ifdef KTRACE
                if (KTRPOINT(curthread, KTR_PSIG))
                        ktrpsig(sig, ps->ps_sigact[_SIG_IDX(sig)],
                            &td->td_sigmask, code);
#endif
                (*p->p_sysent->sv_sendsig)(ps->ps_sigact[_SIG_IDX(sig)], 
                                ksi, &td->td_sigmask);
                mask = ps->ps_catchmask[_SIG_IDX(sig)];
                if (!SIGISMEMBER(ps->ps_signodefer, sig))
                        SIGADDSET(mask, sig);
                kern_sigprocmask(td, SIG_BLOCK, &mask, NULL,
                    SIGPROCMASK_PROC_LOCKED | SIGPROCMASK_PS_LOCKED);
                if (SIGISMEMBER(ps->ps_sigreset, sig)) {
                        /*
                         * See kern_sigaction() for origin of this code.
                         */
                        SIGDELSET(ps->ps_sigcatch, sig);
                        if (sig != SIGCONT &&
                            sigprop(sig) & SA_IGNORE)
                                SIGADDSET(ps->ps_sigignore, sig);
                        ps->ps_sigact[_SIG_IDX(sig)] = SIG_DFL;
                }
                mtx_unlock(&ps->ps_mtx);
        } else {
                /*
                 * Avoid a possible infinite loop if the thread
                 * masking the signal or process is ignoring the
                 * signal.
                 */
                if (kern_forcesigexit &&
                    (SIGISMEMBER(td->td_sigmask, sig) ||
                     ps->ps_sigact[_SIG_IDX(sig)] == SIG_IGN)) {
                        SIGDELSET(td->td_sigmask, sig);
                        SIGDELSET(ps->ps_sigcatch, sig);
                        SIGDELSET(ps->ps_sigignore, sig);
                        ps->ps_sigact[_SIG_IDX(sig)] = SIG_DFL;
                }
                mtx_unlock(&ps->ps_mtx);
                p->p_code = code;       /* XXX for core dump/debugger */
                p->p_sig = sig;         /* XXX to verify code */
                tdsendsignal(p, td, sig, ksi);
        }
        PROC_UNLOCK(p);
}

static struct thread *
sigtd(struct proc *p, int sig, int prop)
{
        struct thread *td, *signal_td;

        PROC_LOCK_ASSERT(p, MA_OWNED);

        /*
         * Check if current thread can handle the signal without
         * switching context to another thread.
         */
        if (curproc == p && !SIGISMEMBER(curthread->td_sigmask, sig))
                return (curthread);
        signal_td = NULL;
        FOREACH_THREAD_IN_PROC(p, td) {
                if (!SIGISMEMBER(td->td_sigmask, sig)) {
                        signal_td = td;
                        break;
                }
        }
        if (signal_td == NULL)
                signal_td = FIRST_THREAD_IN_PROC(p);
        return (signal_td);
}

/*
 * Send the signal to the process.  If the signal has an action, the action
 * is usually performed by the target process rather than the caller; we add
 * the signal to the set of pending signals for the process.
 *
 * Exceptions:
 *   o When a stop signal is sent to a sleeping process that takes the
 *     default action, the process is stopped without awakening it.
 *   o SIGCONT restarts stopped processes (or puts them back to sleep)
 *     regardless of the signal action (eg, blocked or ignored).
 *
 * Other ignored signals are discarded immediately.
 * 
 * NB: This function may be entered from the debugger via the "kill" DDB
 * command.  There is little that can be done to mitigate the possibly messy
 * side effects of this unwise possibility.
 */
void
kern_psignal(struct proc *p, int sig)
{
        ksiginfo_t ksi;

        ksiginfo_init(&ksi);
        ksi.ksi_signo = sig;
        ksi.ksi_code = SI_KERNEL;
        (void) tdsendsignal(p, NULL, sig, &ksi);
}

int
pksignal(struct proc *p, int sig, ksiginfo_t *ksi)
{

        return (tdsendsignal(p, NULL, sig, ksi));
}

/* Utility function for finding a thread to send signal event to. */
int
sigev_findtd(struct proc *p ,struct sigevent *sigev, struct thread **ttd)
{
        struct thread *td;

        if (sigev->sigev_notify == SIGEV_THREAD_ID) {
                td = tdfind(sigev->sigev_notify_thread_id, p->p_pid);
                if (td == NULL)
                        return (ESRCH);
                *ttd = td;
        } else {
                *ttd = NULL;
                PROC_LOCK(p);
        }
        return (0);
}

void
tdsignal(struct thread *td, int sig)
{
        ksiginfo_t ksi;

        ksiginfo_init(&ksi);
        ksi.ksi_signo = sig;
        ksi.ksi_code = SI_KERNEL;
        (void) tdsendsignal(td->td_proc, td, sig, &ksi);
}

void
tdksignal(struct thread *td, int sig, ksiginfo_t *ksi)
{

        (void) tdsendsignal(td->td_proc, td, sig, ksi);
}

int
tdsendsignal(struct proc *p, struct thread *td, int sig, ksiginfo_t *ksi)
{
        sig_t action;
        sigqueue_t *sigqueue;
        int prop;
        struct sigacts *ps;
        int intrval;
        int ret = 0;
        int wakeup_swapper;

        MPASS(td == NULL || p == td->td_proc);
        PROC_LOCK_ASSERT(p, MA_OWNED);

        if (!_SIG_VALID(sig))
                panic("%s(): invalid signal %d", __func__, sig);

        KASSERT(ksi == NULL || !KSI_ONQ(ksi), ("%s: ksi on queue", __func__));

        /*
         * IEEE Std 1003.1-2001: return success when killing a zombie.
         */
        if (p->p_state == PRS_ZOMBIE) {
                if (ksi && (ksi->ksi_flags & KSI_INS))
                        ksiginfo_tryfree(ksi);
                return (ret);
        }

        ps = p->p_sigacts;
        KNOTE_LOCKED(&p->p_klist, NOTE_SIGNAL | sig);
        prop = sigprop(sig);

        if (td == NULL) {
                td = sigtd(p, sig, prop);
                sigqueue = &p->p_sigqueue;
        } else {
                KASSERT(td->td_proc == p, ("invalid thread"));
                sigqueue = &td->td_sigqueue;
        }

        SDT_PROBE(proc, kernel, , signal_send, td, p, sig, 0, 0 );

        /*
         * If the signal is being ignored,
         * then we forget about it immediately.
         * (Note: we don't set SIGCONT in ps_sigignore,
         * and if it is set to SIG_IGN,
         * action will be SIG_DFL here.)
         */
        mtx_lock(&ps->ps_mtx);
        if (SIGISMEMBER(ps->ps_sigignore, sig)) {
                SDT_PROBE(proc, kernel, , signal_discard, td, p, sig, 0, 0 );

                mtx_unlock(&ps->ps_mtx);
                if (ksi && (ksi->ksi_flags & KSI_INS))
                        ksiginfo_tryfree(ksi);
                return (ret);
        }
        if (SIGISMEMBER(td->td_sigmask, sig))
                action = SIG_HOLD;
        else if (SIGISMEMBER(ps->ps_sigcatch, sig))
                action = SIG_CATCH;
        else
                action = SIG_DFL;
        if (SIGISMEMBER(ps->ps_sigintr, sig))
                intrval = EINTR;
        else
                intrval = ERESTART;
        mtx_unlock(&ps->ps_mtx);

        if (prop & SA_CONT)
                sigqueue_delete_stopmask_proc(p);
        else if (prop & SA_STOP) {
                /*
                 * If sending a tty stop signal to a member of an orphaned
                 * process group, discard the signal here if the action
                 * is default; don't stop the process below if sleeping,
                 * and don't clear any pending SIGCONT.
                 */
                if ((prop & SA_TTYSTOP) &&
                    (p->p_pgrp->pg_jobc == 0) &&
                    (action == SIG_DFL)) {
                        if (ksi && (ksi->ksi_flags & KSI_INS))
                                ksiginfo_tryfree(ksi);
                        return (ret);
                }
                sigqueue_delete_proc(p, SIGCONT);
                if (p->p_flag & P_CONTINUED) {
                        p->p_flag &= ~P_CONTINUED;
                        PROC_LOCK(p->p_pptr);
                        sigqueue_take(p->p_ksi);
                        PROC_UNLOCK(p->p_pptr);
                }
        }

        ret = sigqueue_add(sigqueue, sig, ksi);
        if (ret != 0)
                return (ret);
        signotify(td);
        /*
         * Defer further processing for signals which are held,
         * except that stopped processes must be continued by SIGCONT.
         */
        if (action == SIG_HOLD &&
            !((prop & SA_CONT) && (p->p_flag & P_STOPPED_SIG)))
                return (ret);
        /*
         * SIGKILL: Remove procfs STOPEVENTs.
         */
        if (sig == SIGKILL) {
                /* from procfs_ioctl.c: PIOCBIC */
                p->p_stops = 0;
                /* from procfs_ioctl.c: PIOCCONT */
                p->p_step = 0;
                wakeup(&p->p_step);
        }
        /*
         * Some signals have a process-wide effect and a per-thread
         * component.  Most processing occurs when the process next
         * tries to cross the user boundary, however there are some
         * times when processing needs to be done immediatly, such as
         * waking up threads so that they can cross the user boundary.
         * We try do the per-process part here.
         */
        if (P_SHOULDSTOP(p)) {
                if (sig == SIGKILL) {
                        /*
                         * If traced process is already stopped,
                         * then no further action is necessary.
                         */
                        if (p->p_flag & P_TRACED)
                                goto out;
                        /*
                         * SIGKILL sets process running.
                         * It will die elsewhere.
                         * All threads must be restarted.
                         */
                        p->p_flag &= ~P_STOPPED_SIG;
                        goto runfast;
                }

                if (prop & SA_CONT) {
                        /*
                         * If traced process is already stopped,
                         * then no further action is necessary.
                         */
                        if (p->p_flag & P_TRACED)
                                goto out;
                        /*
                         * If SIGCONT is default (or ignored), we continue the
                         * process but don't leave the signal in sigqueue as
                         * it has no further action.  If SIGCONT is held, we
                         * continue the process and leave the signal in
                         * sigqueue.  If the process catches SIGCONT, let it
                         * handle the signal itself.  If it isn't waiting on
                         * an event, it goes back to run state.
                         * Otherwise, process goes back to sleep state.
                         */
                        p->p_flag &= ~P_STOPPED_SIG;
                        PROC_SLOCK(p);
                        if (p->p_numthreads == p->p_suspcount) {
                                PROC_SUNLOCK(p);
                                p->p_flag |= P_CONTINUED;
                                p->p_xstat = SIGCONT;
                                PROC_LOCK(p->p_pptr);
                                childproc_continued(p);
                                PROC_UNLOCK(p->p_pptr);
                                PROC_SLOCK(p);
                        }
                        if (action == SIG_DFL) {
                                thread_unsuspend(p);
                                PROC_SUNLOCK(p);
                                sigqueue_delete(sigqueue, sig);
                                goto out;
                        }
                        if (action == SIG_CATCH) {
                                /*
                                 * The process wants to catch it so it needs
                                 * to run at least one thread, but which one?
                                 */
                                PROC_SUNLOCK(p);
                                goto runfast;
                        }
                        /*
                         * The signal is not ignored or caught.
                         */
                        thread_unsuspend(p);
                        PROC_SUNLOCK(p);
                        goto out;
                }

                if (prop & SA_STOP) {
                        /*
                         * If traced process is already stopped,
                         * then no further action is necessary.
                         */
                        if (p->p_flag & P_TRACED)
                                goto out;
                        /*
                         * Already stopped, don't need to stop again
                         * (If we did the shell could get confused).
                         * Just make sure the signal STOP bit set.
                         */
                        p->p_flag |= P_STOPPED_SIG;
                        sigqueue_delete(sigqueue, sig);
                        goto out;
                }

                /*
                 * All other kinds of signals:
                 * If a thread is sleeping interruptibly, simulate a
                 * wakeup so that when it is continued it will be made
                 * runnable and can look at the signal.  However, don't make
                 * the PROCESS runnable, leave it stopped.
                 * It may run a bit until it hits a thread_suspend_check().
                 */
                wakeup_swapper = 0;
                PROC_SLOCK(p);
                thread_lock(td);
                if (TD_ON_SLEEPQ(td) && (td->td_flags & TDF_SINTR))
                        wakeup_swapper = sleepq_abort(td, intrval);
                thread_unlock(td);
                PROC_SUNLOCK(p);
                if (wakeup_swapper)
                        kick_proc0();
                goto out;
                /*
                 * Mutexes are short lived. Threads waiting on them will
                 * hit thread_suspend_check() soon.
                 */
        } else if (p->p_state == PRS_NORMAL) {
                if (p->p_flag & P_TRACED || action == SIG_CATCH) {
                        tdsigwakeup(td, sig, action, intrval);
                        goto out;
                }

                MPASS(action == SIG_DFL);

                if (prop & SA_STOP) {
                        if (p->p_flag & P_PPWAIT)
                                goto out;
                        p->p_flag |= P_STOPPED_SIG;
                        p->p_xstat = sig;
                        PROC_SLOCK(p);
                        sig_suspend_threads(td, p, 1);
                        if (p->p_numthreads == p->p_suspcount) {
                                /*
                                 * only thread sending signal to another
                                 * process can reach here, if thread is sending
                                 * signal to its process, because thread does
                                 * not suspend itself here, p_numthreads
                                 * should never be equal to p_suspcount.
                                 */
                                thread_stopped(p);
                                PROC_SUNLOCK(p);
                                sigqueue_delete_proc(p, p->p_xstat);
                        } else
                                PROC_SUNLOCK(p);
                        goto out;
                }
        } else {
                /* Not in "NORMAL" state. discard the signal. */
                sigqueue_delete(sigqueue, sig);
                goto out;
        }

        /*
         * The process is not stopped so we need to apply the signal to all the
         * running threads.
         */
runfast:
        tdsigwakeup(td, sig, action, intrval);
        PROC_SLOCK(p);
        thread_unsuspend(p);
        PROC_SUNLOCK(p);
out:
        /* If we jump here, proc slock should not be owned. */
        PROC_SLOCK_ASSERT(p, MA_NOTOWNED);
        return (ret);
}

/*
 * The force of a signal has been directed against a single
 * thread.  We need to see what we can do about knocking it
 * out of any sleep it may be in etc.
 */
static void
tdsigwakeup(struct thread *td, int sig, sig_t action, int intrval)
{
        struct proc *p = td->td_proc;
        register int prop;
        int wakeup_swapper;

        wakeup_swapper = 0;
        PROC_LOCK_ASSERT(p, MA_OWNED);
        prop = sigprop(sig);

        PROC_SLOCK(p);
        thread_lock(td);
        /*
         * Bring the priority of a thread up if we want it to get
         * killed in this lifetime.
         */
        if (action == SIG_DFL && (prop & SA_KILL) && td->td_priority > PUSER)
                sched_prio(td, PUSER);
        if (TD_ON_SLEEPQ(td)) {
                /*
                 * If thread is sleeping uninterruptibly
                 * we can't interrupt the sleep... the signal will
                 * be noticed when the process returns through
                 * trap() or syscall().
                 */
                if ((td->td_flags & TDF_SINTR) == 0)
                        goto out;
                /*
                 * If SIGCONT is default (or ignored) and process is
                 * asleep, we are finished; the process should not
                 * be awakened.
                 */
                if ((prop & SA_CONT) && action == SIG_DFL) {
                        thread_unlock(td);
                        PROC_SUNLOCK(p);
                        sigqueue_delete(&p->p_sigqueue, sig);
                        /*
                         * It may be on either list in this state.
                         * Remove from both for now.
                         */
                        sigqueue_delete(&td->td_sigqueue, sig);
                        return;
                }

                /*
                 * Give low priority threads a better chance to run.
                 */
                if (td->td_priority > PUSER)
                        sched_prio(td, PUSER);

                wakeup_swapper = sleepq_abort(td, intrval);
        } else {
                /*
                 * Other states do nothing with the signal immediately,
                 * other than kicking ourselves if we are running.
                 * It will either never be noticed, or noticed very soon.
                 */
#ifdef SMP
                if (TD_IS_RUNNING(td) && td != curthread)
                        forward_signal(td);
#endif
        }
out:
        PROC_SUNLOCK(p);
        thread_unlock(td);
        if (wakeup_swapper)
                kick_proc0();
}

static void
sig_suspend_threads(struct thread *td, struct proc *p, int sending)
{
        struct thread *td2;
        int wakeup_swapper;

        PROC_LOCK_ASSERT(p, MA_OWNED);
        PROC_SLOCK_ASSERT(p, MA_OWNED);

        wakeup_swapper = 0;
        FOREACH_THREAD_IN_PROC(p, td2) {
                thread_lock(td2);
                td2->td_flags |= TDF_ASTPENDING | TDF_NEEDSUSPCHK;
                if ((TD_IS_SLEEPING(td2) || TD_IS_SWAPPED(td2)) &&
                    (td2->td_flags & TDF_SINTR)) {
                        if (td2->td_flags & TDF_SBDRY) {
                                if (TD_IS_SUSPENDED(td2))
                                        wakeup_swapper |=
                                            thread_unsuspend_one(td2);
                                if (TD_ON_SLEEPQ(td2))
                                        wakeup_swapper |=
                                            sleepq_abort(td2, ERESTART);
                        } else if (!TD_IS_SUSPENDED(td2)) {
                                thread_suspend_one(td2);
                        }
                } else if (!TD_IS_SUSPENDED(td2)) {
                        if (sending || td != td2)
                                td2->td_flags |= TDF_ASTPENDING;
#ifdef SMP
                        if (TD_IS_RUNNING(td2) && td2 != td)
                                forward_signal(td2);
#endif
                }
                thread_unlock(td2);
        }
        if (wakeup_swapper)
                kick_proc0();
}

int
ptracestop(struct thread *td, int sig)
{
        struct proc *p = td->td_proc;

        PROC_LOCK_ASSERT(p, MA_OWNED);
        WITNESS_WARN(WARN_GIANTOK | WARN_SLEEPOK,
            &p->p_mtx.lock_object, "Stopping for traced signal");

        td->td_dbgflags |= TDB_XSIG;
        td->td_xsig = sig;
        PROC_SLOCK(p);
        while ((p->p_flag & P_TRACED) && (td->td_dbgflags & TDB_XSIG)) {
                if (p->p_flag & P_SINGLE_EXIT) {
                        td->td_dbgflags &= ~TDB_XSIG;
                        PROC_SUNLOCK(p);
                        return (sig);
                }
                /*
                 * Just make wait() to work, the last stopped thread
                 * will win.
                 */
                p->p_xstat = sig;
                p->p_xthread = td;
                p->p_flag |= (P_STOPPED_SIG|P_STOPPED_TRACE);
                sig_suspend_threads(td, p, 0);
                if ((td->td_dbgflags & TDB_STOPATFORK) != 0) {
                        td->td_dbgflags &= ~TDB_STOPATFORK;
                        cv_broadcast(&p->p_dbgwait);
                }
stopme:
                thread_suspend_switch(td);
                if (!(p->p_flag & P_TRACED)) {
                        break;
                }
                if (td->td_dbgflags & TDB_SUSPEND) {
                        if (p->p_flag & P_SINGLE_EXIT)
                                break;
                        goto stopme;
                }
        }
        PROC_SUNLOCK(p);
        return (td->td_xsig);
}

static void
reschedule_signals(struct proc *p, sigset_t block, int flags)
{
        struct sigacts *ps;
        struct thread *td;
        int sig;

        PROC_LOCK_ASSERT(p, MA_OWNED);
        if (SIGISEMPTY(p->p_siglist))
                return;
        ps = p->p_sigacts;
        SIGSETAND(block, p->p_siglist);
        while ((sig = sig_ffs(&block)) != 0) {
                SIGDELSET(block, sig);
                td = sigtd(p, sig, 0);
                signotify(td);
                if (!(flags & SIGPROCMASK_PS_LOCKED))
                        mtx_lock(&ps->ps_mtx);
                if (p->p_flag & P_TRACED || SIGISMEMBER(ps->ps_sigcatch, sig))
                        tdsigwakeup(td, sig, SIG_CATCH,
                            (SIGISMEMBER(ps->ps_sigintr, sig) ? EINTR :
                             ERESTART));
                if (!(flags & SIGPROCMASK_PS_LOCKED))
                        mtx_unlock(&ps->ps_mtx);
        }
}

void
tdsigcleanup(struct thread *td)
{
        struct proc *p;
        sigset_t unblocked;

        p = td->td_proc;
        PROC_LOCK_ASSERT(p, MA_OWNED);

        sigqueue_flush(&td->td_sigqueue);
        if (p->p_numthreads == 1)
                return;

        /*
         * Since we cannot handle signals, notify signal post code
         * about this by filling the sigmask.
         *
         * Also, if needed, wake up thread(s) that do not block the
         * same signals as the exiting thread, since the thread might
         * have been selected for delivery and woken up.
         */
        SIGFILLSET(unblocked);
        SIGSETNAND(unblocked, td->td_sigmask);
        SIGFILLSET(td->td_sigmask);
        reschedule_signals(p, unblocked, 0);

}

/*
 * If the current process has received a signal (should be caught or cause
 * termination, should interrupt current syscall), return the signal number.
 * Stop signals with default action are processed immediately, then cleared;
 * they aren't returned.  This is checked after each entry to the system for
 * a syscall or trap (though this can usually be done without calling issignal
 * by checking the pending signal masks in cursig.) The normal call
 * sequence is
 *
 *      while (sig = cursig(curthread))
 *              postsig(sig);
 */
static int
issignal(struct thread *td, int stop_allowed)
{
        struct proc *p;
        struct sigacts *ps;
        struct sigqueue *queue;
        sigset_t sigpending;
        int sig, prop, newsig;

        p = td->td_proc;
        ps = p->p_sigacts;
        mtx_assert(&ps->ps_mtx, MA_OWNED);
        PROC_LOCK_ASSERT(p, MA_OWNED);
        for (;;) {
                int traced = (p->p_flag & P_TRACED) || (p->p_stops & S_SIG);

                sigpending = td->td_sigqueue.sq_signals;
                SIGSETOR(sigpending, p->p_sigqueue.sq_signals);
                SIGSETNAND(sigpending, td->td_sigmask);

                if (p->p_flag & P_PPWAIT)
                        SIG_STOPSIGMASK(sigpending);
                if (SIGISEMPTY(sigpending))     /* no signal to send */
                        return (0);
                sig = sig_ffs(&sigpending);

                if (p->p_stops & S_SIG) {
                        mtx_unlock(&ps->ps_mtx);
                        stopevent(p, S_SIG, sig);
                        mtx_lock(&ps->ps_mtx);
                }

                /*
                 * We should see pending but ignored signals
                 * only if P_TRACED was on when they were posted.
                 */
                if (SIGISMEMBER(ps->ps_sigignore, sig) && (traced == 0)) {
                        sigqueue_delete(&td->td_sigqueue, sig);
                        sigqueue_delete(&p->p_sigqueue, sig);
                        continue;
                }
                if (p->p_flag & P_TRACED && (p->p_flag & P_PPWAIT) == 0) {
                        /*
                         * If traced, always stop.
                         * Remove old signal from queue before the stop.
                         * XXX shrug off debugger, it causes siginfo to
                         * be thrown away.
                         */
                        queue = &td->td_sigqueue;
                        td->td_dbgksi.ksi_signo = 0;
                        if (sigqueue_get(queue, sig, &td->td_dbgksi) == 0) {
                                queue = &p->p_sigqueue;
                                sigqueue_get(queue, sig, &td->td_dbgksi);
                        }

                        mtx_unlock(&ps->ps_mtx);
                        newsig = ptracestop(td, sig);
                        mtx_lock(&ps->ps_mtx);

                        if (sig != newsig) {

                                /*
                                 * If parent wants us to take the signal,
                                 * then it will leave it in p->p_xstat;
                                 * otherwise we just look for signals again.
                                */
                                if (newsig == 0)
                                        continue;
                                sig = newsig;

                                /*
                                 * Put the new signal into td_sigqueue. If the
                                 * signal is being masked, look for other signals.
                                 */
                                sigqueue_add(queue, sig, NULL);
                                if (SIGISMEMBER(td->td_sigmask, sig))
                                        continue;
                                signotify(td);
                        } else {
                                if (td->td_dbgksi.ksi_signo != 0) {
                                        td->td_dbgksi.ksi_flags |= KSI_HEAD;
                                        if (sigqueue_add(&td->td_sigqueue, sig,
                                            &td->td_dbgksi) != 0)
                                                td->td_dbgksi.ksi_signo = 0;
                                }
                                if (td->td_dbgksi.ksi_signo == 0)
                                        sigqueue_add(&td->td_sigqueue, sig,
                                            NULL);
                        }

                        /*
                         * If the traced bit got turned off, go back up
                         * to the top to rescan signals.  This ensures
                         * that p_sig* and p_sigact are consistent.
                         */
                        if ((p->p_flag & P_TRACED) == 0)
                                continue;
                }

                prop = sigprop(sig);

                /*
                 * Decide whether the signal should be returned.
                 * Return the signal's number, or fall through
                 * to clear it from the pending mask.
                 */
                switch ((intptr_t)p->p_sigacts->ps_sigact[_SIG_IDX(sig)]) {

                case (intptr_t)SIG_DFL:
                        /*
                         * Don't take default actions on system processes.
                         */
                        if (p->p_pid <= 1) {
#ifdef DIAGNOSTIC
                                /*
                                 * Are you sure you want to ignore SIGSEGV
                                 * in init? XXX
                                 */
                                printf("Process (pid %lu) got signal %d\n",
                                        (u_long)p->p_pid, sig);
#endif
                                break;          /* == ignore */
                        }
                        /*
                         * If there is a pending stop signal to process
                         * with default action, stop here,
                         * then clear the signal.  However,
                         * if process is member of an orphaned
                         * process group, ignore tty stop signals.
                         */
                        if (prop & SA_STOP) {
                                if (p->p_flag & P_TRACED ||
                                    (p->p_pgrp->pg_jobc == 0 &&
                                     prop & SA_TTYSTOP))
                                        break;  /* == ignore */

                                /* Ignore, but do not drop the stop signal. */
                                if (stop_allowed != SIG_STOP_ALLOWED)
                                        return (sig);
                                mtx_unlock(&ps->ps_mtx);
                                WITNESS_WARN(WARN_GIANTOK | WARN_SLEEPOK,
                                    &p->p_mtx.lock_object, "Catching SIGSTOP");
                                p->p_flag |= P_STOPPED_SIG;
                                p->p_xstat = sig;
                                PROC_SLOCK(p);
                                sig_suspend_threads(td, p, 0);
                                thread_suspend_switch(td);
                                PROC_SUNLOCK(p);
                                mtx_lock(&ps->ps_mtx);
                                break;
                        } else if (prop & SA_IGNORE) {
                                /*
                                 * Except for SIGCONT, shouldn't get here.
                                 * Default action is to ignore; drop it.
                                 */
                                break;          /* == ignore */
                        } else
                                return (sig);
                        /*NOTREACHED*/

                case (intptr_t)SIG_IGN:
                        /*
                         * Masking above should prevent us ever trying
                         * to take action on an ignored signal other
                         * than SIGCONT, unless process is traced.
                         */
                        if ((prop & SA_CONT) == 0 &&
                            (p->p_flag & P_TRACED) == 0)
                                printf("issignal\n");
                        break;          /* == ignore */

                default:
                        /*
                         * This signal has an action, let
                         * postsig() process it.
                         */
                        return (sig);
                }
                sigqueue_delete(&td->td_sigqueue, sig);         /* take the signal! */
                sigqueue_delete(&p->p_sigqueue, sig);
        }
        /* NOTREACHED */
}

void
thread_stopped(struct proc *p)
{
        int n;

        PROC_LOCK_ASSERT(p, MA_OWNED);
        PROC_SLOCK_ASSERT(p, MA_OWNED);
        n = p->p_suspcount;
        if (p == curproc)
                n++;
        if ((p->p_flag & P_STOPPED_SIG) && (n == p->p_numthreads)) {
                PROC_SUNLOCK(p);
                p->p_flag &= ~P_WAITED;
                PROC_LOCK(p->p_pptr);
                childproc_stopped(p, (p->p_flag & P_TRACED) ?
                        CLD_TRAPPED : CLD_STOPPED);
                PROC_UNLOCK(p->p_pptr);
                PROC_SLOCK(p);
        }
}
 
/*
 * Take the action for the specified signal
 * from the current set of pending signals.
 */
int
postsig(sig)
        register int sig;
{
        struct thread *td = curthread;
        register struct proc *p = td->td_proc;
        struct sigacts *ps;
        sig_t action;
        ksiginfo_t ksi;
        sigset_t returnmask, mask;

        KASSERT(sig != 0, ("postsig"));

        PROC_LOCK_ASSERT(p, MA_OWNED);
        ps = p->p_sigacts;
        mtx_assert(&ps->ps_mtx, MA_OWNED);
        ksiginfo_init(&ksi);
        if (sigqueue_get(&td->td_sigqueue, sig, &ksi) == 0 &&
            sigqueue_get(&p->p_sigqueue, sig, &ksi) == 0)
                return (0);
        ksi.ksi_signo = sig;
        if (ksi.ksi_code == SI_TIMER)
                itimer_accept(p, ksi.ksi_timerid, &ksi);
        action = ps->ps_sigact[_SIG_IDX(sig)];
#ifdef KTRACE
        if (KTRPOINT(td, KTR_PSIG))
                ktrpsig(sig, action, td->td_pflags & TDP_OLDMASK ?
                    &td->td_oldsigmask : &td->td_sigmask, ksi.ksi_code);
#endif
        if (p->p_stops & S_SIG) {
                mtx_unlock(&ps->ps_mtx);
                stopevent(p, S_SIG, sig);
                mtx_lock(&ps->ps_mtx);
        }

        if (action == SIG_DFL) {
                /*
                 * Default action, where the default is to kill
                 * the process.  (Other cases were ignored above.)
                 */
                mtx_unlock(&ps->ps_mtx);
                sigexit(td, sig);
                /* NOTREACHED */
        } else {
                /*
                 * If we get here, the signal must be caught.
                 */
                KASSERT(action != SIG_IGN && !SIGISMEMBER(td->td_sigmask, sig),
                    ("postsig action"));
                /*
                 * Set the new mask value and also defer further
                 * occurrences of this signal.
                 *
                 * Special case: user has done a sigsuspend.  Here the
                 * current mask is not of interest, but rather the
                 * mask from before the sigsuspend is what we want
                 * restored after the signal processing is completed.
                 */
                if (td->td_pflags & TDP_OLDMASK) {
                        returnmask = td->td_oldsigmask;
                        td->td_pflags &= ~TDP_OLDMASK;
                } else
                        returnmask = td->td_sigmask;

                mask = ps->ps_catchmask[_SIG_IDX(sig)];
                if (!SIGISMEMBER(ps->ps_signodefer, sig))
                        SIGADDSET(mask, sig);
                kern_sigprocmask(td, SIG_BLOCK, &mask, NULL,
                    SIGPROCMASK_PROC_LOCKED | SIGPROCMASK_PS_LOCKED);

                if (SIGISMEMBER(ps->ps_sigreset, sig)) {
                        /*
                         * See kern_sigaction() for origin of this code.
                         */
                        SIGDELSET(ps->ps_sigcatch, sig);
                        if (sig != SIGCONT &&
                            sigprop(sig) & SA_IGNORE)
                                SIGADDSET(ps->ps_sigignore, sig);
                        ps->ps_sigact[_SIG_IDX(sig)] = SIG_DFL;
                }
                td->td_ru.ru_nsignals++;
                if (p->p_sig == sig) {
                        p->p_code = 0;
                        p->p_sig = 0;
                }
                (*p->p_sysent->sv_sendsig)(action, &ksi, &returnmask);
        }
        return (1);
}

/*
 * Kill the current process for stated reason.
 */
void
killproc(p, why)
        struct proc *p;
        char *why;
{

        PROC_LOCK_ASSERT(p, MA_OWNED);
        CTR3(KTR_PROC, "killproc: proc %p (pid %d, %s)",
                p, p->p_pid, p->p_comm);
        log(LOG_ERR, "pid %d (%s), uid %d, was killed: %s\n", p->p_pid, p->p_comm,
                p->p_ucred ? p->p_ucred->cr_uid : -1, why);
        p->p_flag |= P_WKILLED;
        kern_psignal(p, SIGKILL);
}

/*
 * Force the current process to exit with the specified signal, dumping core
 * if appropriate.  We bypass the normal tests for masked and caught signals,
 * allowing unrecoverable failures to terminate the process without changing
 * signal state.  Mark the accounting record with the signal termination.
 * If dumping core, save the signal number for the debugger.  Calls exit and
 * does not return.
 */
void
sigexit(td, sig)
        struct thread *td;
        int sig;
{
        struct proc *p = td->td_proc;

        PROC_LOCK_ASSERT(p, MA_OWNED);
        p->p_acflag |= AXSIG;
        /*
         * We must be single-threading to generate a core dump.  This
         * ensures that the registers in the core file are up-to-date.
         * Also, the ELF dump handler assumes that the thread list doesn't
         * change out from under it.
         *
         * XXX If another thread attempts to single-thread before us
         *     (e.g. via fork()), we won't get a dump at all.
         */
        if ((sigprop(sig) & SA_CORE) && (thread_single(SINGLE_NO_EXIT) == 0)) {
                p->p_sig = sig;
                /*
                 * Log signals which would cause core dumps
                 * (Log as LOG_INFO to appease those who don't want
                 * these messages.)
                 * XXX : Todo, as well as euid, write out ruid too
                 * Note that coredump() drops proc lock.
                 */
                if (coredump(td) == 0)
                        sig |= WCOREFLAG;
                if (kern_logsigexit)
                        log(LOG_INFO,
                            "pid %d (%s), uid %d: exited on signal %d%s\n",
                            p->p_pid, p->p_comm,
                            td->td_ucred ? td->td_ucred->cr_uid : -1,
                            sig &~ WCOREFLAG,
                            sig & WCOREFLAG ? " (core dumped)" : "");
        } else
                PROC_UNLOCK(p);
        exit1(td, W_EXITCODE(0, sig));
        /* NOTREACHED */
}

/*
 * Send queued SIGCHLD to parent when child process's state
 * is changed.
 */
static void
sigparent(struct proc *p, int reason, int status)
{
        PROC_LOCK_ASSERT(p, MA_OWNED);
        PROC_LOCK_ASSERT(p->p_pptr, MA_OWNED);

        if (p->p_ksi != NULL) {
                p->p_ksi->ksi_signo  = SIGCHLD;
                p->p_ksi->ksi_code   = reason;
                p->p_ksi->ksi_status = status;
                p->p_ksi->ksi_pid    = p->p_pid;
                p->p_ksi->ksi_uid    = p->p_ucred->cr_ruid;
                if (KSI_ONQ(p->p_ksi))
                        return;
        }
        pksignal(p->p_pptr, SIGCHLD, p->p_ksi);
}

static void
childproc_jobstate(struct proc *p, int reason, int status)
{
        struct sigacts *ps;

        PROC_LOCK_ASSERT(p, MA_OWNED);
        PROC_LOCK_ASSERT(p->p_pptr, MA_OWNED);

        /*
         * Wake up parent sleeping in kern_wait(), also send
         * SIGCHLD to parent, but SIGCHLD does not guarantee
         * that parent will awake, because parent may masked
         * the signal.
         */
        p->p_pptr->p_flag |= P_STATCHILD;
        wakeup(p->p_pptr);

        ps = p->p_pptr->p_sigacts;
        mtx_lock(&ps->ps_mtx);
        if ((ps->ps_flag & PS_NOCLDSTOP) == 0) {
                mtx_unlock(&ps->ps_mtx);
                sigparent(p, reason, status);
        } else
                mtx_unlock(&ps->ps_mtx);
}

void
childproc_stopped(struct proc *p, int reason)
{
        childproc_jobstate(p, reason, p->p_xstat);
}

void
childproc_continued(struct proc *p)
{
        childproc_jobstate(p, CLD_CONTINUED, SIGCONT);
}

void
childproc_exited(struct proc *p)
{
        int reason;
        int status = p->p_xstat; /* convert to int */

        reason = CLD_EXITED;
        if (WCOREDUMP(status))
                reason = CLD_DUMPED;
        else if (WIFSIGNALED(status))
                reason = CLD_KILLED;
        /*
         * XXX avoid calling wakeup(p->p_pptr), the work is
         * done in exit1().
         */
        sigparent(p, reason, status);
}

/*
 * We only have 1 character for the core count in the format
 * string, so the range will be 0-9
 */
#define MAX_NUM_CORES 10
static int num_cores = 5;

static int
sysctl_debug_num_cores_check (SYSCTL_HANDLER_ARGS)
{
        int error;
        int new_val;

        new_val = num_cores;
        error = sysctl_handle_int(oidp, &new_val, 0, req);
        if (error != 0 || req->newptr == NULL)
                return (error);
        if (new_val > MAX_NUM_CORES)
                new_val = MAX_NUM_CORES;
        if (new_val < 0)
                new_val = 0;
        num_cores = new_val;
        return (0);
}
SYSCTL_PROC(_debug, OID_AUTO, ncores, CTLTYPE_INT|CTLFLAG_RW, 
            0, sizeof(int), sysctl_debug_num_cores_check, "I", "");

#if defined(COMPRESS_USER_CORES)
int compress_user_cores = 1;
SYSCTL_INT(_kern, OID_AUTO, compress_user_cores, CTLFLAG_RW,
        &compress_user_cores, 0, "");

int compress_user_cores_gzlevel = -1; /* default level */
SYSCTL_INT(_kern, OID_AUTO, compress_user_cores_gzlevel, CTLFLAG_RW,
    &compress_user_cores_gzlevel, -1, "user core gz compression level");

#define GZ_SUFFIX       ".gz"   
#define GZ_SUFFIX_LEN   3       
#endif

static char corefilename[MAXPATHLEN] = {"%N.core"};
SYSCTL_STRING(_kern, OID_AUTO, corefile, CTLFLAG_RW, corefilename,
              sizeof(corefilename), "process corefile name format string");

/*
 * expand_name(name, uid, pid, td, compress)
 * Expand the name described in corefilename, using name, uid, and pid.
 * corefilename is a printf-like string, with three format specifiers:
 *      %N      name of process ("name")
 *      %P      process id (pid)
 *      %U      user id (uid)
 * For example, "%N.core" is the default; they can be disabled completely
 * by using "/dev/null", or all core files can be stored in "/cores/%U/%N-%P".
 * This is controlled by the sysctl variable kern.corefile (see above).
 */
static char *
expand_name(const char *name, uid_t uid, pid_t pid, struct thread *td,
    int compress)
{
        struct sbuf sb;
        const char *format;
        char *temp;
        size_t i;
        int indexpos;
        char *hostname;
        
        hostname = NULL;
        format = corefilename;
        temp = malloc(MAXPATHLEN, M_TEMP, M_NOWAIT | M_ZERO);
        if (temp == NULL)
                return (NULL);
        indexpos = -1;
        (void)sbuf_new(&sb, temp, MAXPATHLEN, SBUF_FIXEDLEN);
        for (i = 0; format[i]; i++) {
                switch (format[i]) {
                case '%':       /* Format character */
                        i++;
                        switch (format[i]) {
                        case '%':
                                sbuf_putc(&sb, '%');
                                break;
                        case 'H':       /* hostname */
                                if (hostname == NULL) {
                                        hostname = malloc(MAXHOSTNAMELEN,
                                            M_TEMP, M_NOWAIT);
                                        if (hostname == NULL) {
                                                log(LOG_ERR,
                                                    "pid %ld (%s), uid (%lu): "
                                                    "unable to alloc memory "
                                                    "for corefile hostname\n",
                                                    (long)pid, name,
                                                    (u_long)uid);
                                                goto nomem;
                                        }
                                }
                                getcredhostname(td->td_ucred, hostname,
                                    MAXHOSTNAMELEN);
                                sbuf_printf(&sb, "%s", hostname);
                                break;
                        case 'I':       /* autoincrementing index */
                                sbuf_printf(&sb, "");
                                indexpos = sbuf_len(&sb) - 1;
                                break;
                        case 'N':       /* process name */
                                sbuf_printf(&sb, "%s", name);
                                break;
                        case 'P':       /* process id */
                                sbuf_printf(&sb, "%u", pid);
                                break;
                        case 'U':       /* user id */
                                sbuf_printf(&sb, "%u", uid);
                                break;
                        default:
                                log(LOG_ERR,
                                    "Unknown format character %c in "
                                    "corename `%s'\n", format[i], format);
                        }
                        break;
                default:
                        sbuf_putc(&sb, format[i]);
                }
        }
        free(hostname, M_TEMP);
#ifdef COMPRESS_USER_CORES
        if (compress) {
                sbuf_printf(&sb, GZ_SUFFIX);
        }
#endif
        if (sbuf_error(&sb) != 0) {
                log(LOG_ERR, "pid %ld (%s), uid (%lu): corename is too "
                    "long\n", (long)pid, name, (u_long)uid);
nomem:
                sbuf_delete(&sb);
                free(temp, M_TEMP);
                return (NULL);
        }
        sbuf_finish(&sb);
        sbuf_delete(&sb);

        /*
         * If the core format has a %I in it, then we need to check
         * for existing corefiles before returning a name.
         * To do this we iterate over 0..num_cores to find a
         * non-existing core file name to use.
         */
        if (indexpos != -1) {
                struct nameidata nd;
                int error, n;
                int flags = O_CREAT | O_EXCL | FWRITE | O_NOFOLLOW;
                int cmode = S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP;
                int vfslocked;

                for (n = 0; n < num_cores; n++) {
                        temp[indexpos] = '' + n;
                        NDINIT(&nd, LOOKUP, NOFOLLOW | MPSAFE, UIO_SYSSPACE,
                            temp, td); 
                        error = vn_open(&nd, &flags, cmode, NULL);
                        if (error) {
                                if (error == EEXIST) {
                                        continue;
                                }
                                log(LOG_ERR,
                                    "pid %d (%s), uid (%u):  Path `%s' failed "
                                    "on initial open test, error = %d\n",
                                    pid, name, uid, temp, error);
                                free(temp, M_TEMP);
                                return (NULL);
                        }
                        vfslocked = NDHASGIANT(&nd);
                        NDFREE(&nd, NDF_ONLY_PNBUF);
                        VOP_UNLOCK(nd.ni_vp, 0);
                        error = vn_close(nd.ni_vp, FWRITE, td->td_ucred, td);
                        VFS_UNLOCK_GIANT(vfslocked);
                        if (error) {
                                log(LOG_ERR,
                                    "pid %d (%s), uid (%u):  Path `%s' failed "
                                    "on close after initial open test, "
                                    "error = %d\n",
                                    pid, name, uid, temp, error);
                                free(temp, M_TEMP);
                                return (NULL);
                        }
                        break;
                }
        }
        return (temp);
}

/*
 * Dump a process' core.  The main routine does some
 * policy checking, and creates the name of the coredump;
 * then it passes on a vnode and a size limit to the process-specific
 * coredump routine if there is one; if there _is not_ one, it returns
 * ENOSYS; otherwise it returns the error from the process-specific routine.
 */

static int
coredump(struct thread *td)
{
        struct proc *p = td->td_proc;
        register struct vnode *vp;
        register struct ucred *cred = td->td_ucred;
        struct flock lf;
        struct nameidata nd;
        struct vattr vattr;
        int error, error1, flags, locked;
        struct mount *mp;
        char *name;                     /* name of corefile */
        off_t limit;
        int vfslocked;
        int compress;

#ifdef COMPRESS_USER_CORES
        compress = compress_user_cores;
#else
        compress = 0;
#endif
        PROC_LOCK_ASSERT(p, MA_OWNED);
        MPASS((p->p_flag & P_HADTHREADS) == 0 || p->p_singlethread == td);
        _STOPEVENT(p, S_CORE, 0);

        name = expand_name(p->p_comm, td->td_ucred->cr_uid, p->p_pid, td,
            compress);
        if (name == NULL) {
                PROC_UNLOCK(p);
#ifdef AUDIT
                audit_proc_coredump(td, NULL, EINVAL);
#endif
                return (EINVAL);
        }
        if (((sugid_coredump == 0) && p->p_flag & P_SUGID) || do_coredump == 0) {
                PROC_UNLOCK(p);
#ifdef AUDIT
                audit_proc_coredump(td, name, EFAULT);
#endif
                free(name, M_TEMP);
                return (EFAULT);
        }
        
        /*
         * Note that the bulk of limit checking is done after
         * the corefile is created.  The exception is if the limit
         * for corefiles is 0, in which case we don't bother
         * creating the corefile at all.  This layout means that
         * a corefile is truncated instead of not being created,
         * if it is larger than the limit.
         */
        limit = (off_t)lim_cur(p, RLIMIT_CORE);
        if (limit == 0 || racct_get_available(p, RACCT_CORE) == 0) {
                PROC_UNLOCK(p);
#ifdef AUDIT
                audit_proc_coredump(td, name, EFBIG);
#endif
                free(name, M_TEMP);
                return (EFBIG);
        }
        PROC_UNLOCK(p);

restart:
        NDINIT(&nd, LOOKUP, NOFOLLOW | MPSAFE, UIO_SYSSPACE, name, td);
        flags = O_CREAT | FWRITE | O_NOFOLLOW;
        error = vn_open_cred(&nd, &flags, S_IRUSR | S_IWUSR, VN_OPEN_NOAUDIT,
            cred, NULL);
        if (error) {
#ifdef AUDIT
                audit_proc_coredump(td, name, error);
#endif
                free(name, M_TEMP);
                return (error);
        }
        vfslocked = NDHASGIANT(&nd);
        NDFREE(&nd, NDF_ONLY_PNBUF);
        vp = nd.ni_vp;

        /* Don't dump to non-regular files or files with links. */
        if (vp->v_type != VREG ||
            VOP_GETATTR(vp, &vattr, cred) || vattr.va_nlink != 1) {
                VOP_UNLOCK(vp, 0);
                error = EFAULT;
                goto close;
        }

        VOP_UNLOCK(vp, 0);
        lf.l_whence = SEEK_SET;
        lf.l_start = 0;
        lf.l_len = 0;
        lf.l_type = F_WRLCK;
        locked = (VOP_ADVLOCK(vp, (caddr_t)p, F_SETLK, &lf, F_FLOCK) == 0);

        if (vn_start_write(vp, &mp, V_NOWAIT) != 0) {
                lf.l_type = F_UNLCK;
                if (locked)
                        VOP_ADVLOCK(vp, (caddr_t)p, F_UNLCK, &lf, F_FLOCK);
                if ((error = vn_close(vp, FWRITE, cred, td)) != 0)
                        goto out;
                if ((error = vn_start_write(NULL, &mp, V_XSLEEP | PCATCH)) != 0)
                        goto out;
                VFS_UNLOCK_GIANT(vfslocked);
                goto restart;
        }

        VATTR_NULL(&vattr);
        vattr.va_size = 0;
        if (set_core_nodump_flag)
                vattr.va_flags = UF_NODUMP;
        vn_lock(vp, LK_EXCLUSIVE | LK_RETRY);
        VOP_SETATTR(vp, &vattr, cred);
        VOP_UNLOCK(vp, 0);
        vn_finished_write(mp);
        PROC_LOCK(p);
        p->p_acflag |= ACORE;
        PROC_UNLOCK(p);

        error = p->p_sysent->sv_coredump ?
          p->p_sysent->sv_coredump(td, vp, limit, compress ? IMGACT_CORE_COMPRESS : 0) :
          ENOSYS;

        if (locked) {
                lf.l_type = F_UNLCK;
                VOP_ADVLOCK(vp, (caddr_t)p, F_UNLCK, &lf, F_FLOCK);
        }
close:
        error1 = vn_close(vp, FWRITE, cred, td);
        if (error == 0)
                error = error1;
out:
#ifdef AUDIT
        audit_proc_coredump(td, name, error);
#endif
        free(name, M_TEMP);
        VFS_UNLOCK_GIANT(vfslocked);
        return (error);
}

/*
 * Nonexistent system call-- signal process (may want to handle it).  Flag
 * error in case process won't see signal immediately (blocked or ignored).
 */
#ifndef _SYS_SYSPROTO_H_
struct nosys_args {
        int     dummy;
};
#endif
/* ARGSUSED */
int
nosys(td, args)
        struct thread *td;
        struct nosys_args *args;
{
        struct proc *p = td->td_proc;

        PROC_LOCK(p);
        kern_psignal(p, SIGSYS);
        PROC_UNLOCK(p);
        return (ENOSYS);
}

/*
 * Send a SIGIO or SIGURG signal to a process or process group using stored
 * credentials rather than those of the current process.
 */
void
pgsigio(sigiop, sig, checkctty)
        struct sigio **sigiop;
        int sig, checkctty;
{
        ksiginfo_t ksi;
        struct sigio *sigio;

        ksiginfo_init(&ksi);
        ksi.ksi_signo = sig;
        ksi.ksi_code = SI_KERNEL;

        SIGIO_LOCK();
        sigio = *sigiop;
        if (sigio == NULL) {
                SIGIO_UNLOCK();
                return;
        }
        if (sigio->sio_pgid > 0) {
                PROC_LOCK(sigio->sio_proc);
                if (CANSIGIO(sigio->sio_ucred, sigio->sio_proc->p_ucred))
                        kern_psignal(sigio->sio_proc, sig);
                PROC_UNLOCK(sigio->sio_proc);
        } else if (sigio->sio_pgid < 0) {
                struct proc *p;

                PGRP_LOCK(sigio->sio_pgrp);
                LIST_FOREACH(p, &sigio->sio_pgrp->pg_members, p_pglist) {
                        PROC_LOCK(p);
                        if (p->p_state == PRS_NORMAL &&
                            CANSIGIO(sigio->sio_ucred, p->p_ucred) &&
                            (checkctty == 0 || (p->p_flag & P_CONTROLT)))
                                kern_psignal(p, sig);
                        PROC_UNLOCK(p);
                }
                PGRP_UNLOCK(sigio->sio_pgrp);
        }
        SIGIO_UNLOCK();
}

static int
filt_sigattach(struct knote *kn)
{
        struct proc *p = curproc;

        kn->kn_ptr.p_proc = p;
        kn->kn_flags |= EV_CLEAR;               /* automatically set */

        knlist_add(&p->p_klist, kn, 0);

        return (0);
}

static void
filt_sigdetach(struct knote *kn)
{
        struct proc *p = kn->kn_ptr.p_proc;

        knlist_remove(&p->p_klist, kn, 0);
}

/*
 * signal knotes are shared with proc knotes, so we apply a mask to 
 * the hint in order to differentiate them from process hints.  This
 * could be avoided by using a signal-specific knote list, but probably
 * isn't worth the trouble.
 */
static int
filt_signal(struct knote *kn, long hint)
{

        if (hint & NOTE_SIGNAL) {
                hint &= ~NOTE_SIGNAL;

                if (kn->kn_id == hint)
                        kn->kn_data++;
        }
        return (kn->kn_data != 0);
}

struct sigacts *
sigacts_alloc(void)
{
        struct sigacts *ps;

        ps = malloc(sizeof(struct sigacts), M_SUBPROC, M_WAITOK | M_ZERO);
        ps->ps_refcnt = 1;
        mtx_init(&ps->ps_mtx, "sigacts", NULL, MTX_DEF);
        return (ps);
}

void
sigacts_free(struct sigacts *ps)
{

        mtx_lock(&ps->ps_mtx);
        ps->ps_refcnt--;
        if (ps->ps_refcnt == 0) {
                mtx_destroy(&ps->ps_mtx);
                free(ps, M_SUBPROC);
        } else
                mtx_unlock(&ps->ps_mtx);
}

struct sigacts *
sigacts_hold(struct sigacts *ps)
{
        mtx_lock(&ps->ps_mtx);
        ps->ps_refcnt++;
        mtx_unlock(&ps->ps_mtx);
        return (ps);
}

void
sigacts_copy(struct sigacts *dest, struct sigacts *src)
{

        KASSERT(dest->ps_refcnt == 1, ("sigacts_copy to shared dest"));
        mtx_lock(&src->ps_mtx);
        bcopy(src, dest, offsetof(struct sigacts, ps_refcnt));
        mtx_unlock(&src->ps_mtx);
}

int
sigacts_shared(struct sigacts *ps)
{
        int shared;

        mtx_lock(&ps->ps_mtx);
        shared = ps->ps_refcnt > 1;
        mtx_unlock(&ps->ps_mtx);
        return (shared);
}

The Project Gutenberg EBook of Tehtaan tytöt, by Maria Furuhjelm

This eBook is for the use of anyone anywhere at no cost and with
almost no restrictions whatsoever.  You may copy it, give it away or
re-use it under the terms of the Project Gutenberg License included
with this eBook or online at www.gutenberg.net


Title: Tehtaan tytöt

Author: Maria Furuhjelm

Release Date: June 14, 2005 [EBook #16068]

Language: Finnish


*** START OF THIS PROJECT GUTENBERG EBOOK TEHTAAN TYTÖT ***




Produced by Matti Järvinen and Tuija Lindholm.





Tehtaan tytöt


Kirjoittanut
Maria


Ensimmäisen kerran julkaissut
Kansanvalistusseura 1912.




Tehtaantytöt.

Kirjoittanut Maria.




Eräänä syysiltana, kun Tervolan torpan emäntä ja hänen vanhin tyttärensä
Miina istuivat rukkiensa ääressä, sanoi Miina yhtäkkiä:

"Äiti, talveksi minä menen tehtaaseen työhön."

"Mitä joutavia", sanoi äiti seisauttaen rukkinsa.

"Niin, täällä kotona olen raatanut pienestä pahasesta, seitsemän,
kahdeksan vanhasta asti, ensin hoitanut lapsia, sitten elukoita, tehnyt
raskasta maatyötä ja nyt tahdon päästä paremmille ja helpommille
päiville."

"Luuletko sinä, että tehdastyö sitten on helpompaa?" virkahti Liisa
sisko, joka karstasi villoja uunin ääressä. "Minä puuhaan puutarhassa,
lypsän lehmiä tahi teen mitä tahansa mieluummin kuin menen tehtaaseen."

"Aina sinä siitä puutarhastasi puhut", sanoi Miina ylenkatseellisesti.

"Mutta kuinka olet tullut ajatelleeksi tehtaaseen menoa?" kysyi äiti.

Miina puuhaili rukkinsa ääressä ja sanoi: "Nivalan Leena oli kotona
juhannuksena, hän tekee työtä villatehtaassa ja sinne minäkin tahdon."

Nyt tuli torpanisäntä tupaan ja kävi uunin eteen lämmittelemään.

"Kuules, Antti", sanoi äiti, "meidän Miina tahtoo mennä tehtaaseen."

Antti ei koskaan jutellut turhia ja siksipä hän nytkin vain katseli
tytärtään,

"Niin", sanoi Miina, "tehtaassa on kymmentuntinen työpäivä ja
päiväpalkka voi nousta kahteen markkaan viiteenkymmeneen penniin saakka.
Pyhäpäivät saa olla vapaana. Täällä kotona täytyy pyhinäkin keittää
ruokaa, lypsää lehmät ja ruokkia elukat. Ja Leenalla oli niin hienot
nappikengät ja ne tehtaantytöt syövät vain kahvia ja vehnäleipää."

"Se on kovin järjetöntä", sanoi äiti.

"Ja minä olen kuullut, että niiden täytyy *seistä* kaiket päivät", sanoi
Liisa.

"Entäs sitten, kyllä minä jaksan seistä", sanoi Miina.

"Ja mitä he tekevät muun osan päivää?" kysyi Antti hitaasti.

"Enhän minä tiedä", sanoi Miina jurosti. Hän huomasi, että kaikki olivat
häntä vastaan.

"Jos he aamuisin nousevat neljältä tai viideltä, niin ovathan he jo
viimeistään kello kolmelta lopettaneet työnsä."

"En minä luule, että he nousevat niin aikaisin aamusella," sanoi Miina,
"he tekevät työtä vain vähän keskipäivällä ja iltaisin he menevät
tansseihin tai kokouksiin."

"Sitten en minä usko, että heillä on niin suurta palkkaa", sanoi Antti
päättävästi. "Vai kymmenen tuntia..."

"Onpahan, isä", innostui Miina sanomaan, "ja täällä kotona meidän täytyy
nousta kello neljältä ja ahertaa koko päivä myöhään iltaan, yhdeksään
asti ja kesäkiireellä kymmeneen, jopa yhteentoistakin saakka."

Antti katsella tuijotti taas tytärtänsä ja sanoi hitaasti: "sinä et
ainakaan näytä siltä, kuin olisit tehnyt liiaksi työtä. Punainen ja
pyöreä olet. Pulskemmaksi et voi tulla kahvista ja vehnäleivästä. Mutta
mene vaan tehtaaseen, koska et huoli Lintulan Kasperista, talollisen
pojasta."

"Isä, kuinka voit sanoa niin", huudahti äiti, "kyllähän Miina tarvitaan
kotonakin ja ne tehtaantytöt ovat niin kelvottomia."

"En minä aio tulla kelvottomaksi", sanoi Miina, "Liisa voi auttaa äitiä,
hänhän on jo seitsemännellätoista ja pojat auttavat isää."

"Niin, kyllähän täällä toimeen tullaan", sanoi Antti ja katseli
tyytyväisenä suurikasvuisia, reippaita poikiaan. "Niin, ja saattaahan se
olla hyväkin, että joku lapsista ansaitsee rahaa."

Isä riisui märjät saappaat jalastaan ja Liisa toi hänelle heti kuivat,
lämpimät sukat ja eheät tallukat. Sitten hän ripusti isän märjät sukat
nuoralle uunin taakse kuivamaan, sulloi saappaat täyteen heiniä ja pani
ne märkiä jalkineita varten laitetulle telineelle, joka oli kiinnitetty
kattoon.

Kaikki olivat tänä iltana jotenkin hiljaiset. Miinan tehtaaseen meno
heitä huolestutti. Vain nelivuotias Tiina jutteli nukkensa ja kissansa
kanssa.

Mutta äiti oli levoton ja päätti mennä pappilaan puhumaan papinrouvan
kanssa.

       *       *       *       *       *

Toimitettuaan aamuaskareensa seuraavana päivänä, silitti emäntä
hiuksensa, sitoi parhaan huivin päähänsä, pani puhtaan esiliinan eteensä
ja meni pappilaan muka viemään lämpimäisiä papinrouvalle.

"Nyt äiti menee kertomaan papinrouvalle, että Miina aikoo lähteä
tehtaaseen", sanoi Matti-veli silmät veitikkamaisessa hymyssä katsellen
äitiä ikkunasta.

"Menköön vaan, ei papinrouva voi kieltää minua lähtemästä", uhmaili
Miina.

"Mutta et suinkaan sinä mene tehtaaseen, jos se papinrouvan mielestä on
tuhmasti tehty?" kysyi Liisa.

"Menenpähän", vastasi Miina.

Sisarukset vaikenivat. He olivat tottuneet täydellisesti luottamaan
papinrouvan viisauteen ja hyvyyteen, rouvahan oli antanut äidille niin
monta hyvää neuvoa ja oli ollut perheen ystävä niin hyvin surussa kuin
ilossa. -- --

Tervolan emäntä istui papinrouvan kanssa pappilan ruokasalissa. Rouva
huomasi kyllä, että hänellä oli jotain sydämellään, mutta ei tahtonut
kysyä, mitä se oli. Kylläpähän kertoo, kun ennättää, arveli rouva. Kun
kahvit oli juotu ja rouva taas oli ottanut työn käteensä, virkahti Anna:

"Ajatelkaahan, hyvä rouva, Miina tahtoo mennä tehtaaseen."

"Miina!" huudahti rouva. "Hänenhän on niin hyvä olla kotona ja onhan hän
ollut hyväksi avuksi sekä sinulle että miehellesi."

"Niin, onhan hän ollut, mutta hänen mielestään hänellä on kotona liiaksi
työtä", naurahti Anna.

"No, miksei hän sitten tahtonut mennä naimisiin talollisen pojan
kanssa?"

"Eipähän tahtonut", sanoi Anna hymyillen. "Kas, meidän tyttöjen on niin
hyvä olla kotona. Vaikka meillä on vain torppa, ja tytöt ovat saaneet
tehdä aika lailla työtä, niin on heidän elämänsä tyyni ja huoleton. On
vallan toista tehdä työtä vierasten luona. Isä on ryyppäämätön ja
hyvänluontoinen, eikä kaikilla torpantytöillä ole niin hauskaa kotia
eikä puutarhaa, eikä niin hyvää ruokaa kuin meidän tytöillä on. Miina
kyllä tietää, että elämä olisi vallan toisellaista, jos hänellä olisi
suuri talous ja ankara anoppi. Ja jos sanon täyden totuuden, niin on
koko Lintulan talo kuin suuri roskaläjä."

"Mutta nyt Miina tahtoo pois siitä hauskasta kodista", ihmetteli
papinrouva.

"Niinhän tuo tahtoo, se Nivalan Leenahan hänet siihen on viekoitellut.
Leena oli kesällä pari päivää kotona ja näytteli Muualle kauniita
puseroitaan ja nappikenkiään ja puhui kahvista ja vehnäleivästä."

Papinrouva huokasi: "sehän se tavallisesti houkuttelee nuoria tyttöjä."

"Minä pelkään enimmin huonoa esimerkkiä", sanoi Anna, "Olen kuullut,
että kaikki tehtaantytöt ovat huonoja ihmisiä."

"Eihän toki, Anna", sanoi papinrouva vakavasti, "mutta ne raukat tulevat
usein niin nuorina ja kokemattomina tehtaaseen. Ne, joilla ei ole kotia,
asuvat yhdessä toisten yhtä nuorten ja lukemattomien, ehkäpä jo
turmeltuneiden tyttöjen kanssa. He ovat ilman turvaa, joutuvat helposti
huonoon seuraan, eivätkä ymmärrä arvostella ihmisiä. Heillä ei ole
ketään, jolta kysyisivät neuvoa, ei ketään, jonka puoleen voisivat
kääntyä. Siksi he helposti joutuvat kiusaukseen ja lankeevat. Mutta
heidän joukossaan on monta hyvää ja kunnollista tyttöä. Ja onhan Miina
saanut kasvaa kahdeksannentoista ikävuoteensa asti hyvässä kodissa.
Hänen pitäisi voida pysyä hyvillä teillä. Ja sitä paitsi hän on vakava
ja kelpo tyttö."

"Niin, onhan hän", myönsi Anna, "mutta eikö rouva kumminkin kieltäisi
häntä menemästä tehtaaseen? Menköön ennemmin palvelukseen, jos tahtoo
pois kotoa."

"Minä en tekisi oikein, jos sekaantuisin asiaan", sanoi papinrouva
ystävällisesti taputtaen Annaa olkapäälle. "Miina on kesästä saakka
ajatellut tätä asiata, ja vaikka hän minunkin mielestäni tekee tyhmästi
jättäessään hyvän kotinsa, jossa hänellä on tarpeeksi työtä, niin on
parasta, että nuoret saavat koettaa, miltä tuntuu maailmallaolo, kun
eivät enää viihdy kotona. Jos on kasvattanut lapsensa Jumalan pelvossa
ja hyvissä tavoissa ja opettanut heitä tekemään työtä, niin voi
tyyneesti lähettää heidät maailmalle. Jos sinä nyt kieltäisit häntä
menemästä, niin hän ehkä tekisi tyytymättömästi työnsä täällä kotona ja
toivoisi vain pois ja kuvittelisi, että olo tehtaassa olisi niin paljon
parempaa. Mutta jos annat hänen koettaa, niin on mahdollista, että hän
tulee takaisin jonkun ajan kuluttua. Juuri siksi, että Miinalla on niin
hyvä koti ja että hän on niin järkevä tyttö, toivon minä kaiken käyvän
hyvin."

Anna huokasi syvään. Hän oli todellakin toivonut, että papinrouva
sekaantuisi asiaan, neuvoisi Miinaa, niin, vieläpä kieltäisikö häntä
menemästä tehtaaseen. Mutta kotimatkalla hän ajatteli tarkemmin asiata
ja tuli lopulta vakuutetuksi siitä, että rouva oli oikeassa.

Kun hän astui tupaan, seisoi Liisa uunin ääressä laittamassa ruokaa,
Miina kirnusi voita ja pikku Tiina nukkui sängyssä. Isä ja pojat olivat
metsässä.

Molemmat tytöt katselivat uteliaina äitiä, kun hän pani huivinsa arkkuun
ja otti esiin rukkinsa.

"No, mitä papinrouva sanoi Miinasta?" kysyi Liisa kiihkeästi.

"Rouva arveli, että antaa vaan Miinan mennä, kosk'ei hän enää viihdy
kotona", sanoi äiti tyyneesti.

Miina näytti hieman nololta. Hän oli varustautunut vastarintaan, eikä
sitä nyt tarvittukaan. Nivalan Leena oli maininnut, että Pyhäinmiesten
päivästä tuli yksi paikka tehtaassa vapaaksi, nyt täytyi vain kirjoittaa
sinne ja laittaa Miinan vaatteet kuntoon. -- --

Viimeistä yötä makasi Miina kotona vanhassa sängyssä Liisan vieressä.
Kyyneleet tulivat hänen silmiinsä ja hänen sydäntänsä ahdisti, kun hän
ajatteli tuntematonta tulevaisuuttaan, häntä pelotti lähteä yksin
vierasten ihmisten pariin. Kuinka hän saattoikaan jättää isän, äidin ja
sisarukset? Mutta sitten hän taas rupesi ajattelemaan kaikkea, mitä
Leena oli kertonut, ja laskiessaan, miten paljon rahaa hän ansaitsisi
yhdessä vuodessa, vaipui hän syvään, rauhalliseen uneen.

       *       *       *       *       *

Oli kevät ja kiire pellolla ja puutarhassa. Pitkät kankaat olivat
valkenemaan osoitteena äidin ja Liisan ahkeruudesta. Pari lihavaa,
hienokarvaista vasikkaa ammui navetassa. Lampaat käydä, tepastelivat
edestakaisin, kun karsinaa puhdistettiin. Kukko kiekui ja kanat nokkivat
ja kuopivat pihalla lähellä tunkiota. Kaikki näytti niin hauskalta ja
iloiselta, mutta Liisa istui portailla ja itki katkerasti.

Silloin astui papinrouva veräjästä pihalle.

"Mikä nyt on hätänä, rakas lapsi?" kysyi hän säälivästi,

"Velli pääsi palamaan pohjaan", nyyhkytti Liisa, "ja kaikki olivat niin
vihaiset minulle. Äiti sanoi, että tuli suuri vahinko, kun ruoka
pilaantui, pojat ilkkuivat ja Tiina sylkäsi vellin suustaan ja isä ....
sanoi, että se oli puutarhan syy. Mutta ei se sen syy ollut. Täytyihän
minun tietystikin kaivaa multa pehmeäksi raparperin ja ruohosipulin
ympäriltä, kun minut oli jätetty kotiin päivällistä laittamaan. Mutta
minä juoksin alinomaan tupaan hämmentämään pataa. Vaan sitten en
huomannutkaan, että Tiina meni sisään ja että se pikku ilkimys työnsi
koko hellan täyteen puita, niin että velli paloi pohjaan. Kun on kädet
täynnä ... eikä Tiina tee koko päivänä muuta kuin pahaa. Mutta minä en
tahtonut kannella isälle, sillä silloin Tiina olisi saanut selkäänsä."

"Se oli hyvin tehty, Liisa, Tiinahan on vielä niin pieni ja
ymmärtämätön. Älä itke enää. Minä opetan sinua keittämään velliä niin,
ettei se koskaan pala pohjaan."

Liisa pyyhki kiireesti kyyneleensä. Hän uskoi papinrouvan voivan tehdä
mitä tahansa ja katseli häntä suurella luottamuksella.

"Milloin teillä ensi kerta keitetään puuroa tai velliä?" kysyi rouva.

"Lauantaina", vastasi Liisa.

Rouva oli kerran ullakolla nähnyt suurenlaisen nelisnurkkaisen
puulaatikon, jossa oli säpillä eli hakasella kiinni pantava kansi. Hän
lähetti Liisan pappilaan noutamaan muutamia voilokinpalasta, joita oli
käytetty pianoa pappilaan kuljetettava. Sitten hän naulasi
voilokinpalaset laatikon sisäpuolelle, sulloi sen heiniä täyteen ja vei
sen taas ullakolle. Kun kaikki olivat lauantai-aamuna menneet työhön,
tuli papinrouva Tervolaan. Hän voiteli suuren padan Pohjan voilla, pani
sen puolilleen vettä ja pisti sen tulelle. Kun vesi kiehui, vispilöitiin
ohraryynit siihen sekaan. Kun Liisa oli huolellisesti hämmentänyt puuroa
noin neljännestunnin niin, että koko seos kiivaasti kiehui, nostettiin
pata tulelta, tiukasti sopiva kansi pantiin padan päälle ja pata
pistettiin laatikkoon syvälle heiniin. Heinätyyny asetettiin
padankannelle ja sitten suljettiin laatikon kansi säpillä.

"Kun väki tulee päivälliselle, niin on puuro valmista", sanoi
papinrouva.

Liisa katsoi vuoroin rouvaan, vuoroin laatikkoon ja änkytti: "mutta,
mutta..."

"Puuro kypsyy hiljalleen padassa", selitti rouva, "mutta ei saa avata
kantta eikä laskea ulos lämmintä."

"Mutta ei suinkaan se vaan pala pohjaan?" kysyi Liisa.

"Ei pala", vakuutti rouva.

"Ja kypsyyköhän se? Kun ne kaikki tulevat kotiin, on niillä nälkä kuin
susilla."

"Kyllä se kypsyy", vastasi rouva ja katsoi kelloaan.

Sitten hän meni kotiin.

Kun Liisa näki isän, äidin ja veljet pihalla, aukaisi hän peloissaan
laatikkonsa.

Kypsän, maukkaan ohrapuuron tuoksu lemusi häntä vastaan padasta. Hän
otti lusikan ja maistoi. Ryynit olivat pehmeät ja puuro oli sopivan
paksua. Hän kaasi puuron vatiin. Äiti pani voisilmän siihen ja sitten he
kaikki istuutuivat pöytään.

"Nyt luulen, että olet tuhlannut voita", sanoi äiti syötyään pari
lusikallista.

"Puuro on niin hyvää", kiittelivät pojat.

"Niin, mutta sinä olet kai keittänyt sen paljaassa maidossa", sanoi
äiti.

Liisa nauroi niin, että hytki.

"Puuro on keitetty paljaaseen veteen ja voita siinä on juuri yhtä
paljon, kuin muulloinkin on ollut", vakuutti hän. "Minä olen keittänyt
puuron tiukkakantisessa laatikossa ja siksi se on niin hyvää."

Äiti huomasi nyt laatikon, näki, ettei ollut tulta pesässä, ja katsoi
kummissaan tyttöön. Pojat juoksivat laatikolle ja tunnustelivat heiniä.
Aivan oikein, heinät olivat vielä lämpöiset.

"Papinrouva on ihan varmaan ollut täällä", sanoi äiti, "kyllähän minä
nyt muistan, että hän kerran puhui heinissä keittämisestä, mutta en ole
tullut panneeksi sitä mieleeni. Kun meillä on puita tarpeeksi, niin ei
tule ajatelleeksi semmoista."

"Kyllähän se niinkin on", riensi Liisa sanomaan, "mutta tällä tavoin ei
puuro pala pohjaan." Ja sitten hän kertoi, että papinrouva oli nähnyt
hänen itkevän, kun häntä oli nuhdeltu siksi, että velli oli pohjaan
palanutta.

"Ei siltä rouvalta koskaan konstit puutu", tuumi Antti itsekseen.

Nytkös oli Liisasta hauskaa, melkein joka päivä hän keitti ruokaa
heinälaatikossa. Milloin laittoi hän puuroa, milloin velliä, milloin
perunakeittoa, milloin uunijuustoa. Sill'aikaa kun ruoka kypsyi, teki
hän työtä puutarhassa tahi pihamaalla, juotti vasikat, syötti porsaat ja
piti pikku Tiinaa työssä niin, ettei tämä päässyt tekemään niin paljon
pahaa.

Mutta kerran kävi hullusti.

Liisa ei ollut varannut tarpeeksi aikaa hernekeittoa varten ja herneet
olivat vain puolikypsät, kun muut perheenjäsenet tulivat päivälliselle.
Silloin häntä taas toruttiin ja taas hän itki, mutta hämärissä hän otti
pikku Tiinan syliinsä ja riensi pappilaan. Ja papinrouva antoi hänelle
pienen kirjoituksen, jossa oli neuvoja niille, jotka tahtoivat keittää
heinissä.

*Hernekeiton* täytyy olla heinälaatikossa 5 tahi 6 tuntia. Sen saattaa
jo edellisenä iltana kiehauttaa ja pistää heinälaatikkoon ja sitten
keittää uudestaan aamulla. Kuutta desilitraa herneitä kohti tarvitaan 3
litraa vettä. *Riisi-*, *ohra-* ja *tattariryynit* tarvitsevat
kypsyäkseen 3 tuntia. Neljää desilitraa ryynejä kohti tarvitaan 2 litraa
vettä tai maitoa. *Mankeloitujen kauraryynien* tarvitsee olla laatikossa
vain tunnin. *Isot ohraryynit* tarvitsevat 5--6 tuntia kypsyäkseen
laatikossa ja imevät itseensä enemmän vettä kuin pieniksi survotut
ryynit.

*Lampaanlihaa ja kaalia* valmistetaan seuraavasti: 1 kilo pieniksi
palasiksi leikattua lampaanlihaa, 20 kuorittua perunaa, 1 1/2 litraa
hienoksi leikattua kaalia, 1 litra vettä, vähän suolaa, sipulia ja
muutama pippurinjyvä keitetään hyvällä tulella 20 minuuttia. Pata
asetetaan heinälaatikkoon 4--5 tunniksi. Kantta ei saa nostaa
katsoakseen, onko ruoka valmista, sillä silloin pääsee lämpö ulos
laatikosta. Kun on ottanut ruuan heinistä, voi sen vielä kiehauttaa
tulella. -- Vähän tottumusta ja harjoitusta tarvitaan, jotta oppisi
keittämään heinissä.

       *       *       *       *       *

Miina oli ollut poissa kotoa melkein kaksi vuotta. Hän oli hidas
kirjeiden kirjoittaja ja kotiväki tiesi hänestä kovin vähän. Alussa hän
kertoi joka viikko panevansa rahaa säästöön postisäästöpankkikirjaansa,
mutta sitten hän rupesi valittamaan, etteivät rahat tahtoneet riittää
hänen menoihinsa. Äiti lähetti hänelle silloin tällöin parin sukkia ja,
kun suutari oli Tervolassa työssä, tehtiin Miinan vanhan mitan mukaan
pari lujia vasikannahkakenkiä, jotka lähetettiin hänelle kaupunkiin.
Mutta vähän väliä Miina kirjoitti vieläkin, että kaikki oli niin
kallista. -- --

Jouluna piti Miinan päästä kotiin kolmeksi päiväksi. Tervolassa oli ilo
ylimmillään. Kaikki joulupuuhat toimitettiin vikkelästi. Liisa puhdisti
joka nurkan. Tiina juoksi hänen kintereillään ja auttoi häntä. Liisa
harjasi lehmät tavallista huolellisemmin sekä leipoi äidin kanssa
ohraleipiä, joista Miina niin kovasti piti. Pojat loivat teitä
pihamaalle, puhdistivat tallin, ajoivat kotiin heiniä ja olkia ja puita
pyhiksi sekä lämmittivät saunan.

Antti oli itse lähtenyt noutamaan Miinaa kotiin ja heidän ajaessaan
pihalle riensivät kaikki tuvasta portaille tulijoita vastaan. Helisevä
pakkanen oli purrut Miinan posket ja nenänipukan koreanpunaisiksi. Kun
hän tupaan tultuaan oli riisunut saalin päästään, arvelivat kaikki, että
hän oli jotensakin samannäköinen kuin ennenkin. Mutta kun puna poskista
oli haihtunut, huomasi äiti, miten kalpeaksi ja laihaksi hänen tyttönsä
oli muuttunut. Liisa ja Tiina huomasivat heti hänen kirjavan puseronsa
ja leveän nahkavyön, joka teki hänet niin hoikaksi vyötäisiltä. Kädet
olivat hienot ja valkoiset. Saattoi tuskin uskoa, että tämä tyttö, jonka
tukka oli kammattu korkealle päälaelle, oli se entinen vahva,
punaposkinen Miina, jonka vaaleat, paksut palmikot riippuivat niskassa,

"Voi, kuinka hyvältä puuro täällä kotona maistuu", virkahti Miina,
syötyään pari lusikallista, "ja kuinka punaisilta ja terveiltä te
näytätte", lisäsi hän katseltuaan vanhempiaan ja sisaruksiaan. "Minä
olen niin tottunut näkemään vaan kalpeita tehtaantyttöjä."

"Niin, sinä et ole tullut lihavammaksi kahvista ja vehnäleivästä", sanoi
isä puoleksi leikillä.

Miina oli hieman hämillään ja sanoi: "ensi kerran pitkään aikaan minun
on nälkä."

"Eikö sinun ole nälkä joka päivä?" kysyi Matti silmät pyöreinä.

"Ei ole. Ja sitä kyllästyy niin kovasti kahviinkin."

"Kyllästyy kahviin!" kirkasi pikku Tiina, joka sai maistaa tätä juomaa
vain suurina juhlina ja sunnuntaisin. Kaikki nauroivat, mutta äiti
sanoi: "olet matkustanut raittiissa ilmassa, siksi olet saanut
ruokahalun."

"Kai se niin on. Tehtaassa haisee öljyltä ja on niin kuuma, enkä minä
käy ulkona muuta kuin työhön mennessäni ja sieltä kotiin tullessani." --
--

Pyhäpäiviksi oli kaikki käsityöt pantu syrjään. Syötettiin vain elukat
ja valmistettiin ateriat. Isä ja pojat antoivat hevosille heiniä ja
kauroja sekä toivat puita ja vettä. Siksi oli koko perheellä hyvä aika
istua tuvassa ja puhella tahi oikeammin kuunnella Miinan puhetta, sillä
hän kertoi työstään tehtaassa ja elämästään kaupungissa. Miina, joka
aina oli ollut niin harvapuheinen, oli ruvennut puhumaan niin paljon.
Hän oli lukenut kirjoja ja sanomalehtiä lukutuvassa ja käynyt huveissa
ja kokouksissa.

Kun Anna toisena joulupäivänä oli lukenut saarnan ja kun kaikki yhdessä
olivat veisanneet muutamia virsiä, alkoivat he taas puhua tehtaasta.

"Mitä te sunnuntaisin teette?" kysyi Liisa.

"Ensin nukutaan oikein kauan ja sitten juodaan kahvia", vastasi Miina,
"ja sitten käherretään hiukset, pannaan parhaat vaatteet ylle ja mennään
jonkun tuttavan tykö kahville. Päivällisen jälkeen taas kävellään.
Hauskinta on silloin niillä, joilla on sulhanen. Ja sitten mennään ehkä
lukusaliin tahi johonkin kokoukseen."

"Sinunhan piti panna rahaa pankkiin", sanoi isä vähän levottomana.
Miinan tehdastyö oli koko ajan ollut isälle vain rahakysymys.

"Niin, mutta minä olen ottanut pois pankista sen vähän, minkä sinne
alussa panin", sanoi Miina alakuloisena.

Miina oli ottanut kaikki vaatteensa mukaansa voidakseen näyttää
kotoväelle koko koreutensa. Hän oli asettanut sisarten ihailtavaksi
hameita, puseroita, pitsejä, kaulanauhoja, kenkiä, rintasolkia,
vaaleanharmaan "saketin" sekä valkoisen leveälierisen olkihatun, joka
oli vihreitä lehtiä, kirsimarjaterttuja ja omenankukkia täynnä. Mutta
äiti sanoi: "kylläpä täytyy olla suuri palkka, jotta voisi ostaa
tuollaisia vaatteita ja noin paljon sitten! Tuohon koreuteenhan ne rahat
ovat menneet."

"Enhän minä voi käydä huivi päässä, kun muut ovat hattupäisiä", sanoi
Miina äreästi.

"Yksinkertainen olkihattu, jossa on musta tai kirjava nauha, ei maksa
enempää kuin hyvä huivi, niin että ei se hattu paljoakaan rahaa niele",
sanoi äiti tyyneesti, "mutta kukat ja tuo muu roska, joka pilaantuu
sateessa ja tomussa, ja kaikki nuo pitsit ja puserot, ne ne rahaa
vievät. En olisi koskaan uskonut, että sinä, Miina, joka olit niin
järkevä, olisit antanut viekoitella itseäsi sellaiseen. Köyhä tyttö ei
tarvitse muuta kuin yhden työpuvun ja yhdet pyhävaatteet. Silloin voi
hankkia itselleen myöskin hyvät alusvaatteet, mutta sinun hyvät paitasi,
jotka sait kotoa, näyttävät huonoilta, etkä sinä ole paikannut, etkä
pitänyt niitä kunnossa."

"Mutta äiti, koska luulette minun ehtivän ommella?" virkahti Miina.

Isä otti piipun suustaan ja sanoi: "etkö sinä ehdi ommella itsellesi
niinä neljäntoista tuntina, jolloin et ole työssä?"

Miina ei heti voinut vastata mitään ja silloin huusi pikku Tiina: "nyt
tulee papinrouva!"

Liisa riensi puhaltamaan hiilosta ja panemaan kahvipannua tulelle ja
äiti meni ulos ottamaan vastaan kunnioitettua vierasta.

Tervehdittyään ystävällisesti kaikkia, kääntyi papinrouva Miinan
puoleen.

"Minun täytyi oikein tulla tervehtimään sinua, kun kuulin, että viivyt
kotona vain pari päivää", sanoi hän. "Sinä olet tullut niin laihaksi ja
kalpeaksi, rakas lapsi."

Miina punastui ja niiasi.

"Minä olen sanonut samaa", virkkoi Anna huolestuneena. "Miinahan oli
niin pyöreä ja punaposkinen."

"Tehdastyö on epäterveellisempää kuin maatyö ja taloustoimet", sanoi
rouva. "Ilma on huono ja sinun täytyy kai seistä?"

"Täytyy, koko päivä. Ensi alussa olivat jalkani turvonneet ja niitä
särki niin, etten saanut unta iltaisin, mutta nyt olen tottunut
seisomaan."

"Mutta hoidatkohan muuten itseäsi järkevästi", kysyi papinrouva
ystävällisesti, "vai elätkö kahvilla ja vehnäleivällä, niinkuin niin
monet muutkin nuoret työläisnaiset."

"Hän on kyllästynyt kahviin", kirkasi pikku Tiina, ja hänen
liinatukkainen päänsä pilkisti esiin äidin tuolin takaa.

"Oi, oi", nauroi papinrouva, "eikös ole parempi saada kahvia vain
silloin tällöin, pikku Tiina. Silloin se aina maistuu hyvältä."

"Niin, ja sitten tulee niin terveeksi ja vahvaksi, kun syö maitoa ja
leipää", selitti pikku Tiina.

"Ei sitä ehdi keittää ruokaa itselleen, kun on vaan tunnin
päivällisaika", sanoi Miina. "Ostetaan vähän vehnäleipää ja keitetään
pannu kahvia. Se käy niin nopeasti."

"Hänellä on vaan neljätoista tuntia joutoaikaa", sanoi Antti
naureskellen, "mitäpä hän ehtisi keittää ja paistaa."

"Isä on niin paha, kun aina vatkuttaa tuota neljäntoista tuntia", sanoi
Miina itku kurkussa, "täytyyhän sitä nukkua ja levätäkin."

"Älä ole pahoillasi, Miina, leikkiähän se isä vain laskee", sanoi äiti
sovitellen. "Kyllähän sinä tiedät, että meidän täällä Tervolassa täytyy
tehdä työtä paljon enemmän kuin kymmenen tuntia. Siksihän sinä juuri
läksitkin pois kotoa."

"Mutta täällä kotona ei tarvitse *seisoa* koko päivää."

"Ei, sinä sait istua kangaspuissa ja rukin ääressä", sanoi äiti
naurahtaen.

Nyt oli kahvi valmis, ja koska oli juhlapäivä, sai pikku Tiinakin
kupillisen sitä sekä suuren viipaleen vehnäleipää.

Kun Liisa oli vienyt pois kahvivehkeet, otti hän esiin heinälaatikkonsa
ja rupesi lieden ääressä valmistelemaan mannaryynipuuroa päivälliseksi.

"Kuuleppas, Miina", sanoi Antti, "keittäisit puuroa laatikossa, niinkuin
Liisa tekee." Isä nauroi harvoin, mutta nyt hän nauroi oikein sydämensä
pohjasta.

"Niin, sehän käy erinomaisesti", virkahti äiti ihastuksissaan.

Miina katseli hämmästyneenä laatikkoa. Hän luuli, että he laskivat
leikkiä. Mutta Liisa alkoi innokkaasti selittää, kuinka hän teki, ja
vakuutti, että puuro tahi mikä muu ruoka tahansa kiehui itsekseen
laatikossa. Papinrouva oli opettanut sen heille.

"Isä osui oikeaan", sanoi rouva. "Vähällä vaivalla ja huolella voit
hankkia itsellesi hyvää ja terveellistä ruokaa sillä palkalla, mikä
sinulla on. Mutta vaivaa siitä on, eivätkä rahat silloin riitä
ylellisiin koristuksiin. Minä näin Helsingissä tyttöjä, joita asui kuusi
yhdessä pienessä huoneessa, he söivät silliä ja leipää ja joivat kahvia
päälle, voidakseen sunnuntaisin käydä hienoissa vaatteissa ja hatuissa
sekä huvitella itseään sirkuksessa, tansseissa ja teatterissa. Mutta
semmoiset tytöt menettävät pian terveytensä, ja jos he menevät
naimisiin, niin heistä tulee heikkoja ja kivulloisia vaimoja ja heidän
lapsensa ovat sairaalloisia tai kuolevat ensimäisellä ikävuodellaan. Jos
tahdot koettaa syödä säännöllisesti sekä muuten elää järkevästi, niin
saat nähdä, että pian tulet vahvaksi ja terveeksi, että teet työtä
ilolla ja innolla sekä tunnet olevasi nuori ja reipas. Minä tunnen tuon
tehtaan, jossa teet työtä. Mutta missä sinä asut?"

"Minä asun leipuri Koskelinilla Nivalan Leenan kanssa."

"Hyvä. Leipuri ja hänen vaimonsa ovat hyvää ja kunnollista väkeä ja
Nivalan Leena on kelpo tyttö. On hauskaa kuulla, että olet joutunut
hyvään seuraan."

"Olisiko rouva niin hyvä ja neuvoisi, mitä minun pitää tehdä", sanoi
Miina ujosti. "Kyllä Nivalan Leena suostuu siihen, että me laitamme
ruokaa."

"Mielelläni tahdon sen tehdä", sanoi papinrouva ystävällisesti.

"*Puhutaan nyt ensin ruuasta.*

*Kahvia* sinun ei pidä juoda enempää, kuin kerta tai kahdesti päivässä.

Seulomattomista jauhoista leivottu *ruis-* ja *hiivaleipä* on
ravitsevampaa kuin seulotuista jauhoista laitettu leipä.

*Vehnäleipää* voit syödä kahvia juodessasi.

*Maito* ja maitoruoka on terveellistä.

*Lihaa*, tuoretta, suolattua tai savustettua, voit kyllä joskus hankkia
itsellesi.

*Silli* ja *suolattu silakka* antaa ruokahalua, kun on kauan tehnyt
työtä sisällä.

*Perunoita* olet tottunut syömään jo lapsuudesta asti. Niistä voit
laittaa perunapuuroa, muhennusta, voit keittää ne kokonaisina tahi
paistaa tuhassa.

Isä laittaa sinulle vähän pienemmän, mutta muuten samanlaisen
heinälaatikon kuin täällä kotonakin on. Sitä paitsi täytyy sinun hankkia
tulikivi, jonka panet kamarisi uuniin. Kun talvella lämmität uunia,
tulee tulikivi tulikuumaksi. Silloin panet läkkilaatikkoon perunakeittoa
tahi manna- tai tattaripuuroa, jonka sitä ennen olet kiehauttanut,
suljet pellit ja menet työhösi. Kun tulet kotiin, on ruoka valmista,
sillä tulikivi pysyy lämpimänä monta tuntia.

Jos tahdot keittää heinälaatikossa, niin keität ensin veden tai maidon
ja ryynit kamarisi uunissa tahi, jos leipurinväki sallii, niin keität
heidän hellallaan. Kun puuro tai velli kiivaasti kiehuu, pistät padan
heinälaatikkoon. Mutta padan päälle täytyy panna tiukasti sopiva kansi
ja tämän päälle täytyy vielä asettaa heinätyyny. Laatikon kansi
suljetaan säpillä. Ja sitten voit mennä työhösi. Ruoka ei pala pohjaan,
sitä ei tarvitse hämmentää, siihen ei tarvitse lisätä mitään. Se on
valmista, kun tulet kotiin,"

"Mitähän Leena sanoo!" huudahti Miina hämmästyneenä.

"Voit myöskin laittaa lihamuhennusta", jatkoi rouva, "mutta liha täytyy
leikata pieniksi palasiksi. Perunat kuoritaan, leikataan palasiksi,
pannaan pataan samalla kuin lihapalat, vesi, suola ja vähän
vehnäjauhoja. Kun muhennus hyvästi kiehuu, nostat sen tulelta, pistät
heinälaatikkoon ja annat sen hautua siellä, kunnes tulet kotiin. Jos
olet keittänyt maitoruokaa, voit ensin syödä suolaista lihaa tai kalaa
ja leipää; jos olet laittanut lihamuhennusta, saatat juoda kaljaa tai
maitoa päälle.

Jos kerran tai kahdesti päivässä syö keittoruokaa, saattaa hyvästi
tyytyä maitoon ja leipään tai kahviin ja leipään aamulla.

Tämä olkoon sanottu ruuasta.

*Tärkeä asia on raitis ilma.* Ne, jotka tekevät työtä tehtaassa tahi
muuten sisässä, eivät ole niin onnellisessa asemassa kuin maatyöntekijät
ja maalaispalvelijat, joiden työ parhaasta päästä tapahtuu raittiissa
ilmassa ja on sitä paitsi vaihtelevaa. Siksi on erittäin tärkeätä, että
työntekijät järjestävät vapaa-aikansa -- -- --"

"Neljätoista tuntia", mutisi Antti katsahtaen merkitsevästi Miinaan.

-- -- -- "vapaa-aikansa niin, että heidän keuhkonsa saavat sitä, mitä
niiltä työhuoneessa puuttuu. Onnellista on, jos tehdas on maalla, sillä
maalla tarvitsee vain avata huoneensa ikkunan, niin raitis ilma virtaa
sisään. Maalla eivät puut ole kalliit. Maalla on vuokra halvempi kuin
kaupungeissa. Ikkuna avataan aamulla niin, että makuuvaatteet voi
tuulettaa yön jälkeen, keskipäivällä, jotta ruuanhaju menee ulos, sekä
illalla juuri ennen maatapanoa, koska uni sitten on terveellisempää ja
rauhallisempaa.

*Ruumiinliikunto* on hyvin tärkeätä niille, joitten työ on
yksitoikkoista. Kulkiessasi tehtaaseen ja sieltä kotiin, et saa kylliksi
liikuntoa, jollei matka ole kovin pitkä, vaan pitää sinun sitä paitsi
vielä kävellä ulko-ilmassa..."

"Ne kävelevät sulhasensa kanssa", huusi Tiina innokkaasti.

"Ole hiljaa, tyttö!" virkkoi Miina hämillään kaikkien muiden
sydämellisesti nauraessa.

"No niin", sanoi papinrouva hyväntahtoisesti, "voivathan he kävellä
sulhasensa kanssa, jos heillä kerran on sulhanen. Luulisi, ettei se,
joka on seisonut koko päivän, enää jaksa kävellä, mutta kyllä sitä
jaksaa, kun ensin on istunut ja levännyt vähän aikaa tahi loikonut
pitkänään.

*Vähän voimistelua* tarvittaisiin joka päivä, mutta sen pitää tapahtua
ulkona tai hyvin tuuletetussa huoneessa.

*Puhtaus on ylen tärkeä seikka.* Ei ole tarpeeksi, että kerran viikossa
menee saunaan. Sen, joka tekee työtä tomuisessa tehtaassa tai
työhuoneessa, pitää joka ilta pestä kasvonsa, kaulansa, kätensä,
käsivartensa, kainalonsa ja jalkansa lämpimällä vedellä ja saippualla.
Virkistävää ja terveellistä on joka aamu äkkiä pyyhkäistä koko ruumiinsa
semmoiseen veteen kastetulla käsiliinalla, joka on ollut yön
tavallisessa huoneen lämpimässä. On luonnollista, että usein täytyy
vaihtaa alusvaatteita, mutta senkin voi tehdä, jos hankkii itselleen
vain yksinkertaisia, mutta lujia ja hyviä liinavaatteita. Reipas tyttö
pesee vikkelästi paidan ja sukkaparin, varsinkin jos asuu aivan kosken
partaalla."

"Sitten on vielä yksi seikka", jatkoi papinrouva vakavasti. "Nuori tyttö
tahtoo mielellään huvitella. Sehän on luonnollista, eihän sitä muuten
jaksa tehdä työtä päivästä päivään ja viikosta viikkoon.

*Mutta täytyy valita huvituksensa samoinkuin ystävänsäkin.* Ei pidä
ruveta ystäväksi huonon, epäsiveellisen tytön, eikä kevytmielisen,
viinaan menevän miehen kanssa. Sitten ei myöskään pidä käydä huonoissa
tansseissa, ei käyttää väkeviä juomia, ei laulaa rumia lauluja, ei lukea
huonoja kirjoja, eikä ottaa osaa raakoihin huvituksiin. Hyvä tyttö
valitsee ystävikseen sellaisia henkilöitä, jotka vaikuttavat häneen
niin, että hänestä tulee *hyvä*, *iloinen* ja *tyytyväinen* ihminen. Hän
valitsee semmoisia huveja, jotka *jalostuttavat häntä* ja *vaikuttavat
siten, että hän aamuisin tuntee itsensä virkistyneeksi ja valmiiksi
hyvällä mielin ja uusin voimin taas alkamaan työtänsä*.

On olemassa tuhansia nuoria tyttöjä, jotka ovat yksin maailmalla ilman
suojaa ja ilman hyvää perustusta. Heillä ei koskaan ole ollut hyvää
kotia, heillä ei ole ollut isää eikä äitiä, jotka olisivat opettaneet ja
neuvoneet heitä. Ei kukaan pidä huolta heistä, ei kukaan ohjaa heitä, ei
kukaan varoita heitä. Siksi ei ole ihmeellistä, että niin monet nuoret
tytöt tulevat sairaiksi, lankeevat syntiin tahi perustavat onnettomia,
köyhiä koteja ja kuolevat suruun ja kurjuuteen.

Sinä, Miina, olet kahdeksannentoista ikävuoteesi asti saanut kasvaa
hyvässä kodissa, jossa olet oppinut rukoilemaan ja tekemään työtä. Sinun
pitää nyt olla hyvänä esimerkkinä tuolla tehtaassa. Sinun ja Nivalan
Leenan pitää tehdä kotinne puhtaaksi ja terveelliseksi, teidän pitää
laittaa itsellenne säännöllinen pieni talous. Ja sitten kun huomaatte,
että kaikki käy hyvin, niin pitää sinun puhua muutamien muiden
ymmärtäväisen tyttöjen kanssa ja näyttää heille teidän kotinne ja
ruuanlaittonne ja kehoittaa heitä seuraamaan teidän esimerkkiänne. Siten
saatte ehkä monen muuttamaan elämänsä ja saavuttamaan jälleen
terveytensä.

Lauletaan nyt virsi ja sitten minun täytyy mennä kotiin."

       *       *       *       *       *

Ensimäiset päivät, jolloin Miina taas teki työtä tehtaassa, tuntuivat
pitkiltä ja ikäviltä ja, kun hän iltaisin istui pienessä kamarissaan
Leenan kanssa, itki hän ja ajatteli kaipauksella kotia, vanhempia ja
siskoja. Mutta sitten hän muisti papinrouvan sanat ja rupesi kertomaan
Leenalle heinälaatikosta, raittiista ilmasta ja muista hyödyllisistä
asioista. Ensiksi tytöt hankkivat tulikiven uuniinsa. He lainasivat
leipurin vaimolta, läkkilaatikon, sitten he kiehauttivat maitoa ja
mannaryyniä pienessä padassa, voitelivat läkkilaatikon pohjan voilla,
kaasivat puuron siihen, asettivat sen uuniin kuumalle tiilikivelle ja
sulkivat pellit. Kun he tulivat päivälliseksi kotiin, oli puuro valmis.
Hyvällä halulla he söivät sen ja olivat sekä ravitut että tyytyväiset.
Kun he saivat heinälaatikon, ei Leena tahtonut uskoa, että keittäminen
siinä onnistuisi. He laittoivat siinä puuroa ensi kerran eräänä
sunnuntaina. Sillä aikaa kun he olivat kirkossa, kypsyi puuro, ja Leenan
suureksi ihmeeksi oli se todellakin valmista. Kolme heidän tuttavataan
tyttöä oli seurannut heitä kirkosta leipurin taloon ja he saivat myöskin
maistaa puuroa. Kulovalkean tavoin levisi koko tehtaaseen tieto siitä,
että Tervolan Miina keitti puuroa heinälaatikossa. Leipurin vaimo oli
ensimäinen, joka laitatti itselleen heinälaatikon. Hänellä oli monta
pientä lasta, hän auttoi miestään leipomisessa, sitä paitsi hänellä oli
kaksi lehmää, porsas ja perunamaa, ja hän oli aina kiinni työssä.
Heinälaatikosta oli hänelle suunnaton apu, sillä nyt ei hänen enää
tarvinnut seistä velliä hämmentämässä.

Kun heinälaatikolla oli niin hyvä menestys, rupesi Miina vähitellen
kertomaan toisille myöskin raittiista ilmasta, ruumiinliikunnosta,
puhtaudesta ja järkevistä, hyvistä huveista. Tosin tapahtui usein, että
molemmille tytöille naurettiin, monet olivat tietysti liian laiskat
laittaakseen ruokaa, ja monet tahtoivat mieluummin koreita vaatteita
kuin kelvollista ravintoa, mutta suuri joukko nuoria tyttöjä sai halun
koettaa ja he seurasivat monessa asiassa Miinan ja Leenan esimerkkiä.
Viisitoista tyttöä oli myöskin muodostanut pienen yhdistyksen. He
kokoontuivat lauantai-iltaisin ja päättivät lukea ääneen hyviä kirjoja.
He lukivat Terveydenhoitolehteä, Koti ja Yhteiskuntaa, raittiuskirjasia
ja hyviä kertomuskirjoja. Kaikki nämät olivat olemassa tehtaan
lukusalissa. Sitä paitsi siellä oli laulukirjoja, ja Leena, joka oli
oikea laululintunen, opetti muille monta kaunista laulua.

       *       *       *       *       *

Miina oli todellakin tullut terveeksi ja punaposkiseksi, mutta hän ei
kuitenkaan viihtynyt tehtaassa. Vihdoin hän eräänä kevätpäivänä tuli
kotiin Tervolaan ja sanoi, että jos isä ja äiti antaisivat hänen jäädä
kotiin, niin tekisi hän mielellään kauemminkin työtä kuin tehtaassa, kun
hän vain saisi lypsää lehmiä, haravoida, panna perunoita ja leikata
viljaa. Se olisi sittenkin hauskempaa, kuin koko päivän seistä
tomuisessa tehtaassa.

"Saathan toki jäädä", sanoi äiti iloisena. "Työtä on kesällä kylliksi.
Ja talvisin emme ehdi kutoa niin paljon, kuin muut haluavat meiltä ostaa
käsiliina-, palttina- ja puolivillaista kangasta."

Voi, miten iloisena Miina seuraavana aamuna hameet ylöskäärittyinä
levitteli pellolla lantaa! Käki kukkui ja koivut tuoksuivat, Matti
vihelteli iloista laulua ja isä kynti vähän matkan päässä. Kumaraksi ja
vanhaksi ukko oli käynyt, mutta hän oli tyytyväisen näköinen, kun hän
piippuaan täyttäessään antoi hevosen hetkeksi levätä ja katseli, miten
reippaasti hänen vanhin tyttärensä piteli tadikkoa.

"Kai ne kaupungin kadut sopivat kaupungin lapsille, jotka eivät ole
nähneet mitään parempaa", sanoi Miina Matille, "mutta kun on kasvanut
maalla, niin näyttävät koivut paremmilta kuin tehtaanpiiput ja
käenkukunta kuuluu kauniimmalta kuin höyrypillin vihellys."

       *       *       *       *       *

Tervolan naapuritorpan isäntänä oli jo pari vuotta ollut eräs nuori
mies, Salmelan Lauri. Hän oli välistä ollut Tervolassa talkoossa, ja
Tervolan väki oli ollut hänen luonaan talkoossa. Hän oli raivannut
itselleen aivan samanlaisen puutarhan, kuin Tervolassakin oli, ja oli
saanut Annalta ohjeita ja neuvoja. Taloutta hoiti hänen sisarensa,
reipas ja iloinen tyttö, josta heti tuli Tervolan tyttöjen hyvä ystävä.
Mutta syksyllä sisar aikoi mennä naimisiin, ja silloin Lauri rupesi
ajattelemaan, että hänenkin täytyi hankkia itselleen vaimo. Nähdessään
Miinan liikkuvan niin reippaana ja iloisena työssään, arveli hän, että
siinähän oli tyttö häntä varten.

Ja elonkorjuun jälkeen tulivat kuuliaiset ja häät.

"Kas tuota", sanoi Antti istuessaan tupansa nurkassa rakas piippunysä
käsissään, "talollisen poika ei kelvannut, vaan torppari se hänelle
kelpasi."

"Torppari on kelpo mies", sanoi Anna.

"Niin on, ja Miina on viisas tyttö, Lintulan talo ränstyy minkä
ennättää, mutta Salmelan torppa vaurastuu niin, että sitä ilokseen
katselee."

"Ja me hankimme puutarhan ja kanoja ja kaikkea, mitä Tervolassakin on",
sanoi Miina.

       *       *       *       *       *

Kun Pekka oli täyttänyt 21 vuotta, otti hän haltuunsa yhden pappilan
muista torpista. Ja hän, joka lapsena oli leikkirattaillaan vetänyt
hiekkaa Tervolan puutarhaan, alkoi heti järjestykseen päästyään raivata
itselleen puutarhaa. Liisa meni häntä auttamaan, kun hän vain
hetkeksikään pääsi Tervolasta. Ja kun Pekka meni naimisiin, neuvoi ja
opasti Liisa kälyään, sillä Anna alkoi käydä vanhaksi ja askaroitsi
mieluimmin sisällä.

Papinrouvana oli paljon iloa uusista pikku kodeista. Hän iloitsi
sydämestään, kun pikku Tiina toi hänelle korillisen punaposkisia omenia,
kun Miina lahjoitti hänelle tiun tuoreita munia, tahi kun Pekan nuori
vaimo toi hänelle kevään ensimäiset narsissit.

"Jos minä osaisin kirjoittaa kirjan," sanoi Anna kerran papinrouvalle,
"niin kirjoittaisin, mitä hyvää rouva on tehnyt Tervolassa ja miten
rouva on opastanut meidän lapsiamme, joilla nyt on kullakin oma kotinsa;
mutta kyllähän hyvän rouvan nimi on kirjoitettu suureen kirjaan tuolla
ylhäällä taivaassa."





End of the Project Gutenberg EBook of Tehtaan tytöt, by Maria Furuhjelm

*** END OF THIS PROJECT GUTENBERG EBOOK TEHTAAN TYTÖT ***

***** This file should be named 16068-8.txt or 16068-8.zip *****
This and all associated files of various formats will be found in:
        http://www.gutenberg.org/1/6/0/6/16068/

Produced by Matti Järvinen and Tuija Lindholm.

Updated editions will replace the previous one--the old editions
will be renamed.

Creating the works from public domain print editions means that no
one owns a United States copyright in these works, so the Foundation
(and you!) can copy and distribute it in the United States without
permission and without paying copyright royalties.  Special rules,
set forth in the General Terms of Use part of this license, apply to
copying and distributing Project Gutenberg-tm electronic works to
protect the PROJECT GUTENBERG-tm concept and trademark.  Project
Gutenberg is a registered trademark, and may not be used if you
charge for the eBooks, unless you receive specific permission.  If you
do not charge anything for copies of this eBook, complying with the
rules is very easy.  You may use this eBook for nearly any purpose
such as creation of derivative works, reports, performances and
research.  They may be modified and printed and given away--you may do
practically ANYTHING with public domain eBooks.  Redistribution is
subject to the trademark license, especially commercial
redistribution.



*** START: FULL LICENSE ***

THE FULL PROJECT GUTENBERG LICENSE
PLEASE READ THIS BEFORE YOU DISTRIBUTE OR USE THIS WORK

To protect the Project Gutenberg-tm mission of promoting the free
distribution of electronic works, by using or distributing this work
(or any other work associated in any way with the phrase "Project
Gutenberg"), you agree to comply with all the terms of the Full Project
Gutenberg-tm License (available with this file or online at
http://gutenberg.net/license).


Section 1.  General Terms of Use and Redistributing Project Gutenberg-tm
electronic works

1.A.  By reading or using any part of this Project Gutenberg-tm
electronic work, you indicate that you have read, understand, agree to
and accept all the terms of this license and intellectual property
(trademark/copyright) agreement.  If you do not agree to abide by all
the terms of this agreement, you must cease using and return or destroy
all copies of Project Gutenberg-tm electronic works in your possession.
If you paid a fee for obtaining a copy of or access to a Project
Gutenberg-tm electronic work and you do not agree to be bound by the
terms of this agreement, you may obtain a refund from the person or
entity to whom you paid the fee as set forth in paragraph 1.E.8.

1.B.  "Project Gutenberg" is a registered trademark.  It may only be
used on or associated in any way with an electronic work by people who
agree to be bound by the terms of this agreement.  There are a few
things that you can do with most Project Gutenberg-tm electronic works
even without complying with the full terms of this agreement.  See
paragraph 1.C below.  There are a lot of things you can do with Project
Gutenberg-tm electronic works if you follow the terms of this agreement
and help preserve free future access to Project Gutenberg-tm electronic
works.  See paragraph 1.E below.

1.C.  The Project Gutenberg Literary Archive Foundation ("the Foundation"
or PGLAF), owns a compilation copyright in the collection of Project
Gutenberg-tm electronic works.  Nearly all the individual works in the
collection are in the public domain in the United States.  If an
individual work is in the public domain in the United States and you are
located in the United States, we do not claim a right to prevent you from
copying, distributing, performing, displaying or creating derivative
works based on the work as long as all references to Project Gutenberg
are removed.  Of course, we hope that you will support the Project
Gutenberg-tm mission of promoting free access to electronic works by
freely sharing Project Gutenberg-tm works in compliance with the terms of
this agreement for keeping the Project Gutenberg-tm name associated with
the work.  You can easily comply with the terms of this agreement by
keeping this work in the same format with its attached full Project
Gutenberg-tm License when you share it without charge with others.

1.D.  The copyright laws of the place where you are located also govern
what you can do with this work.  Copyright laws in most countries are in
a constant state of change.  If you are outside the United States, check
the laws of your country in addition to the terms of this agreement
before downloading, copying, displaying, performing, distributing or
creating derivative works based on this work or any other Project
Gutenberg-tm work.  The Foundation makes no representations concerning
the copyright status of any work in any country outside the United
States.

1.E.  Unless you have removed all references to Project Gutenberg:

1.E.1.  The following sentence, with active links to, or other immediate
access to, the full Project Gutenberg-tm License must appear prominently
whenever any copy of a Project Gutenberg-tm work (any work on which the
phrase "Project Gutenberg" appears, or with which the phrase "Project
Gutenberg" is associated) is accessed, displayed, performed, viewed,
copied or distributed:

This eBook is for the use of anyone anywhere at no cost and with
almost no restrictions whatsoever.  You may copy it, give it away or
re-use it under the terms of the Project Gutenberg License included
with this eBook or online at www.gutenberg.net

1.E.2.  If an individual Project Gutenberg-tm electronic work is derived
from the public domain (does not contain a notice indicating that it is
posted with permission of the copyright holder), the work can be copied
and distributed to anyone in the United States without paying any fees
or charges.  If you are redistributing or providing access to a work
with the phrase "Project Gutenberg" associated with or appearing on the
work, you must comply either with the requirements of paragraphs 1.E.1
through 1.E.7 or obtain permission for the use of the work and the
Project Gutenberg-tm trademark as set forth in paragraphs 1.E.8 or
1.E.9.

1.E.3.  If an individual Project Gutenberg-tm electronic work is posted
with the permission of the copyright holder, your use and distribution
must comply with both paragraphs 1.E.1 through 1.E.7 and any additional
terms imposed by the copyright holder.  Additional terms will be linked
to the Project Gutenberg-tm License for all works posted with the
permission of the copyright holder found at the beginning of this work.

1.E.4.  Do not unlink or detach or remove the full Project Gutenberg-tm
License terms from this work, or any files containing a part of this
work or any other work associated with Project Gutenberg-tm.

1.E.5.  Do not copy, display, perform, distribute or redistribute this
electronic work, or any part of this electronic work, without
prominently displaying the sentence set forth in paragraph 1.E.1 with
active links or immediate access to the full terms of the Project
Gutenberg-tm License.

1.E.6.  You may convert to and distribute this work in any binary,
compressed, marked up, nonproprietary or proprietary form, including any
word processing or hypertext form.  However, if you provide access to or
distribute copies of a Project Gutenberg-tm work in a format other than
"Plain Vanilla ASCII" or other format used in the official version
posted on the official Project Gutenberg-tm web site (www.gutenberg.net),
you must, at no additional cost, fee or expense to the user, provide a
copy, a means of exporting a copy, or a means of obtaining a copy upon
request, of the work in its original "Plain Vanilla ASCII" or other
form.  Any alternate format must include the full Project Gutenberg-tm
License as specified in paragraph 1.E.1.

1.E.7.  Do not charge a fee for access to, viewing, displaying,
performing, copying or distributing any Project Gutenberg-tm works
unless you comply with paragraph 1.E.8 or 1.E.9.

1.E.8.  You may charge a reasonable fee for copies of or providing
access to or distributing Project Gutenberg-tm electronic works provided
that

- You pay a royalty fee of 20% of the gross profits you derive from
     the use of Project Gutenberg-tm works calculated using the method
     you already use to calculate your applicable taxes.  The fee is
     owed to the owner of the Project Gutenberg-tm trademark, but he
     has agreed to donate royalties under this paragraph to the
     Project Gutenberg Literary Archive Foundation.  Royalty payments
     must be paid within 60 days following each date on which you
     prepare (or are legally required to prepare) your periodic tax
     returns.  Royalty payments should be clearly marked as such and
     sent to the Project Gutenberg Literary Archive Foundation at the
     address specified in Section 4, "Information about donations to
     the Project Gutenberg Literary Archive Foundation."

- You provide a full refund of any money paid by a user who notifies
     you in writing (or by e-mail) within 30 days of receipt that s/he
     does not agree to the terms of the full Project Gutenberg-tm
     License.  You must require such a user to return or
     destroy all copies of the works possessed in a physical medium
     and discontinue all use of and all access to other copies of
     Project Gutenberg-tm works.

- You provide, in accordance with paragraph 1.F.3, a full refund of any
     money paid for a work or a replacement copy, if a defect in the
     electronic work is discovered and reported to you within 90 days
     of receipt of the work.

- You comply with all other terms of this agreement for free
     distribution of Project Gutenberg-tm works.

1.E.9.  If you wish to charge a fee or distribute a Project Gutenberg-tm
electronic work or group of works on different terms than are set
forth in this agreement, you must obtain permission in writing from
both the Project Gutenberg Literary Archive Foundation and Michael
Hart, the owner of the Project Gutenberg-tm trademark.  Contact the
Foundation as set forth in Section 3 below.

1.F.

1.F.1.  Project Gutenberg volunteers and employees expend considerable
effort to identify, do copyright research on, transcribe and proofread
public domain works in creating the Project Gutenberg-tm
collection.  Despite these efforts, Project Gutenberg-tm electronic
works, and the medium on which they may be stored, may contain
"Defects," such as, but not limited to, incomplete, inaccurate or
corrupt data, transcription errors, a copyright or other intellectual
property infringement, a defective or damaged disk or other medium, a
computer virus, or computer codes that damage or cannot be read by
your equipment.

1.F.2.  LIMITED WARRANTY, DISCLAIMER OF DAMAGES - Except for the "Right
of Replacement or Refund" described in paragraph 1.F.3, the Project
Gutenberg Literary Archive Foundation, the owner of the Project
Gutenberg-tm trademark, and any other party distributing a Project
Gutenberg-tm electronic work under this agreement, disclaim all
liability to you for damages, costs and expenses, including legal
fees.  YOU AGREE THAT YOU HAVE NO REMEDIES FOR NEGLIGENCE, STRICT
LIABILITY, BREACH OF WARRANTY OR BREACH OF CONTRACT EXCEPT THOSE
PROVIDED IN PARAGRAPH F3.  YOU AGREE THAT THE FOUNDATION, THE
TRADEMARK OWNER, AND ANY DISTRIBUTOR UNDER THIS AGREEMENT WILL NOT BE
LIABLE TO YOU FOR ACTUAL, DIRECT, INDIRECT, CONSEQUENTIAL, PUNITIVE OR
INCIDENTAL DAMAGES EVEN IF YOU GIVE NOTICE OF THE POSSIBILITY OF SUCH
DAMAGE.

1.F.3.  LIMITED RIGHT OF REPLACEMENT OR REFUND - If you discover a
defect in this electronic work within 90 days of receiving it, you can
receive a refund of the money (if any) you paid for it by sending a
written explanation to the person you received the work from.  If you
received the work on a physical medium, you must return the medium with
your written explanation.  The person or entity that provided you with
the defective work may elect to provide a replacement copy in lieu of a
refund.  If you received the work electronically, the person or entity
providing it to you may choose to give you a second opportunity to
receive the work electronically in lieu of a refund.  If the second copy
is also defective, you may demand a refund in writing without further
opportunities to fix the problem.

1.F.4.  Except for the limited right of replacement or refund set forth
in paragraph 1.F.3, this work is provided to you 'AS-IS' WITH NO OTHER
WARRANTIES OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO
WARRANTIES OF MERCHANTIBILITY OR FITNESS FOR ANY PURPOSE.

1.F.5.  Some states do not allow disclaimers of certain implied
warranties or the exclusion or limitation of certain types of damages.
If any disclaimer or limitation set forth in this agreement violates the
law of the state applicable to this agreement, the agreement shall be
interpreted to make the maximum disclaimer or limitation permitted by
the applicable state law.  The invalidity or unenforceability of any
provision of this agreement shall not void the remaining provisions.

1.F.6.  INDEMNITY - You agree to indemnify and hold the Foundation, the
trademark owner, any agent or employee of the Foundation, anyone
providing copies of Project Gutenberg-tm electronic works in accordance
with this agreement, and any volunteers associated with the production,
promotion and distribution of Project Gutenberg-tm electronic works,
harmless from all liability, costs and expenses, including legal fees,
that arise directly or indirectly from any of the following which you do
or cause to occur: (a) distribution of this or any Project Gutenberg-tm
work, (b) alteration, modification, or additions or deletions to any
Project Gutenberg-tm work, and (c) any Defect you cause.


Section  2.  Information about the Mission of Project Gutenberg-tm

Project Gutenberg-tm is synonymous with the free distribution of
electronic works in formats readable by the widest variety of computers
including obsolete, old, middle-aged and new computers.  It exists
because of the efforts of hundreds of volunteers and donations from
people in all walks of life.

Volunteers and financial support to provide volunteers with the
assistance they need, is critical to reaching Project Gutenberg-tm's
goals and ensuring that the Project Gutenberg-tm collection will
remain freely available for generations to come.  In 2001, the Project
Gutenberg Literary Archive Foundation was created to provide a secure
and permanent future for Project Gutenberg-tm and future generations.
To learn more about the Project Gutenberg Literary Archive Foundation
and how your efforts and donations can help, see Sections 3 and 4
and the Foundation web page at http://www.pglaf.org.


Section 3.  Information about the Project Gutenberg Literary Archive
Foundation

The Project Gutenberg Literary Archive Foundation is a non profit
501(c)(3) educational corporation organized under the laws of the
state of Mississippi and granted tax exempt status by the Internal
Revenue Service.  The Foundation's EIN or federal tax identification
number is 64-6221541.  Its 501(c)(3) letter is posted at
http://pglaf.org/fundraising.  Contributions to the Project Gutenberg
Literary Archive Foundation are tax deductible to the full extent
permitted by U.S. federal laws and your state's laws.

The Foundation's principal office is located at 4557 Melan Dr. S.
Fairbanks, AK, 99712., but its volunteers and employees are scattered
throughout numerous locations.  Its business office is located at
809 North 1500 West, Salt Lake City, UT 84116, (801) 596-1887, email
business@pglaf.org.  Email contact links and up to date contact
information can be found at the Foundation's web site and official
page at http://pglaf.org

For additional contact information:
     Dr. Gregory B. Newby
     Chief Executive and Director
     gbnewby@pglaf.org


Section 4.  Information about Donations to the Project Gutenberg
Literary Archive Foundation

Project Gutenberg-tm depends upon and cannot survive without wide
spread public support and donations to carry out its mission of
increasing the number of public domain and licensed works that can be
freely distributed in machine readable form accessible by the widest
array of equipment including outdated equipment.  Many small donations
($1 to $5,000) are particularly important to maintaining tax exempt
status with the IRS.

The Foundation is committed to complying with the laws regulating
charities and charitable donations in all 50 states of the United
States.  Compliance requirements are not uniform and it takes a
considerable effort, much paperwork and many fees to meet and keep up
with these requirements.  We do not solicit donations in locations
where we have not received written confirmation of compliance.  To
SEND DONATIONS or determine the status of compliance for any
particular state visit http://pglaf.org

While we cannot and do not solicit contributions from states where we
have not met the solicitation requirements, we know of no prohibition
against accepting unsolicited donations from donors in such states who
approach us with offers to donate.

International donations are gratefully accepted, but we cannot make
any statements concerning tax treatment of donations received from
outside the United States.  U.S. laws alone swamp our small staff.

Please check the Project Gutenberg Web pages for current donation
methods and addresses.  Donations are accepted in a number of other
ways including including checks, online payments and credit card
donations.  To donate, please visit: http://pglaf.org/donate


Section 5.  General Information About Project Gutenberg-tm electronic
works.

Professor Michael S. Hart is the originator of the Project Gutenberg-tm
concept of a library of electronic works that could be freely shared
with anyone.  For thirty years, he produced and distributed Project
Gutenberg-tm eBooks with only a loose network of volunteer support.


Project Gutenberg-tm eBooks are often created from several printed
editions, all of which are confirmed as Public Domain in the U.S.
unless a copyright notice is included.  Thus, we do not necessarily
keep eBooks in compliance with any particular paper edition.


Most people start at our Web site which has the main PG search facility:

     http://www.gutenberg.net

This Web site includes information about Project Gutenberg-tm,
including how to make donations to the Project Gutenberg Literary
Archive Foundation, how to help produce our new eBooks, and how to
subscribe to our email newsletter to hear about new eBooks.

$,=42;for(34,0,-3,9,-11,11,-17,7,-5){$*.=pack'c'=>$,+=$_}for(reverse split//=>$*
){$%++?$ %%2?push@C,$_,$":push@c,$_,$":(push@C,$_,$")&&push@c,$"}$C[$#C]=$/;($#C
>$#c)?($ c=\@C)&&($ C=\@c):($ c=\@c)&&($C=\@C);$%=$|;for(@$c){print$_^$$C[$%++]}
-p $_=1+$_.$/for@;[9-$_..8]}{print@
-ln0 ($~+=s~$=~~g)&&print$~while--$=
-ln0 $~+=s~$=~~gand print$~while--$=
-p $_=++$_.$/for@a[9-$_..8]}for(@a){
-n $_=++$_.$/for@a[9-$_..8]}{print@a
-ln0 ($,+=s/$=//g)&&print$,while--$=
-pl $_++for@s[1..$_]}while($_=pop@s){
-lp $_++for@_[1..$_]}while($_=pop@_){
-pl ++$_[--$_]while$_}for(reverse@_){
-pl $_++for@_[1..$_]}while($_=pop@_){
-n map$_=++$_.$/,@p[9-$_..8]}{print@p
-nl ++$$[--$_]}{map{print$t+=pop@$}@$
-ln0 /$=/?print s//$=-1/eg:3while--$=
-p $x[--$_]++while$_}{$\=$_.$/.$\for@x
-p $k[--$_]++while$_}{$\=~s//$_\n/for@k
-nl $_[9-$_]++for 1..$_}{$_&&print for@_
-p $d[$_-1]++for 1..$_}{$\=$_.$/.$\for@d
-l map++$o[$_-1],<>;map{print$o+=pop@o}@o
-nl ++$o[$_-1];END{map{print$o+=pop@o}@o}
-l map{++$a[--$_]}<>;map{print$o+=pop@a}@a
-ln $_[$_]++while$_--}{map{print}reverse@_
-nl ++$o[9-$_--]while$_;END{map$_&&print,@o}
-p $z.=a.1x$_}{$_="$a\n$_"while$a=$z=~s/a1/a/g
-ln $a[$_]++while$_--;END{print for+reverse@a}
$x[$_]++for map{1..$_}<>;print join$/,reverse@x
-nl $i=0;$a[$i++]++for 1..$_}{print for reverse@a
-n END{print join"\n",reverse@a}$a[$_]++for(1..$_)
map{for(1..$_){$a[$_]++}}<>;print join"\n",reverse@a
for(;<>=~/\d+/;){for(@a[1..$&]){$_++}}print join("\n",reverse@a)
sub x{$_=shift;$v="";while($_){if(/^(\D*)/){$v.=$&;$_=$'}if(/^(\d+)/){$v.=sprintf("%09d",$&),$_=$'}};$v}map{print}sort{x($a)cmp x($b)}<>;
sub K($$){@a=@_;$*=ord((sort+map{chr(length)}"@_"=~/\d+/g)[-1]);s/\d+/sprintf"%0$*s",$&/eg for@a;$a[0]cmp$a[1]}print+sort K<>
-n $c++;$e=$_;s/(\d+)/$a=length $1;''x(9999-$a).$1/ge;$a{lc($_.$c)}=$e;}foreach $b(sort keys %a){print $a{$b};
print/([^\0]*)$/for sort map{$b=$_;lc;$_=$`.0 x(length@b-length$&)."$&\0$'"while/\d+(?!.*\0)/;"$_\0$b"}@b=<>
$c++;$e=$_;s/(\d+)/$a=length $1;' 'x(99-$a).$1/ge;$a{lc($_.$c)}=$e;}foreach$b(sort keys %a){print $a{$b};
sub K($$){@a=@_;$*=length"@_";s/\d+/sprintf"%0$*s",$&/eg for@a;$a[0]cmp$a[1]}print+sort K<>
$;|=y===cfor@f=<>;sub f{$_=lc$_[0];s/\d+/sprintf"%$;s",$&/eg;$_}print+sort{f($a)cmp f$b}@f
sub f{$_=pop;s/\d+/$a=$&+0;pack("N",length$a)."-$a"/eg;$_}print sort{f($a)cmp f $b}<>
print+sort{@_=($a,$b);$*=length"@_";s/\d+/sprintf"%0$*s",$&/eg for@_;$_[0]cmp$_[1]}<>
print+sort{s|\d+|0 x(length($a.$b)-length$&).$&|eg,for@_=($a,$b);$_[0]cmp$_[1]}<>
print sort{($$_=lc${lc$_})=~s/\d+|$/$"x(1e4-length$&).$&/ge for A,B;$A cmp$B}<>
($a=uc)=~s/\d+/$|x($=-length$&).$&/eg,s/^/$a/for@l=<>;s/.*\n//,print for sort@l
print+sort{s|\d+|0 x(2**07-length$&).$&|eg,for@_=map{lc}$a,$b;$_[0]cmp$_[1]}<>
print sort{($$_=lc${lc$_})=~s/\d+|$/$"x(99-length$&).$&/ge for A,B;$A cmp$B}<>
print/(.*\n)$/for sort map{$x=$_;s#\d+#'0'.pack'w/a*',$&+0#eg;"\U$_\E\n$x"}<>
print map/\n(.+)/s,sort map{($a=lc)=~s/\d+/$[.chr(length$&).$&/eg;"$a$_"}<>
sub Z{$_=pop;s/\d+/0 .pack(N,length$&).$&/eg;uc}print sort{Z($a)cmp Z$b}<>
-n $a=$_;s/\d+/sprintf"%099s",$&/ge;$b{$:.uc}.=$a}{print map{$b{$_}}sort%b
b"=~/^(.*\D)?(\d+).*\n\1(\d+)/i&&$2<=>$3||lc$a cmp lc$b}<>
or sort map{$x=$_;s#\d+|\n#pack'xN/a*',$&#eg;"\U$_\E$x"}<>
ort{s|\d+|0 x(2**07-length$&).$&|eg,for@_=($a,$b);$_[0]cmp$_[1]}<>
/\d+/0 .pack(N,length$&).$&/eg;uc}print sort{Z($_=$a)cmp Z$_=$b}<>
|\d+|0 x(2**07-length$&).$&|eg;lc}print+sort{_($_=$a)cmp _$_=$b}<>
b"=~/^(.*\D)?(\d+).*\n\1(\d+)/i;$2<=>$3||lc$a cmp lc$b}<>
or sort map{$x=$_;s#\d+|\n#pack'N/a*',$&#eg;"\U$_\E$x"}<>
ap/\n(.+)/s,sort map{($a=lc)=~s/\d+/0${\chr length$&}$&/g;$a.$_}<>
_=pop;s/(\d+)/sprintf"%.99d",$1/eg;uc}print sort{Z($a)cmp Z$b}<>
 sub a{$_=pop;s#\d+#0 .pack'N/A*',$&#ge;lc$_}print sort{a($a)cmp a$b}<>
b"=~/^(.*)(\d+).*\n\1(\d+)/i&&$2<=>$3||lc$a cmp lc$b}<>
/\d+/0 .pack(N,$+[0]).$&/eg;uc}print sort{Z($_=$a)cmp Z$_=$b}<>
b"=~/^(.*)(\d+).*\n\1(\d+)/?$2<=>$3:$a cmp$b}map lc,<>
/\d+/(':'x length$&).$&/eg;uc}print sort{Z($_=$a)cmp Z$_=$b}<>
b"=~/^(.*)(\d+).*\n\1(\d+)/i&&$2-$3||lc$a cmp lc$b}<>
b"=~/^(.*)(\d+)(.*)\n\1(\d+)\3$/i?$2<=>$4:$a cmp$b}<>
 sub a{$_=pop;s#\d+#0 .pack'N/A*',$&#ge;lc}print sort{a($a)cmp a$b}<>
 sub a{$_=pop;s#\d+#_ x(length$&).$&#ge;lc}print sort{a($a)cmp a$b}<>
r sort map{$x=$_;s#\d+|\n#pack'xN/a*',$&#eg;lc().$x}<>
/\d+/0 .(A x$+[0]).$&/eg;uc}print sort{Z($_=$a)cmp Z$_=$b}<>
 sub a{$_=lc pop;s#\d+#A x$+[0].$&#ge;$_}print sort{a($a)cmp a$b}<>
\d+;~0/3+$+[0].$&;eg;lc}print+sort{f($a)cmp+f$b}<>
 sub a{$_=pop;s#\d+#8x$+[0].$/.$&#ge;lc}print sort{a($a)cmp a$b}<>
/\d+/0 .A x$+[0].$&/eg;uc}print sort{Z($_=$a)cmp Z$_=$b}<>
_=pop;s/\d+/length($&).$&/eg;uc}print sort{Z($a)cmp Z$b}<>
_;s/\d+/sprintf"%99s",$&/ge;$b{$:.uc}.=$a}{print@b{sort%b}
_;s!|\d+!pack'AN/Z*',0,$&!eg;$;{lc,}.=$k}for(@;{sort%;}){
/\d+/': 'x$+[0].$&/eg;uc}print sort{Z($_=$a)cmp Z$_=$b}<>
/\d+/':0'x$+[0].$&/eg;uc}print sort{Z($_=$a)cmp Z$_=$b}<>
 sub a{$_=lc pop;s#\d+#0 x$&.$/#ge;$_}print sort{a($a)cmp a$b}<>
/\d+/':'x$+[0].$&/eg;uc}print sort{Z($_=$a)cmp Z$_=$b}<>
\d+!pack'AN/Z*',0,$&!eg;$;{lc,}.="@F\n"}for(@;{sort%;}){
_=shift;s/\d+/chr$&/g;$_}print+sort{_($a)cmp _ $b}<>
 print sort{"$a$b"=~('(\D+)(\d*)\n'x 2);$1cmp$3||$2<=>$4}<>
{$r=0;$j=$a;$k=$b;$d=$j=~/\d/?1:0;until($r){$u=$v=1;$e=$d?'\d':'[a-z]';($p,$q)=map{s/^($e+)//i?lc$1:''}$j,$k;($x,$y)=map/\w/?0:1,$j,$k;if($p&&$q){if($d){($h,$i)=map{length}$p,$q;;if(!($r=($h<=>$i))){($u,$v)=map{s/(.)//?$1:''}$p,$q until($u==''||($r=$u<=>$v))}}$r=($p cmp$q)if!$d}else{$r=$p?1:-1;$r=!$r if$d}$r||($y&&$r++)||$x&&$r--;$d=$d?0:1}$r}<>
{chop($j=$a);chop($k=$b);do{$e=($d=$j=~/^\d/)?'\d':'[a-z]';($p,$q)=map{s/^($e+)//i?lc$1:''}$j,$k;if($p&&$q){if($d&&!($r=length$p<=>length$q)){do{($u,$v)=map{s/(.)//?$1:''}$p,$q}until($u==''||($r=$u<=>$v))}$r=($p cmp$q)if!$d}else{$r=$p?1:-1;$r=!$r if$d}$r||(!$k&&$r++)||!$j&&$r--}until($r)}<>
;print sort{g($a,$b)}<>;sub g{my($j,$k,$z,$x)=@_;for($j,$k){my@c;{$e=/^\d/?'\d':$w;$p=$z?'':'+';s/($e$p)//i;push@c,lc$1;$1ne''&&redo}$_=+\@c}for(@$j){$v=$$k[$x++];last if$r=/\d/?$z?$_<=>$v:g($_,$v,1):$_ cmp$v}if($z){$r=($s=@$j<=>@$k)?$s:$r;$r=(grep/$w/,@$k)?-1:$r}$r}
;print sort{g($a,$b)}<>;sub g{my($j,$k,$z,$x)=@_;for($j,$k){my@c;{$e=/^\d/?'\d':$w;$p=$z?'':'+';s/($e$p)//i;push@c,lc$1;$1ne''&&redo}$_=\@c}for(@$j){$v=$$k[$x++];last if$r=/\d/?$z?$_<=>$v:g($_,$v,1):$_ cmp$v}if($z){$r=($s=@$j<=>@$k)?$s:$r;$r=(grep/$w/,@$k)?-1:$r}$r}
{$u=uc$a;$v=uc$b;@x=$u=~/\d+|\D+/g;@y=$v=~/\d+|\D+/g;return$u cmp$v if@x<2||@y<2or$x[0]=~/\d/^$y[0]=~/\d/;for(0..(@x<@y?@x:@y)){$c=$x[$_];$d=$y[$_];$i=length$c;$j=length$d;return$i<=>$j if$c=~/\d/&&$i!=$j;return$c cmp$d if$c ne$d}@x<=>@y}<>
{my@z;($;=$a)=~s/\d+/push@z,$&;1/eg;$_=$b;s/\d+/1-(length($*=shift@z)<=>length$&||$*cmp$&)/eg;lc$;cmp+lc}<>
~/^((.*\D)?)(\d+).*\n\1(\d+)/i&&length$3<=>length$4||lc$a cmp lc$b}<>
~/^(.*)(\d+).*\n\1(\d+)/i&&length$2<=>length$3||lc$a cmp lc$b}<>
{($a.$b)=~/(.*)(\d+).*\n\1(\d+)/i&&length$2<=>length$3||uc$a cmp uc$b}<>
op;s/\d+/sprintf("%010d",length$&).$&/eg;uc}print sort{Z($a)cmp Z$b}<>
printf"%".length("@_")."s",$&|egfor@_=($a,$b);$_[0]cmp$_[1]}<>
b a{$_=lc pop;s#\d+#0 .pack(N,length$&).$&#ge;$_}print sort{a($a)cmp a$b}<>
int sort{s/\d+/sprintf"%9d$&",length$&/egfor($",$;)=(uc$a,uc$b);$"cmp$;}<>
 x length("$@").$&|egfor@_=($a,lc$b);lc$_[0]cmp$_[1]}<>
\n(.+)/s,sort map{($a=lc)=~s|\d+|0${\pack'N/a*',$&}$&|g;$a.$_}<>
+/0 .(':'x length$&).$&/eg;uc}print sort{Z($_=$a)cmp Z$_=$b}<>
b a{$_=lc pop;s#\d+#0 .pack'N/A*',$&#ge;$_}print sort{a($a)cmp a$b}<>
+/0 .(A x length$&).$&/eg;uc}print sort{Z($_=$a)cmp Z$_=$b}<>
sort map{($x=lc)=~s#\d+|\n#pack'xN/a*',$&#eg;$x.$_}<>
op;s/\d+/(1e9+length$&).$&/ge;lc}print sort{t($a)cmp t$b}<>
_=lc;s!|\d+!pack'AN/Z*',0,$&!eg;$;{$_}.=$k}for(@;{sort%;}){
int sort{s!\d+!pack'AN/A*',0,$&!egfor($",$;)=(uc$a,uc$b);$"cmp$;}<>
=~s!|\d+!pack'AN/A*',0,$&!eg;$;{$*}.=$_}for(@;{sort%;}){
;9 x9+$+[0].$&;eg;lc}print+sort{f($a)cmp+f$b}<>
int sort{s!\d+!pack'AN/A*',0,$&!egfor$"=uc$a,$;=uc$b;$"cmp$;}<>
sub f{$_=pop;s;\d+;1e9+$+[0].$&;eg;uc}print+sort{f($a)cmp+f$b}<>
sub f{$_=pop;s|\d+|9x9+$+[0].$&|eg;lc}print+sort{f($a)cmp+f$b}<>
sub f{s;\d+;1e9+$+[0].$&;eg;uc}print+sort{f($_=$a)cmp+f$_=$b}<>
sub f{s;\d+;$^T+$+[0].$&;eg;uc}print+sort{f($_=$a)cmp+f$_=$b}<>
print sort{s!\d+!1e9+$+[0].$&!egfor$"=uc$a,$;=uc$b;$"cmp$;}<>
print sort{s!\d+!$^T+$+[0].$&!egfor$"=uc$a,$;=uc$b;$"cmp$;}<>
-p $k=$_;s!|\d+!1e9+$+[0].$&!eg;$;{+uc}.=$k}for(@;{sort%;}){
-p $k=$_;s!|\d+!$^T+$+[0].$&!eg;$;{+uc}.=$k}for(@;{sort%;}){
-paF s!|\d+!1e9+$+[0].$&!eg;$;{+uc}.="@F\n"}for(@;{sort%;}){
-paF s!|\d+!$^T+$+[0].$&!eg;$;{+uc}.="@F\n"}for(@;{sort%;}){
-w @a=<>;for(@INC){open F,$_."/pod/perlfaq4.pod"or next;undef$/;$_=<F>;($_)=/(my\$arr.*?\})/s;s'shift'\@a's;eval;print@a} doesn't seem to pick up the right code in my perl)
@a=<>;for(@INC){open F,$_."/pod/perlfaq4.pod"or next;undef$/;$_=<F>;($_)=/(my\$arr.*?\})/s;s'shift'\@a's;eval;print@a} doesn't seem to pick up the right code in my perl)
-n $a{$..rand}=$_}{print values%a
e@_,rand@_,0,$_}{print@_
e@a,rand@a,0,$_}for(@a){
and,$_}<>;print values%C
and}=$_}{print values%_
for(values%a){
_}for(@a{%a}){
for(@a{%a}){
and}=$_}{print@_{%_}
@A=<>;while(@A){print splice @A,int rand @A,1}
int splice@a,int rand$#a+1,1 while@a
ce(@f,rand(@f),1)while@f
ile(@a){print splice@a,rand@a,1}
int splice@a,int rand@a,1while@a
ce@x,rand@x,1 while@x
int splice @x,rand@x,1while@x
ce@a,rand@a,1while@a
int splice@a,rand@a,1while@a
@a=<>;print splice@a,rand@a,1while@a
int splice@x,rand@x,1while@x
int splice@a,rand@a,1while@a
int+delete$_[rand@_]while@_
and@a,1 for@b=@a=<>
e@_,rand@_+1,0,$_}{print@_
and@,,1for@==@,=<>
print splice@a,rand@a,1for@b=@a=<>
e@a,rand@a+1,0,$_}for(@a){
e@F,rand@F+1,0,$_}for(@F){
@x,rand@x,1}@x=<>
p{splice@x,rand@x,1}@x=<>
$.,0,$_}print@,;{
-p splice@a,rand$.,0,$_}for(@a){
$.,0,$_}{print@F
e@x,rand$.,0,$_}{print@x
-n splice@_,rand$.,0,$_}{print@_
e@a,rand$.,0,$_}{print@a
e@.,rand$.,0,$_}for(@.){
@a=<>;splice@a,rand@a,1while@a>2;print@a
e@_,rand@_,0,$_}{print@_[0,1]
e@a,rand@a,0,$_}for(@a[0,1]){
int+splice@F,rand@F,1,for$,,1
-n $a{$..rand}=$_}{print+(%a)[1,3]
_}for((%a)[1,3]){
and}=$_}{print+(%_)[1,3]
for((%a)[1,3]){
=2;while($a--){print splice@a,rand@a,1}
@A=<>;for(1,2){print splice @A,int rand @A,1}
int splice@a,int rand$#a+1,1 for+1,2
print splice(@a,rand(@a=<>),1),$a[rand@a]
p{print splice@a,int rand@a,1}0,0
e@a,rand@a+1,0,$_}for(@a[0,1]){
al'print splice@x,rand@x,1;'x2
p{print+splice@_,rand@_,1}1,2
ce@x,rand@x,1 for 1,1
ce@a,rand@a,1 for 1,2
int splice@a,rand@a,1for 1..2
int splice@x,rand@x,1for 1..2
int+splice@F,rand@F,1,for$,,1
e@a,rand$.,0,$_}{print@a[0,1]
p{print splice@a,rand@a,1}1,1
@a=<>;print splice@a,rand@a,1for 1,2
ce@_,rand@_,1for+1,2
and@x,1 for[@x=<>],1
@a=<>;print splice@a,rand@a,1for a,b
int splice@x,rand@x,1for 1,2
int splice@a,rand@a,1for 1,2
@_=<>;print splice@_,rand@_,1for 0,0
and@,,1for[@,=<>],f
-p splice@a,rand$.,0,$_}{($_,$\)=@a
e@x,rand$.,0,$_}{($_,$\)=@x
-p0i(.{10}|) $Q=$_;$==rand 4,/$&$^I$=|$=$^I$&/s?$_=$Q:s/$&/$=/gwhile/[A-Z]/
-p0aF% $==rand 4,/$&(.{10}|)$=|$=(.{10}|)$&/s?($_)=@F:s/$&/$=/gwhile/[A-Z]/
-0p $${$.^=2}^=rand 4while/(.)(\C{10})?(?!\1)(.)(??{$$1!=$$3})/;s/(.)/3-$$1/ge
-p0i(.{10}|) $Q=$_;$==rand 4,/$&$^I$=|$=$^I$&/s?$=||=$_=$Q:s/$&/$=/gwhile/[A-Z]/
-n0i(.{10}|) for$n(!s/$&/$n/g..3){s#$#/\pL/?!/$&$^I$n|$n$^I$&/s&&do$0:exit print#e}
-0p s/./$&0/g;$==rand 4,s/(${1+3*$|--})./$1$=/gwhile/(.)(\d)(\C{19})?(?!\1)(.)\2/;y/A-Z//d
-n0i(.{10}|) sub f{y/0-3/1230/;/$&$^I0|0$^I$&/s||map{s/$&/0/g*/[A-Z]/?&f+&f+&f+&f:exit print}"$_"}f/./
-l print map$_=$ARGV[($.+=!--$.[$.])%2],@.=(0)x pop
-l print map$.[$!++]=$ARGV[1&($.+=!--$.[$.])],1..pop
-l print map$$[$.++]=$ARGV[--$$[$;]||++$;,$;&1],1..pop
s/.?/$ARGV[1&pos]x$&||2/ge>>9?print$_&'?'x pop,$/:do$0
print$_?$.[$!++]=$ARGV[--$.[$.]||++$.,$.%2]:$/for-pop..0
-l for$$(1..pop){$_.=$ARGV[1&grep$|<($$-=$_),/./g]}print
-l print eval'($_.=chop()x$+.$ARGV[$|--])=~/$&(.)/,'x pop
s/.?/$ARGV[1&pos]x($&||1)/geuntil/.{$ARGV[2]}/;print$&,$/
$;=pop;s/.?/$ARGV[1&pos]x($&||1)/eguntil/.{$;}/;print"$&
-l s/.?/$ARGV[1&pos]x($&||1)/eg until/.{$ARGV[2]}/;print$&
-l $_.=2while$|=s/./$ARGV[--$|]x$&/ge<999;print$_&'?'x pop
s/.?/$ARGV[1&pos]x$&||2/ge<999?do$0:print/(.{${\pop}})/,$/
s/.?/$ARGV[$|--]x($&||1)/eguntil$|=/.{$ARGV[2]}/;print"$&
map{@;[0..@;]=map{($ARGV[$|--])x$_}@;,@;;print}@;=1..pop,$/
s/.?/$ARGV[1&pos]x$&||1/eg until/(.{$ARGV[2]})./;print"$1
s/.?/$ARGV[$-[0]%2]x($&||1)/ge until/.{$ARGV[2]}/;print$&,$/
s/.|/$ARGV[(pos)%2]x$&||9/ge<999?do$0:printf"%.${\pop}s
",$_
$%[$_]=$ARGV[$"],$*||=$%[++$.],$"^=!--$*for 1..pop;print@%,$/
$_=2;{s/./$ARGV[$-[0]%2]x$&/eg;/.{$ARGV[2]}/?print"$&
-l print map{-@@+push@@,($==$ARGV[$|--])x($@[$.++]||$=)}1..pop
s/.?/$ARGV[$"++%2]x($&||1)/eg until$"=/.{$ARGV[2]}/;print$&.$/
$_[$_]=$ARGV[$|-=!--$z],$z>0or$z=$_[++$*]for 1..pop;print@_,$/
-l print map{@.=(($?=$ARGV[$|--])x($.[-1]||$?),@.);pop@.}1..pop
-l print map{(map@/=(($_)x($/[--$%]||$_),@/),@ARGV)[-$_]}1..pop
-l print map{push@@,($%=$ARGV[--$_%2])x($@=$@[$_]||$%);$@}1..pop
-li1 map{push@,,$ARGV[$^I^=!$h];($h||=$,[$m++])--}1..pop;print@,
-l print map{push@_,($n=$ARGV[$i%2])x($c=$_[$i++]||$n);$c}1..pop
-l print+map+chop($*=($.=$ARGV[1&~$_])x chop($_=$..$*).$*),1..pop
-l $_.=($d=$ARGV[$|--])x(/./g,$d)[$f++]until/.{$ARGV[2]}/;print$&
-l $_.=($k=$ARGV[$i&1])x(/./g,$k)[$i++]until/.{$ARGV[2]}/;print$&
-l print map{push@a,($%=$ARGV[$_%2])x($n=$a[$_]||$%);$n}0..-1+pop
-l $n=pop;push@_,($_)x(@_,$_)[$i++]for(@ARGV)x$n--;print@_[0..$n]
-l push@,,($.=$ARGV[$|--])x($,[$_]||$.)for@/=0..-1+pop;print@,[@/]
print+(map{push@_,($-=$ARGV[$|--])x($==$_[--$_]||$-);$=}1..pop),$/
-l push@r,($/=$ARGV[1&$i])x($s[$i++]=$r[$i]||$/)for 1..pop;print@s
-l $l=pop;push@s,($_)x($s[$i++]||$_)for(@ARGV)x$l;print@s[0..--$l]
-l $o=pop;push@_,($_)x($_[$l++]||$_)for(@ARGV)x$o--;print@_[0..$o]
push@>,($.=@ARGV[$|--])x(@>,$.)[$_]for 0..500;print@>[0..-1+pop],$/
-l $$=pop;s/.?/$ARGV[1&pos]x$&||$ARGV[0]/eg until/(.{$$})./;print$1
$_.=($,=$ARGV[$%%2])x((/./g)[$%++]||$,)until/.{$ARGV[2]}/;print$&.$/
push@$,($$=$ARGV[$|--])x($$[$_]||$$)for 0..500;$#$=-1+pop;print@$,$/
-l print map{push@_,($%=$ARGV[$/^=1])x($\xa7=$_[$_-1]||$%);$\xa7}++$/..pop
push@_,($"=$ARGV[$_&1])x($_[$_]||$")for+0..500;$#_=-1+pop;print@_,$/
push@@,($@=$ARGV[$_%2])x($@[$_]||$@)for 0..333;print@@[0..(pop)-1],$/
$_=11;s!.!$ARGV[$-[0]%2]x$&!eg,s!(.{$ARGV[2]}).*!$1
!swhile--$=;print
-l push@_,($~=$ARGV[$|--])x($_[$-++]||$~)for a..kn;print@_[0..pop()-1]
-l map{push@_,($%=$ARGV[$_%2])x($_[$_]||$%)}0..500;print@_[0..(pop)-1]
-l print map{push@v,($_)x($v[0]||$_);shift@v}map$ARGV[$_%2^1],(1..pop)
-l @.=@ARGV;$.=1,s/./$.[$.^=1]x$&/ge,$_.=$.[!$.]until/.{$.[2]}/;print$&
for$"(1..pop){/.$/;$_=($-=$ARGV[$"-1&1])x($&||$-).$_;print chop}print$/
-l $_.=($x=$ARGV[$i%2])x(/./g,$x)[$i++]while$i<500;print substr$_,0,pop
$$=pop;$.=$ARGV[$|--],$_.=$.x substr$_.$.,$*++,1while!/.{$$}/;print$&,$/
-l /.{$i}(.)/,$;=$ARGV[$i++%2],$_.=$;x($1||$;)until/.{$ARGV[2]}/;print$&
-l push@a,($ARGV[$_%2])x($a[$_]||$ARGV[$_])for 0..999;print@a[0..-1+pop]
-l $l=pop;@l=(@l,($m=$ARGV[$|--])x($l[$_]||$m))for 0..$l;print@l[0..$l-1]
push@1,($ARGV[$|--])x($1[$_]or$ARGV[$;++])for$1..332;print@1[0..-1+pop],$/
@t=@ARGV;for(1..pop){print$u=$f[$p++]||$t[$|];push@f,($t[$|--])x$u}die"\n"
-l print map{$.=~s/.//;$..=($=^=$%||=($==pop)^pop)x($&||$=-1);$&||$=}1..pop
-l $.=pop;push@*,($==$ARGV[$%%2])x($*[$%++]||$=)while$%<$.;print@*[0..$.-1]
-l substr($@.=$ARGV[$|--],-1)x=substr$@,$_,1for 0..500;print substr$@,0,pop
-l print map{$x=$a.$x;$e||=chop$x;--$e?$a:($a^=$b)^$b}2..pop,$b=pop^($a=pop)
-l push@b,($ARGV[$_%2])x($b[$_]||$ARGV[$_%2])for(0..500);print@b[0..pop()-1]
-l ($a,$b)=@ARGV;print map{push@s,($l=$_%2?$a:$b)x($s[0]||$l);shift@s}1..pop
-l until(/.{$ARGV[2]}/&&print$&){/.{$b}(.)/;$^=$ARGV[$b++%2];$_.=$^x($1||$^)}
$/=$ARGV[1-$_%2],$*.=$/x($2||$/),$*=~s/(.)(.?)/$2/,print$1for 1..pop;print'
-l map{$s.=($a=$ARGV[$_%2])x(substr($s,$_,1)||$a)}0..999;print substr$s,0,pop
-l $n=pop;@l=@a=@ARGV;$i=0until(@l=map{($a[$i++&1])x$_}@l)>$n;print@l[0..--$n]
-l --$|,push@l,map$ARGV[!$|],1..$l[$_]||$ARGV[$_]for 0..500;print@l[0..pop()-1]
@a=@ARGV;s//@a/;while($i<666){$i=0;s/./$a[$i++&1]x$&/ge}s|.{$a[2]}|print$&,$/|e
-l *,=*ARGV;($,.=$,[$|])=~s,.,,,$,.=$,[$|--]x($&-
1),$_.=$&while$,[2]>y|||c;print
-l @A=@ARGV;push@a,($A[$_%2])x($a[$_]||$A[$_%2])for 0..$A[2];print@a[0..$A[2]-
-l @A=@ARGV;$z=$A[$_%2],push@a,($z)x($a[$_]||$z)for 0..$A[2];print@a[0..$A[2]-
-l for(0..pop){@s=(@ARGV)x999;push@a,($s[$i++])x($a[$_]||$s[$_])}print@a[0..$i-
-l @K=@ARGV;for$i(0..500){for(1..$K[$i]){$K[$p++]=$ARGV[$i%2]}}print@K[0..-
-l @a=@ARGV;print map{$n=$a[$_%2];push@d,$n for 1..$d[0]||$n;shift@d;}0..$a[2]-
-l @d=@ARGV;while($d[2]--){$b[$n++]=$d[$m%2];if($i++==$b[$m]-
1){$i=0;$m++}}print@b
-l ($a,$b,$t)=@ARGV;map{push@a,($c=$|--
?$b:$a)x($a[$_]||$c)}0..$t;print@a[0..$t-1]
-l $?=pop;$_.=($"=$ARGV[$x&1])x($:=($/=(/./g)[$x++]||$")>$??$?:$/)while$?-
=$:;print
-l for(;@o<501;++$c,$|--){push@o,($ARGV[$|])x($o[$c]||$ARGV[$|])}print@o[0..-
-l $n=pop;do{/.{$i}(.)/,$b=$ARGV[$i%2],$_.=$b
x($1||$b)}while$i++<$n;print/(.{$n})/
-l @a=@ARGV;map{$/=$a[$_%2];push@d,$/for
1..$d[$_]||$/}0..$a[2];print@d[0..$a[2]-1]
-l sub x{push@t,$ARGV[$i%2];$;--}$;=pop;while($;){x;$;&&x for
2..$t[$i];$i++}print@t
-l ($s,$t,$n)=@ARGV;$_=$s.$t;$p="$t$s"x$n,s/./chop($p)x$&/eg
until/(.{$n})./;print$1
-l ($x,$y,$a)=@ARGV;push@f,($|--?$y:$x)x($f[$_]||$|*$x||$y)for
0..$a;print@f[0..$a-1]
-l ($%,$.,$=)=@ARGV;($.,$%)=($%,$.),push@.,($.)x($.[$_]||$.)for
0..$=;print@.[0..$=-1]
@a=@ARGV;push@c,($a[$e&1])x@{$e<=@c?@c:@a}[$e++]while(@c<$a[2]);print@c[0..--
$a[2]],$/
-l $==pop;push@],($_)x($-++?$-<3?$%>1?$%:$_:$][$--
1]:($%=$_))for(@ARGV)x$=;print@][0..$=-1]
-l ($/,$b)=@ARGV;for(0..999){$;=$_%2?$b:$/;$k.=$;x(substr($k,$_,1)||$;)}print
substr$k,0,pop
$l=pop;@s=@ARGV;while(@l<$l){@l=(@l,($s[$c%2])x($l[$c]||$s[$c%2]));$c++}prin
t@l[
0..--$l]
-l @x=@ARGV;$i=shift;$z.=$x[$_%2]x$i,$i=substr$z.$x[1],$_+1,1for 0..567;print
substr$z,0,pop
($a,$b,$n)=@ARGV;$b^=$k=$a;$k||($a^=$b,$k=$R[++$p]||$a),(push@R,$a),$k--
while$n--;print@R,'
-l print+map{$c--||($v=$ARGV[$|--],$c=$_<1?$v:$_-1?$s[$_-$d]:$v,$d+=--
$c);$s[$_]=$v}0..-1+pop
($a,$b,$l)=@ARGV;push@a,($_%2?$b:$a)x($_<2?$a<2*$_?$b:$a:$a[$_])for
0..$l;print@a[0..$l-1],$/
($a,$b,$c)=@ARGV;for$i(0..$c){pos=$i;/./g;$_.=($i%2?$b:$a)x($_==1?$b:$&||$a)}pr
int/(.{$c})/,$/
($a,$b,$c)=@ARGV;while(@_<$c){map{push+_,$a}1..$_[$l++]||$a;$a^=$b^=$a^=$b}p
rint@_[0..$c-1]
b:if(@b==$ARGV[2]){print@b,"
";exit}push @b,$ARGV[$i%2];$k++;$k<$b[$i]&&goto b;$k=0;$i++;goto b
($a,$b,$c)=@ARGV;for(0..$c){$s.=($_%2?$b:$a)x(substr($s,$_,1)||shift)}print
substr($s,0,$c)."
($,,$;,$")=@ARGV;$_=$,x$,;$_.=(/$,$/?$;:$,)x(substr($_,++$i,1)||$;)while$i<$
";/.{$"}/;print$&
-l ($:,$;,$%)=@ARGV;$_=$:x$:;$_.=$;
x(substr$_,++$x,1or$;),($:,$;)=($;,$:)while$%>$x;/.{$%}/;print$&
@a=@ARGV;@b="";for$i(1..$a[2]){for$j(1..($b[$i]||$a[$t])){push(@b,$a[$t])}$t
=!$t;$_.=$b[$i]}print
-l ($a,$b,$l)=@ARGV;$b+=$a;for(1..$l){$p=$a-
1;$s.=@n?($p=pop@n):$a;@n=(($a)x$p,@n);$a=$b-$a;}print$s;
($n,$s,$i)=@ARGV;$l=0;map{push@r,(@ARGV[$l])x$n;$l=$l?0:1;$n=@r[$_]?@r[$_]:$
s;}1..500;print@r[0..--$i]
-l ($.,$/,$")=@ARGV;split'',$.x$..$/;for(0..$"){$_[$%++]=$-
?$/:$.for(1..$_[$?++]);$-=1-$-}$#_=$"-1;print@_
@k=@ARGV;for(0..pop){splice(@k,$o,$k[$i],($x=shift)x$k[$i]),$o+=$k[$i++],pus
h@ARGV,$x}print @k[0..$i-2]
($a,$b,$c)=@ARGV;for$d(0..$c){push@e,$a;$f=$e[$d];for(2..$f){push@e,$a}($a,$
b)=($b,$a)}print@e[0..$c-1]
-l ($a)=@a=@ARGV;@s=($a,$a[$a-
1?0:1]);map{$e.=$d=$s[$x];map{$s[$j++]=$a[$x%2]}1..$d;$x++}1..$a[-1];print$e
-l ($a,$b,$c)=@ARGV;$o=$a x$a.$b x($a>1?$a:$b);$o.=$ARGV[$_%2]x substr$o,$_,1
for 2..$c;print substr$o,0,$c
-l ($%,$/)=@ARGV;$@=$%x$%.$/x($%==1?$/:$%);map{$@.=($_%2?$/:$%)x substr
$@,$_,1}2..500;print substr $@,0,pop
@a=@ARGV;while($a[2]--){if($_){s/.//;print$&;$_.=$a[$|--
]x$&}else{$_=$a[$|]x$a[$|--];s/.//;print$&}}print"
-l ($b,$a,$d)=@ARGV;do{push@l,split//,$b x($l[$c++]?$l[$c-
1]:$b);($a,$b)=($b,$a)}while@l<$d;print@l[0..$d-1]
@t=shift;$b=shift;for(1..pop){for(1..$t[$n]){@t[$i++]=$n%2?$b:$t[0]}$t[1]=$t[1]
||$b;$f.=$t[$n++]}print"$f\n"
@t=@ARGV;$l=pop@t;$"='';for($s="@t";$n<999;$i=0){$s=~s/(.)/$t[++$n,$i++%2]x$1/g
e;}print substr($s,0,$l),"\n";
($.,$/,$,)=@ARGV;$_=($;=$.)x$.;while((length)<$,){$;=$:++%2?$.:$/;/.{$:}(.)/
;$_.=$;x($+||$;)}print/(.{$,})/
for(@*=@ARGV;@/<$*[2];){@/<2?push@/,($*[$/])x$*[$/++]:push@/,($*[$*%2])x$/[$/++
];$*++;}print@/[0..$*[2]-1],"
-l (@n[0,1],$c)=@ARGV;while($c>0){$c-
=$l=(substr($o,$j,1)||$n[$i]);$o.=$n[$i]x$l;$i=!$i;$j++;}print
substr$o,0,pop
-l @z=((@0=@ARGV)[0])x$0[0];$#z or@z=(1,($0[--$|])x$0[++$"]);@z=(@z,($0[--
$|])x$z[++$"])for 0..666;print@z[0..--$0[2]]
-l @z=(@0=@ARGV)[0]==1?(1,($0[--$|])x$0[++$"]):($0[0])x$0[0];@z=(@z,($0[--
$|])x$z[++$"])for 0..666;print@z[0..--$0[2]]
($a,$b,$c)=@ARGV;do{$r=substr$k,$i++,1;$r=$a if!$r;$k.=$a
x$r;($a,$b)=($b,$a)}until$c<length$k;print substr($k,0,$c)."\n"
-l ($=,$-)=@ARGV,@a=($=)x$=;$=<2&&($y=1)&&push@a,($-)x$-;map{push@a,($_%2?$-
:$=)x$a[$_]}1+$y..999;$"=!splice@a,pop;print"@a";
-l ($A,$B,$C)=@ARGV;$x=$A x$A;if($A<2){$x.=$B
x$B;$i++}for($i+1..$C){$c=$ARGV[$_%2];$x.=$c x substr$x,$_,1}print
substr$x,0,$C
-l ($e,$d)=(shift,shift);for($s=pop;$s;$s--
){s/(.)//;$m=$1||$e;for$i(1..$m){s/$/$e/}$1?1:s/(.)//;$q.=$1;($e,$d)=($d,$e)
}print$q
($a,$b,$l)=@ARGV;@a=(($a)x$a,($b)x($a==1?$b:$a));for(;($j+=2)<$l;){@a=(@a,($
a)x$a[$j]);@a=(@a,($b)x$a[$j+1])}print@a[0..$l-1]
-l while($l=$ARGV[2]-
length($s)){$d=$ARGV[($e++)%2];push@l,split//,"$d"x($l[0]||$d)
;$n=shift@l||$d;$s.="$d"x($n>$l?$l:$n)}print$s
$h=($n=shift)+shift;$l=pop;do{if(@s>1){$j=$s[$i++];}else{$j=$n;++$i;}push@s,
($n)x$j;$n=$h-$n;}while(@s<$l);splice@s,$l;print@s;
$l=pop;@A=@ARGV;L:$a.=$A[$j%2]x$A[$j++%2];goto L
if($a<2);while($j<$l){$a.=$A[$j%2]x substr($a,$j++,1);}print
substr($a,0,$l)."\n";
$c=pop;$b=pop;$a=pop;$_=$a;while($c--){print;@s=((split//,$a
x--$_),@s);($#s==-1)?$_=$b:($_=pop@s,@s=($b,@s));$t=$a;$a=$b;$b=$t}print"
($A,$R,$G)=@ARGV;$_=$A x$A;if($A<2){$_.=$R
x$R;$x++}for(;$x<$G;$x++){$t=$R;$t=$A if$x%2;$_.=$t x
substr$_,$x+1,1}print((substr$_,0,$G),"\n");
$x=$ARGV[0];$y=$ARGV[1];$p=0;while(length($_)<=$ARGV[2]){$_.=$x;m/(.{$p})(\d)/;
$_.=$x x($2-1);($x,$y)=($y,$x);$p++}chop
while(length($_)>$ARGV[2]);print$_."\n";
$a=$ARGV[0];$b=$ARGV[1];$c=$ARGV[2];$d=0;$e=$a;$f=$a;$o='';while(length
$o<$c){$o.=$e x$f;if($e==$a){$e=$b}else{$e=$a};$f=substr
$o,++$d,1;if(!$f){$f=$b}}$o=substr $o,0,$c;print "$o\n";
($a,$b,$c)=@ARGV;sub w{$e=$_[0];$d[$_]=$e for(@d..@d+$_[1]-
1);}w($a,$a);if($a<2){w($b,$b);$f++}while(@d<$c){$f++;if($e!=$a){w($a,$d[$f]
)}else{w($b,$d[$f])}}print substr(join("",@d),0,$c),"\n";
($x,$y,$c)=@ARGV;if ($x==$y&&$y==1){print"1"x$c,"\n";exit;}$o=$x
x$x;$z=$y;$i=1;if($x==1){$o.=$y x$y;$i++;$z=$x}while(length($o)<=$c){$o.=$z
x substr($o,$i,1);$i++;$z=($z eq $x)?$y:$x}print substr($o,0,$c),"\n";
($o,$e,$n)=@ARGV;for($x=0;$x<$o;$x++){g($o);$p++;}if($o==1){for($x=0;$x<$e;$x++
){g($e);$p++;}}$c=substr$s,$p,1;while($l<$n){g($c);$p++;$c=substr$s,$p,1;}pr
int substr$s,0,$n;print"\n";sub
g{($z)=@_;$l+=$z;$r=$ARGV[$w++%2];for($x=0;$x<$z;$x++){$s.=$r;}}
-l print map@@[$.++]=$ARGV[--@@[$@]||++$@,$@&1],1..pop
-l eval'$l=@a;map$l-=$_*!!$l,@a;push@a,$d=$ARGV[!!$l^$d==$ARGV[0]];'x
pop;print@a
-l eval'$l=$s++;map$l-=$_*!!$l,/./g;s/$/$d=$ARGV[!!$l^$d==$ARGV[0]]/e;'x
-l eval'$l=@a=/./g;map$l-=$_*!!$l,@a;s/$/$ARGV[!!$l^$a[-1]==$ARGV[0]]/;'x
-l $,=pop;$a=\substr$_="@ARGV "x$,,0,$,;s/(.) /$+x
substr$_,$i++,1/ewhile$i<$,;print$$a
-l $c=pop;$a=\substr$_="@ARGV "x$c,0,$c;eval's/(.) /$+x
substr$_,$i++,1/e;'x500;print$$a
-l $_=\substr$@=1x pop,0;$@="";substr($@.=$ARGV[$|--],-
1)x=substr$@,$_,1for$"..500;print$$_
-l eval'if($l=@a=/./g){$i++until($l-=$a[$i])<1}
$i=!s/$/$ARGV[($a[-1]==$ARGV[0])^!!$l]/;'x
-l print map$_=$ARGV[($.+=!--$.[$.])%2],@.=(0)x pop
-l print map$.[$!++]=$ARGV[1&($.+=!--$.[$.])],1..pop
-l print map$$[$.++]=$ARGV[--$$[$;]||++$;,$;&1],1..pop
s/.?/$ARGV[1&pos]x$&||2/ge>>9?print$_&'?'x pop,$/:do$0
print$_?$.[$!++]=$ARGV[--$.[$.]||++$.,$.%2]:$/for-pop..0
-l for$$(1..pop){$_.=$ARGV[1&grep$|<($$-=$_),/./g]}print
-l print eval'($_.=chop()x$+.$ARGV[$|--])=~/$&(.)/,'x pop
s/.?/$ARGV[1&pos]x($&||1)/geuntil/.{$ARGV[2]}/;print$&,$/
$;=pop;s/.?/$ARGV[1&pos]x($&||1)/eguntil/.{$;}/;print"$&
-l s/.?/$ARGV[1&pos]x($&||1)/eg until/.{$ARGV[2]}/;print$&
-l $_.=2while$|=s/./$ARGV[--$|]x$&/ge<999;print$_&'?'x pop
s/.?/$ARGV[1&pos]x$&||2/ge<999?do$0:print/(.{${\pop}})/,$/
s/.?/$ARGV[$|--]x($&||1)/eguntil$|=/.{$ARGV[2]}/;print"$&
map{@;[0..@;]=map{($ARGV[$|--])x$_}@;,@;;print}@;=1..pop,$/
s/.?/$ARGV[1&pos]x$&||1/eg until/(.{$ARGV[2]})./;print"$1
s/.?/$ARGV[$-[0]%2]x($&||1)/ge until/.{$ARGV[2]}/;print$&,$/
s/.|/$ARGV[(pos)%2]x$&||9/ge<999?do$0:printf"%.${\pop}s
",$_
$%[$_]=$ARGV[$"],$*||=$%[++$.],$"^=!--$*for 1..pop;print@%,$/
$_=2;{s/./$ARGV[$-[0]%2]x$&/eg;/.{$ARGV[2]}/?print"$&
-l print map{-@@+push@@,($==$ARGV[$|--])x($@[$.++]||$=)}1..pop
s/.?/$ARGV[$"++%2]x($&||1)/eg until$"=/.{$ARGV[2]}/;print$&.$/
$_[$_]=$ARGV[$|-=!--$z],$z>0or$z=$_[++$*]for 1..pop;print@_,$/
-l print map{@.=(($?=$ARGV[$|--])x($.[-1]||$?),@.);pop@.}1..pop
-l print map{(map@/=(($_)x($/[--$%]||$_),@/),@ARGV)[-$_]}1..pop
-l print map{push@@,($%=$ARGV[--$_%2])x($@=$@[$_]||$%);$@}1..pop
-li1 map{push@,,$ARGV[$^I^=!$h];($h||=$,[$m++])--}1..pop;print@,
-l print map{push@_,($n=$ARGV[$i%2])x($c=$_[$i++]||$n);$c}1..pop
-l print+map+chop($*=($.=$ARGV[1&~$_])x chop($_=$..$*).$*),1..pop
-l $_.=($d=$ARGV[$|--])x(/./g,$d)[$f++]until/.{$ARGV[2]}/;print$&
-l $_.=($k=$ARGV[$i&1])x(/./g,$k)[$i++]until/.{$ARGV[2]}/;print$&
-l print map{push@a,($%=$ARGV[$_%2])x($n=$a[$_]||$%);$n}0..-1+pop
-l $n=pop;push@_,($_)x(@_,$_)[$i++]for(@ARGV)x$n--;print@_[0..$n]
-l push@,,($.=$ARGV[$|--])x($,[$_]||$.)for@/=0..-1+pop;print@,[@/]
print+(map{push@_,($-=$ARGV[$|--])x($==$_[--$_]||$-);$=}1..pop),$/
-l push@r,($/=$ARGV[1&$i])x($s[$i++]=$r[$i]||$/)for 1..pop;print@s
-l $l=pop;push@s,($_)x($s[$i++]||$_)for(@ARGV)x$l;print@s[0..--$l]
-l $o=pop;push@_,($_)x($_[$l++]||$_)for(@ARGV)x$o--;print@_[0..$o]
push@>,($.=@ARGV[$|--])x(@>,$.)[$_]for 0..500;print@>[0..-1+pop],$/
-l $$=pop;s/.?/$ARGV[1&pos]x$&||$ARGV[0]/eg until/(.{$$})./;print$1
$_.=($,=$ARGV[$%%2])x((/./g)[$%++]||$,)until/.{$ARGV[2]}/;print$&.$/
push@$,($$=$ARGV[$|--])x($$[$_]||$$)for 0..500;$#$=-1+pop;print@$,$/
-l print map{push@_,($%=$ARGV[$/^=1])x($\xa7=$_[$_-1]||$%);$\xa7}++$/..pop
push@_,($"=$ARGV[$_&1])x($_[$_]||$")for+0..500;$#_=-1+pop;print@_,$/
push@@,($@=$ARGV[$_%2])x($@[$_]||$@)for 0..333;print@@[0..(pop)-1],$/
$_=11;s!.!$ARGV[$-[0]%2]x$&!eg,s!(.{$ARGV[2]}).*!$1
!swhile--$=;print
-l push@_,($~=$ARGV[$|--])x($_[$-++]||$~)for a..kn;print@_[0..pop()-1]
-l map{push@_,($%=$ARGV[$_%2])x($_[$_]||$%)}0..500;print@_[0..(pop)-1]
-l print map{push@v,($_)x($v[0]||$_);shift@v}map$ARGV[$_%2^1],(1..pop)
-l @.=@ARGV;$.=1,s/./$.[$.^=1]x$&/ge,$_.=$.[!$.]until/.{$.[2]}/;print$&
for$"(1..pop){/.$/;$_=($-=$ARGV[$"-1&1])x($&||$-).$_;print chop}print$/
-l $_.=($x=$ARGV[$i%2])x(/./g,$x)[$i++]while$i<500;print substr$_,0,pop
$$=pop;$.=$ARGV[$|--],$_.=$.x substr$_.$.,$*++,1while!/.{$$}/;print$&,$/
-l /.{$i}(.)/,$;=$ARGV[$i++%2],$_.=$;x($1||$;)until/.{$ARGV[2]}/;print$&
-l push@a,($ARGV[$_%2])x($a[$_]||$ARGV[$_])for 0..999;print@a[0..-1+pop]
-l $l=pop;@l=(@l,($m=$ARGV[$|--])x($l[$_]||$m))for 0..$l;print@l[0..$l-1]
push@1,($ARGV[$|--])x($1[$_]or$ARGV[$;++])for$1..332;print@1[0..-1+pop],$/
@t=@ARGV;for(1..pop){print$u=$f[$p++]||$t[$|];push@f,($t[$|--])x$u}die"\n"
-l print map{$.=~s/.//;$..=($=^=$%||=($==pop)^pop)x($&||$=-1);$&||$=}1..pop
-l $.=pop;push@*,($==$ARGV[$%%2])x($*[$%++]||$=)while$%<$.;print@*[0..$.-1]
-l substr($@.=$ARGV[$|--],-1)x=substr$@,$_,1for 0..500;print substr$@,0,pop
-l print map{$x=$a.$x;$e||=chop$x;--$e?$a:($a^=$b)^$b}2..pop,$b=pop^($a=pop)
-l push@b,($ARGV[$_%2])x($b[$_]||$ARGV[$_%2])for(0..500);print@b[0..pop()-1]
-l ($a,$b)=@ARGV;print map{push@s,($l=$_%2?$a:$b)x($s[0]||$l);shift@s}1..pop
-l until(/.{$ARGV[2]}/&&print$&){/.{$b}(.)/;$^=$ARGV[$b++%2];$_.=$^x($1||$^)}
$/=$ARGV[1-$_%2],$*.=$/x($2||$/),$*=~s/(.)(.?)/$2/,print$1for 1..pop;print'
-l map{$s.=($a=$ARGV[$_%2])x(substr($s,$_,1)||$a)}0..999;print substr$s,0,pop
-l $n=pop;@l=@a=@ARGV;$i=0until(@l=map{($a[$i++&1])x$_}@l)>$n;print@l[0..--$n]
-l --$|,push@l,map$ARGV[!$|],1..$l[$_]||$ARGV[$_]for 0..500;print@l[0..pop()-1]
@a=@ARGV;s//@a/;while($i<666){$i=0;s/./$a[$i++&1]x$&/ge}s|.{$a[2]}|print$&,$/|e
-l *,=*ARGV;($,.=$,[$|])=~s,.,,,$,.=$,[$|--]x($&-
1),$_.=$&while$,[2]>y|||c;print
-l @A=@ARGV;push@a,($A[$_%2])x($a[$_]||$A[$_%2])for 0..$A[2];print@a[0..$A[2]-
-l @A=@ARGV;$z=$A[$_%2],push@a,($z)x($a[$_]||$z)for 0..$A[2];print@a[0..$A[2]-
-l for(0..pop){@s=(@ARGV)x999;push@a,($s[$i++])x($a[$_]||$s[$_])}print@a[0..$i-
-l @K=@ARGV;for$i(0..500){for(1..$K[$i]){$K[$p++]=$ARGV[$i%2]}}print@K[0..-
-l @a=@ARGV;print map{$n=$a[$_%2];push@d,$n for 1..$d[0]||$n;shift@d;}0..$a[2]-
-l @d=@ARGV;while($d[2]--){$b[$n++]=$d[$m%2];if($i++==$b[$m]-
1){$i=0;$m++}}print@b
-l ($a,$b,$t)=@ARGV;map{push@a,($c=$|--
?$b:$a)x($a[$_]||$c)}0..$t;print@a[0..$t-1]
-l $?=pop;$_.=($"=$ARGV[$x&1])x($:=($/=(/./g)[$x++]||$")>$??$?:$/)while$?-
=$:;print
-l for(;@o<501;++$c,$|--){push@o,($ARGV[$|])x($o[$c]||$ARGV[$|])}print@o[0..-
-l $n=pop;do{/.{$i}(.)/,$b=$ARGV[$i%2],$_.=$b
x($1||$b)}while$i++<$n;print/(.{$n})/
-l @a=@ARGV;map{$/=$a[$_%2];push@d,$/for
1..$d[$_]||$/}0..$a[2];print@d[0..$a[2]-1]
-l sub x{push@t,$ARGV[$i%2];$;--}$;=pop;while($;){x;$;&&x for
2..$t[$i];$i++}print@t
-l ($s,$t,$n)=@ARGV;$_=$s.$t;$p="$t$s"x$n,s/./chop($p)x$&/eg
until/(.{$n})./;print$1
-l ($x,$y,$a)=@ARGV;push@f,($|--?$y:$x)x($f[$_]||$|*$x||$y)for
0..$a;print@f[0..$a-1]
-l ($%,$.,$=)=@ARGV;($.,$%)=($%,$.),push@.,($.)x($.[$_]||$.)for
0..$=;print@.[0..$=-1]
@a=@ARGV;push@c,($a[$e&1])x@{$e<=@c?@c:@a}[$e++]while(@c<$a[2]);print@c[0..--
$a[2]],$/
-l $==pop;push@],($_)x($-++?$-<3?$%>1?$%:$_:$][$--
1]:($%=$_))for(@ARGV)x$=;print@][0..$=-1]
-l ($/,$b)=@ARGV;for(0..999){$;=$_%2?$b:$/;$k.=$;x(substr($k,$_,1)||$;)}print
substr$k,0,pop
$l=pop;@s=@ARGV;while(@l<$l){@l=(@l,($s[$c%2])x($l[$c]||$s[$c%2]));$c++}prin
t@l[
0..--$l]
-l @x=@ARGV;$i=shift;$z.=$x[$_%2]x$i,$i=substr$z.$x[1],$_+1,1for 0..567;print
substr$z,0,pop
($a,$b,$n)=@ARGV;$b^=$k=$a;$k||($a^=$b,$k=$R[++$p]||$a),(push@R,$a),$k--
while$n--;print@R,'
-l print+map{$c--||($v=$ARGV[$|--],$c=$_<1?$v:$_-1?$s[$_-$d]:$v,$d+=--
$c);$s[$_]=$v}0..-1+pop
($a,$b,$l)=@ARGV;push@a,($_%2?$b:$a)x($_<2?$a<2*$_?$b:$a:$a[$_])for
0..$l;print@a[0..$l-1],$/
($a,$b,$c)=@ARGV;for$i(0..$c){pos=$i;/./g;$_.=($i%2?$b:$a)x($_==1?$b:$&||$a)}pr
int/(.{$c})/,$/
($a,$b,$c)=@ARGV;while(@_<$c){map{push+_,$a}1..$_[$l++]||$a;$a^=$b^=$a^=$b}p
rint@_[0..$c-1]
b:if(@b==$ARGV[2]){print@b,"
";exit}push @b,$ARGV[$i%2];$k++;$k<$b[$i]&&goto b;$k=0;$i++;goto b
($a,$b,$c)=@ARGV;for(0..$c){$s.=($_%2?$b:$a)x(substr($s,$_,1)||shift)}print
substr($s,0,$c)."
($,,$;,$")=@ARGV;$_=$,x$,;$_.=(/$,$/?$;:$,)x(substr($_,++$i,1)||$;)while$i<$
";/.{$"}/;print$&
-l ($:,$;,$%)=@ARGV;$_=$:x$:;$_.=$;
x(substr$_,++$x,1or$;),($:,$;)=($;,$:)while$%>$x;/.{$%}/;print$&
@a=@ARGV;@b="";for$i(1..$a[2]){for$j(1..($b[$i]||$a[$t])){push(@b,$a[$t])}$t
=!$t;$_.=$b[$i]}print
-l ($a,$b,$l)=@ARGV;$b+=$a;for(1..$l){$p=$a-
1;$s.=@n?($p=pop@n):$a;@n=(($a)x$p,@n);$a=$b-$a;}print$s;
($n,$s,$i)=@ARGV;$l=0;map{push@r,(@ARGV[$l])x$n;$l=$l?0:1;$n=@r[$_]?@r[$_]:$
s;}1..500;print@r[0..--$i]
-l ($.,$/,$")=@ARGV;split'',$.x$..$/;for(0..$"){$_[$%++]=$-
?$/:$.for(1..$_[$?++]);$-=1-$-}$#_=$"-1;print@_
@k=@ARGV;for(0..pop){splice(@k,$o,$k[$i],($x=shift)x$k[$i]),$o+=$k[$i++],pus
h@ARGV,$x}print @k[0..$i-2]
($a,$b,$c)=@ARGV;for$d(0..$c){push@e,$a;$f=$e[$d];for(2..$f){push@e,$a}($a,$
b)=($b,$a)}print@e[0..$c-1]
-l ($a)=@a=@ARGV;@s=($a,$a[$a-
1?0:1]);map{$e.=$d=$s[$x];map{$s[$j++]=$a[$x%2]}1..$d;$x++}1..$a[-1];print$e
-l ($a,$b,$c)=@ARGV;$o=$a x$a.$b x($a>1?$a:$b);$o.=$ARGV[$_%2]x substr$o,$_,1
for 2..$c;print substr$o,0,$c
-l ($%,$/)=@ARGV;$@=$%x$%.$/x($%==1?$/:$%);map{$@.=($_%2?$/:$%)x substr
$@,$_,1}2..500;print substr $@,0,pop
@a=@ARGV;while($a[2]--){if($_){s/.//;print$&;$_.=$a[$|--
]x$&}else{$_=$a[$|]x$a[$|--];s/.//;print$&}}print"
-l ($b,$a,$d)=@ARGV;do{push@l,split//,$b x($l[$c++]?$l[$c-
1]:$b);($a,$b)=($b,$a)}while@l<$d;print@l[0..$d-1]
@t=shift;$b=shift;for(1..pop){for(1..$t[$n]){@t[$i++]=$n%2?$b:$t[0]}$t[1]=$t[1]
||$b;$f.=$t[$n++]}print"$f\n"
@t=@ARGV;$l=pop@t;$"='';for($s="@t";$n<999;$i=0){$s=~s/(.)/$t[++$n,$i++%2]x$1/g
e;}print substr($s,0,$l),"\n";
($.,$/,$,)=@ARGV;$_=($;=$.)x$.;while((length)<$,){$;=$:++%2?$.:$/;/.{$:}(.)/
;$_.=$;x($+||$;)}print/(.{$,})/
for(@*=@ARGV;@/<$*[2];){@/<2?push@/,($*[$/])x$*[$/++]:push@/,($*[$*%2])x$/[$/++
];$*++;}print@/[0..$*[2]-1],"
-l (@n[0,1],$c)=@ARGV;while($c>0){$c-
=$l=(substr($o,$j,1)||$n[$i]);$o.=$n[$i]x$l;$i=!$i;$j++;}print
substr$o,0,pop
-l @z=((@0=@ARGV)[0])x$0[0];$#z or@z=(1,($0[--$|])x$0[++$"]);@z=(@z,($0[--
$|])x$z[++$"])for 0..666;print@z[0..--$0[2]]
-l @z=(@0=@ARGV)[0]==1?(1,($0[--$|])x$0[++$"]):($0[0])x$0[0];@z=(@z,($0[--
$|])x$z[++$"])for 0..666;print@z[0..--$0[2]]
($a,$b,$c)=@ARGV;do{$r=substr$k,$i++,1;$r=$a if!$r;$k.=$a
x$r;($a,$b)=($b,$a)}until$c<length$k;print substr($k,0,$c)."\n"
-l ($=,$-)=@ARGV,@a=($=)x$=;$=<2&&($y=1)&&push@a,($-)x$-;map{push@a,($_%2?$-
:$=)x$a[$_]}1+$y..999;$"=!splice@a,pop;print"@a";
-l ($A,$B,$C)=@ARGV;$x=$A x$A;if($A<2){$x.=$B
x$B;$i++}for($i+1..$C){$c=$ARGV[$_%2];$x.=$c x substr$x,$_,1}print
substr$x,0,$C
-l ($e,$d)=(shift,shift);for($s=pop;$s;$s--
){s/(.)//;$m=$1||$e;for$i(1..$m){s/$/$e/}$1?1:s/(.)//;$q.=$1;($e,$d)=($d,$e)
}print$q
($a,$b,$l)=@ARGV;@a=(($a)x$a,($b)x($a==1?$b:$a));for(;($j+=2)<$l;){@a=(@a,($
a)x$a[$j]);@a=(@a,($b)x$a[$j+1])}print@a[0..$l-1]
-l while($l=$ARGV[2]-
length($s)){$d=$ARGV[($e++)%2];push@l,split//,"$d"x($l[0]||$d)
;$n=shift@l||$d;$s.="$d"x($n>$l?$l:$n)}print$s
$h=($n=shift)+shift;$l=pop;do{if(@s>1){$j=$s[$i++];}else{$j=$n;++$i;}push@s,
($n)x$j;$n=$h-$n;}while(@s<$l);splice@s,$l;print@s;
$l=pop;@A=@ARGV;L:$a.=$A[$j%2]x$A[$j++%2];goto L
if($a<2);while($j<$l){$a.=$A[$j%2]x substr($a,$j++,1);}print
substr($a,0,$l)."\n";
$c=pop;$b=pop;$a=pop;$_=$a;while($c--){print;@s=((split//,$a
x--$_),@s);($#s==-1)?$_=$b:($_=pop@s,@s=($b,@s));$t=$a;$a=$b;$b=$t}print"
($A,$R,$G)=@ARGV;$_=$A x$A;if($A<2){$_.=$R
x$R;$x++}for(;$x<$G;$x++){$t=$R;$t=$A if$x%2;$_.=$t x
substr$_,$x+1,1}print((substr$_,0,$G),"\n");
$x=$ARGV[0];$y=$ARGV[1];$p=0;while(length($_)<=$ARGV[2]){$_.=$x;m/(.{$p})(\d)/;
$_.=$x x($2-1);($x,$y)=($y,$x);$p++}chop
while(length($_)>$ARGV[2]);print$_."\n";
$a=$ARGV[0];$b=$ARGV[1];$c=$ARGV[2];$d=0;$e=$a;$f=$a;$o='';while(length
$o<$c){$o.=$e x$f;if($e==$a){$e=$b}else{$e=$a};$f=substr
$o,++$d,1;if(!$f){$f=$b}}$o=substr $o,0,$c;print "$o\n";
($a,$b,$c)=@ARGV;sub w{$e=$_[0];$d[$_]=$e for(@d..@d+$_[1]-
1);}w($a,$a);if($a<2){w($b,$b);$f++}while(@d<$c){$f++;if($e!=$a){w($a,$d[$f]
)}else{w($b,$d[$f])}}print substr(join("",@d),0,$c),"\n";
($x,$y,$c)=@ARGV;if ($x==$y&&$y==1){print"1"x$c,"\n";exit;}$o=$x
x$x;$z=$y;$i=1;if($x==1){$o.=$y x$y;$i++;$z=$x}while(length($o)<=$c){$o.=$z
x substr($o,$i,1);$i++;$z=($z eq $x)?$y:$x}print substr($o,0,$c),"\n";
($o,$e,$n)=@ARGV;for($x=0;$x<$o;$x++){g($o);$p++;}if($o==1){for($x=0;$x<$e;$x++
){g($e);$p++;}}$c=substr$s,$p,1;while($l<$n){g($c);$p++;$c=substr$s,$p,1;}pr
int substr$s,0,$n;print"\n";sub
g{($z)=@_;$l+=$z;$r=$ARGV[$w++%2];for($x=0;$x<$z;$x++){$s.=$r;}}
-l print map@@[$.++]=$ARGV[--@@[$@]||++$@,$@&1],1..pop
-l eval'$l=@a;map$l-=$_*!!$l,@a;push@a,$d=$ARGV[!!$l^$d==$ARGV[0]];'x
pop;print@a
-l eval'$l=$s++;map$l-=$_*!!$l,/./g;s/$/$d=$ARGV[!!$l^$d==$ARGV[0]]/e;'x
-l eval'$l=@a=/./g;map$l-=$_*!!$l,@a;s/$/$ARGV[!!$l^$a[-1]==$ARGV[0]]/;'x
-l $,=pop;$a=\substr$_="@ARGV "x$,,0,$,;s/(.) /$+x
substr$_,$i++,1/ewhile$i<$,;print$$a
-l $c=pop;$a=\substr$_="@ARGV "x$c,0,$c;eval's/(.) /$+x
substr$_,$i++,1/e;'x500;print$$a
-l $_=\substr$@=1x pop,0;$@="";substr($@.=$ARGV[$|--],-
1)x=substr$@,$_,1for$"..500;print$$_
-l eval'if($l=@a=/./g){$i++until($l-=$a[$i])<1}
$i=!s/$/$ARGV[($a[-1]==$ARGV[0])^!!$l]/;'x
51 (post-mortem) 
-l print map$_=$ARGV[($.+=!--$.[$.])%2],@.=(0)x pop
-l print map$.[$!++]=$ARGV[1&($.+=!--$.[$.])],1..pop
-l print map$$[$.++]=$ARGV[--$$[$;]||++$;,$;&1],1..pop
s/.?/$ARGV[1&pos]x$&||2/ge>>9?print$_&'?'x pop,$/:do$0
print$_?$.[$!++]=$ARGV[--$.[$.]||++$.,$.%2]:$/for-pop..0
-l for$$(1..pop){$_.=$ARGV[1&grep$|<($$-=$_),/./g]}print
-l print eval'($_.=chop()x$+.$ARGV[$|--])=~/$&(.)/,'x pop
s/.?/$ARGV[1&pos]x($&||1)/geuntil/.{$ARGV[2]}/;print$&,$/
$;=pop;s/.?/$ARGV[1&pos]x($&||1)/eguntil/.{$;}/;print"$&
-l s/.?/$ARGV[1&pos]x($&||1)/eg until/.{$ARGV[2]}/;print$&
-l $_.=2while$|=s/./$ARGV[--$|]x$&/ge<999;print$_&'?'x pop
s/.?/$ARGV[1&pos]x$&||2/ge<999?do$0:print/(.{${\pop}})/,$/
s/.?/$ARGV[$|--]x($&||1)/eguntil$|=/.{$ARGV[2]}/;print"$&
map{@;[0..@;]=map{($ARGV[$|--])x$_}@;,@;;print}@;=1..pop,$/
s/.?/$ARGV[1&pos]x$&||1/eg until/(.{$ARGV[2]})./;print"$1
s/.?/$ARGV[$-[0]%2]x($&||1)/ge until/.{$ARGV[2]}/;print$&,$/
s/.|/$ARGV[(pos)%2]x$&||9/ge<999?do$0:printf"%.${\pop}s
",$_
$%[$_]=$ARGV[$"],$*||=$%[++$.],$"^=!--$*for 1..pop;print@%,$/
$_=2;{s/./$ARGV[$-[0]%2]x$&/eg;/.{$ARGV[2]}/?print"$&
-l print map{-@@+push@@,($==$ARGV[$|--])x($@[$.++]||$=)}1..pop
s/.?/$ARGV[$"++%2]x($&||1)/eg until$"=/.{$ARGV[2]}/;print$&.$/
$_[$_]=$ARGV[$|-=!--$z],$z>0or$z=$_[++$*]for 1..pop;print@_,$/
-l print map{@.=(($?=$ARGV[$|--])x($.[-1]||$?),@.);pop@.}1..pop
-l print map{(map@/=(($_)x($/[--$%]||$_),@/),@ARGV)[-$_]}1..pop
-l print map{push@@,($%=$ARGV[--$_%2])x($@=$@[$_]||$%);$@}1..pop
-li1 map{push@,,$ARGV[$^I^=!$h];($h||=$,[$m++])--}1..pop;print@,
-l print map{push@_,($n=$ARGV[$i%2])x($c=$_[$i++]||$n);$c}1..pop
-l print+map+chop($*=($.=$ARGV[1&~$_])x chop($_=$..$*).$*),1..pop
-l $_.=($d=$ARGV[$|--])x(/./g,$d)[$f++]until/.{$ARGV[2]}/;print$&
-l $_.=($k=$ARGV[$i&1])x(/./g,$k)[$i++]until/.{$ARGV[2]}/;print$&
-l print map{push@a,($%=$ARGV[$_%2])x($n=$a[$_]||$%);$n}0..-1+pop
-l $n=pop;push@_,($_)x(@_,$_)[$i++]for(@ARGV)x$n--;print@_[0..$n]
-l push@,,($.=$ARGV[$|--])x($,[$_]||$.)for@/=0..-1+pop;print@,[@/]
print+(map{push@_,($-=$ARGV[$|--])x($==$_[--$_]||$-);$=}1..pop),$/
-l push@r,($/=$ARGV[1&$i])x($s[$i++]=$r[$i]||$/)for 1..pop;print@s
-l $l=pop;push@s,($_)x($s[$i++]||$_)for(@ARGV)x$l;print@s[0..--$l]
-l $o=pop;push@_,($_)x($_[$l++]||$_)for(@ARGV)x$o--;print@_[0..$o]
push@>,($.=@ARGV[$|--])x(@>,$.)[$_]for 0..500;print@>[0..-1+pop],$/
-l $$=pop;s/.?/$ARGV[1&pos]x$&||$ARGV[0]/eg until/(.{$$})./;print$1
$_.=($,=$ARGV[$%%2])x((/./g)[$%++]||$,)until/.{$ARGV[2]}/;print$&.$/
push@$,($$=$ARGV[$|--])x($$[$_]||$$)for 0..500;$#$=-1+pop;print@$,$/
-l print map{push@_,($%=$ARGV[$/^=1])x($\xa7=$_[$_-1]||$%);$\xa7}++$/..pop
push@_,($"=$ARGV[$_&1])x($_[$_]||$")for+0..500;$#_=-1+pop;print@_,$/
push@@,($@=$ARGV[$_%2])x($@[$_]||$@)for 0..333;print@@[0..(pop)-1],$/
$_=11;s!.!$ARGV[$-[0]%2]x$&!eg,s!(.{$ARGV[2]}).*!$1
!swhile--$=;print
-l push@_,($~=$ARGV[$|--])x($_[$-++]||$~)for a..kn;print@_[0..pop()-1]
-l map{push@_,($%=$ARGV[$_%2])x($_[$_]||$%)}0..500;print@_[0..(pop)-1]
-l print map{push@v,($_)x($v[0]||$_);shift@v}map$ARGV[$_%2^1],(1..pop)
-l @.=@ARGV;$.=1,s/./$.[$.^=1]x$&/ge,$_.=$.[!$.]until/.{$.[2]}/;print$&
for$"(1..pop){/.$/;$_=($-=$ARGV[$"-1&1])x($&||$-).$_;print chop}print$/
-l $_.=($x=$ARGV[$i%2])x(/./g,$x)[$i++]while$i<500;print substr$_,0,pop
$$=pop;$.=$ARGV[$|--],$_.=$.x substr$_.$.,$*++,1while!/.{$$}/;print$&,$/
-l /.{$i}(.)/,$;=$ARGV[$i++%2],$_.=$;x($1||$;)until/.{$ARGV[2]}/;print$&
-l push@a,($ARGV[$_%2])x($a[$_]||$ARGV[$_])for 0..999;print@a[0..-1+pop]
-l $l=pop;@l=(@l,($m=$ARGV[$|--])x($l[$_]||$m))for 0..$l;print@l[0..$l-1]
push@1,($ARGV[$|--])x($1[$_]or$ARGV[$;++])for$1..332;print@1[0..-1+pop],$/
@t=@ARGV;for(1..pop){print$u=$f[$p++]||$t[$|];push@f,($t[$|--])x$u}die"\n"
-l print map{$.=~s/.//;$..=($=^=$%||=($==pop)^pop)x($&||$=-1);$&||$=}1..pop
-l $.=pop;push@*,($==$ARGV[$%%2])x($*[$%++]||$=)while$%<$.;print@*[0..$.-1]
-l substr($@.=$ARGV[$|--],-1)x=substr$@,$_,1for 0..500;print substr$@,0,pop
-l print map{$x=$a.$x;$e||=chop$x;--$e?$a:($a^=$b)^$b}2..pop,$b=pop^($a=pop)
-l push@b,($ARGV[$_%2])x($b[$_]||$ARGV[$_%2])for(0..500);print@b[0..pop()-1]
-l ($a,$b)=@ARGV;print map{push@s,($l=$_%2?$a:$b)x($s[0]||$l);shift@s}1..pop
-l until(/.{$ARGV[2]}/&&print$&){/.{$b}(.)/;$^=$ARGV[$b++%2];$_.=$^x($1||$^)}
$/=$ARGV[1-$_%2],$*.=$/x($2||$/),$*=~s/(.)(.?)/$2/,print$1for 1..pop;print'
-l map{$s.=($a=$ARGV[$_%2])x(substr($s,$_,1)||$a)}0..999;print substr$s,0,pop
-l $n=pop;@l=@a=@ARGV;$i=0until(@l=map{($a[$i++&1])x$_}@l)>$n;print@l[0..--$n]
-l --$|,push@l,map$ARGV[!$|],1..$l[$_]||$ARGV[$_]for 0..500;print@l[0..pop()-1]
@a=@ARGV;s//@a/;while($i<666){$i=0;s/./$a[$i++&1]x$&/ge}s|.{$a[2]}|print$&,$/|e
-l *,=*ARGV;($,.=$,[$|])=~s,.,,,$,.=$,[$|--]x($&-
1),$_.=$&while$,[2]>y|||c;print
-l @A=@ARGV;push@a,($A[$_%2])x($a[$_]||$A[$_%2])for 0..$A[2];print@a[0..$A[2]-
-l @A=@ARGV;$z=$A[$_%2],push@a,($z)x($a[$_]||$z)for 0..$A[2];print@a[0..$A[2]-
-l for(0..pop){@s=(@ARGV)x999;push@a,($s[$i++])x($a[$_]||$s[$_])}print@a[0..$i-
-l @K=@ARGV;for$i(0..500){for(1..$K[$i]){$K[$p++]=$ARGV[$i%2]}}print@K[0..-
-l @a=@ARGV;print map{$n=$a[$_%2];push@d,$n for 1..$d[0]||$n;shift@d;}0..$a[2]-
-l @d=@ARGV;while($d[2]--){$b[$n++]=$d[$m%2];if($i++==$b[$m]-
1){$i=0;$m++}}print@b
-l ($a,$b,$t)=@ARGV;map{push@a,($c=$|--
?$b:$a)x($a[$_]||$c)}0..$t;print@a[0..$t-1]
-l $?=pop;$_.=($"=$ARGV[$x&1])x($:=($/=(/./g)[$x++]||$")>$??$?:$/)while$?-
=$:;print
-l for(;@o<501;++$c,$|--){push@o,($ARGV[$|])x($o[$c]||$ARGV[$|])}print@o[0..-
-l $n=pop;do{/.{$i}(.)/,$b=$ARGV[$i%2],$_.=$b
x($1||$b)}while$i++<$n;print/(.{$n})/
-l @a=@ARGV;map{$/=$a[$_%2];push@d,$/for
1..$d[$_]||$/}0..$a[2];print@d[0..$a[2]-1]
-l sub x{push@t,$ARGV[$i%2];$;--}$;=pop;while($;){x;$;&&x for
2..$t[$i];$i++}print@t
-l ($s,$t,$n)=@ARGV;$_=$s.$t;$p="$t$s"x$n,s/./chop($p)x$&/eg
until/(.{$n})./;print$1
-l ($x,$y,$a)=@ARGV;push@f,($|--?$y:$x)x($f[$_]||$|*$x||$y)for
0..$a;print@f[0..$a-1]
-l ($%,$.,$=)=@ARGV;($.,$%)=($%,$.),push@.,($.)x($.[$_]||$.)for
0..$=;print@.[0..$=-1]
@a=@ARGV;push@c,($a[$e&1])x@{$e<=@c?@c:@a}[$e++]while(@c<$a[2]);print@c[0..--
$a[2]],$/
-l $==pop;push@],($_)x($-++?$-<3?$%>1?$%:$_:$][$--
1]:($%=$_))for(@ARGV)x$=;print@][0..$=-1]
-l ($/,$b)=@ARGV;for(0..999){$;=$_%2?$b:$/;$k.=$;x(substr($k,$_,1)||$;)}print
substr$k,0,pop
$l=pop;@s=@ARGV;while(@l<$l){@l=(@l,($s[$c%2])x($l[$c]||$s[$c%2]));$c++}prin
t@l[
0..--$l]
-l @x=@ARGV;$i=shift;$z.=$x[$_%2]x$i,$i=substr$z.$x[1],$_+1,1for 0..567;print
substr$z,0,pop
($a,$b,$n)=@ARGV;$b^=$k=$a;$k||($a^=$b,$k=$R[++$p]||$a),(push@R,$a),$k--
while$n--;print@R,'
-l print+map{$c--||($v=$ARGV[$|--],$c=$_<1?$v:$_-1?$s[$_-$d]:$v,$d+=--
$c);$s[$_]=$v}0..-1+pop
($a,$b,$l)=@ARGV;push@a,($_%2?$b:$a)x($_<2?$a<2*$_?$b:$a:$a[$_])for
0..$l;print@a[0..$l-1],$/
($a,$b,$c)=@ARGV;for$i(0..$c){pos=$i;/./g;$_.=($i%2?$b:$a)x($_==1?$b:$&||$a)}pr
int/(.{$c})/,$/
($a,$b,$c)=@ARGV;while(@_<$c){map{push+_,$a}1..$_[$l++]||$a;$a^=$b^=$a^=$b}p
rint@_[0..$c-1]
b:if(@b==$ARGV[2]){print@b,"
";exit}push @b,$ARGV[$i%2];$k++;$k<$b[$i]&&goto b;$k=0;$i++;goto b
($a,$b,$c)=@ARGV;for(0..$c){$s.=($_%2?$b:$a)x(substr($s,$_,1)||shift)}print
substr($s,0,$c)."
($,,$;,$")=@ARGV;$_=$,x$,;$_.=(/$,$/?$;:$,)x(substr($_,++$i,1)||$;)while$i<$
";/.{$"}/;print$&
-l ($:,$;,$%)=@ARGV;$_=$:x$:;$_.=$;
x(substr$_,++$x,1or$;),($:,$;)=($;,$:)while$%>$x;/.{$%}/;print$&
@a=@ARGV;@b="";for$i(1..$a[2]){for$j(1..($b[$i]||$a[$t])){push(@b,$a[$t])}$t
=!$t;$_.=$b[$i]}print
-l ($a,$b,$l)=@ARGV;$b+=$a;for(1..$l){$p=$a-
1;$s.=@n?($p=pop@n):$a;@n=(($a)x$p,@n);$a=$b-$a;}print$s;
($n,$s,$i)=@ARGV;$l=0;map{push@r,(@ARGV[$l])x$n;$l=$l?0:1;$n=@r[$_]?@r[$_]:$
s;}1..500;print@r[0..--$i]
-l ($.,$/,$")=@ARGV;split'',$.x$..$/;for(0..$"){$_[$%++]=$-
?$/:$.for(1..$_[$?++]);$-=1-$-}$#_=$"-1;print@_
@k=@ARGV;for(0..pop){splice(@k,$o,$k[$i],($x=shift)x$k[$i]),$o+=$k[$i++],pus
h@ARGV,$x}print @k[0..$i-2]
($a,$b,$c)=@ARGV;for$d(0..$c){push@e,$a;$f=$e[$d];for(2..$f){push@e,$a}($a,$
b)=($b,$a)}print@e[0..$c-1]
-l ($a)=@a=@ARGV;@s=($a,$a[$a-
1?0:1]);map{$e.=$d=$s[$x];map{$s[$j++]=$a[$x%2]}1..$d;$x++}1..$a[-1];print$e
-l ($a,$b,$c)=@ARGV;$o=$a x$a.$b x($a>1?$a:$b);$o.=$ARGV[$_%2]x substr$o,$_,1
for 2..$c;print substr$o,0,$c
-l ($%,$/)=@ARGV;$@=$%x$%.$/x($%==1?$/:$%);map{$@.=($_%2?$/:$%)x substr
$@,$_,1}2..500;print substr $@,0,pop
@a=@ARGV;while($a[2]--){if($_){s/.//;print$&;$_.=$a[$|--
]x$&}else{$_=$a[$|]x$a[$|--];s/.//;print$&}}print"
-l ($b,$a,$d)=@ARGV;do{push@l,split//,$b x($l[$c++]?$l[$c-
1]:$b);($a,$b)=($b,$a)}while@l<$d;print@l[0..$d-1]
@t=shift;$b=shift;for(1..pop){for(1..$t[$n]){@t[$i++]=$n%2?$b:$t[0]}$t[1]=$t[1]
||$b;$f.=$t[$n++]}print"$f\n"
@t=@ARGV;$l=pop@t;$"='';for($s="@t";$n<999;$i=0){$s=~s/(.)/$t[++$n,$i++%2]x$1/g
e;}print substr($s,0,$l),"\n";
($.,$/,$,)=@ARGV;$_=($;=$.)x$.;while((length)<$,){$;=$:++%2?$.:$/;/.{$:}(.)/
;$_.=$;x($+||$;)}print/(.{$,})/
for(@*=@ARGV;@/<$*[2];){@/<2?push@/,($*[$/])x$*[$/++]:push@/,($*[$*%2])x$/[$/++
];$*++;}print@/[0..$*[2]-1],"
-l (@n[0,1],$c)=@ARGV;while($c>0){$c-
=$l=(substr($o,$j,1)||$n[$i]);$o.=$n[$i]x$l;$i=!$i;$j++;}print
substr$o,0,pop
-l @z=((@0=@ARGV)[0])x$0[0];$#z or@z=(1,($0[--$|])x$0[++$"]);@z=(@z,($0[--
$|])x$z[++$"])for 0..666;print@z[0..--$0[2]]
-l @z=(@0=@ARGV)[0]==1?(1,($0[--$|])x$0[++$"]):($0[0])x$0[0];@z=(@z,($0[--
$|])x$z[++$"])for 0..666;print@z[0..--$0[2]]
($a,$b,$c)=@ARGV;do{$r=substr$k,$i++,1;$r=$a if!$r;$k.=$a
x$r;($a,$b)=($b,$a)}until$c<length$k;print substr($k,0,$c)."\n"
-l ($=,$-)=@ARGV,@a=($=)x$=;$=<2&&($y=1)&&push@a,($-)x$-;map{push@a,($_%2?$-
:$=)x$a[$_]}1+$y..999;$"=!splice@a,pop;print"@a";
-l ($A,$B,$C)=@ARGV;$x=$A x$A;if($A<2){$x.=$B
x$B;$i++}for($i+1..$C){$c=$ARGV[$_%2];$x.=$c x substr$x,$_,1}print
substr$x,0,$C
-l ($e,$d)=(shift,shift);for($s=pop;$s;$s--
){s/(.)//;$m=$1||$e;for$i(1..$m){s/$/$e/}$1?1:s/(.)//;$q.=$1;($e,$d)=($d,$e)
}print$q
($a,$b,$l)=@ARGV;@a=(($a)x$a,($b)x($a==1?$b:$a));for(;($j+=2)<$l;){@a=(@a,($
a)x$a[$j]);@a=(@a,($b)x$a[$j+1])}print@a[0..$l-1]
-l while($l=$ARGV[2]-
length($s)){$d=$ARGV[($e++)%2];push@l,split//,"$d"x($l[0]||$d)
;$n=shift@l||$d;$s.="$d"x($n>$l?$l:$n)}print$s
$h=($n=shift)+shift;$l=pop;do{if(@s>1){$j=$s[$i++];}else{$j=$n;++$i;}push@s,
($n)x$j;$n=$h-$n;}while(@s<$l);splice@s,$l;print@s;
$l=pop;@A=@ARGV;L:$a.=$A[$j%2]x$A[$j++%2];goto L
if($a<2);while($j<$l){$a.=$A[$j%2]x substr($a,$j++,1);}print
substr($a,0,$l)."\n";
$c=pop;$b=pop;$a=pop;$_=$a;while($c--){print;@s=((split//,$a
x--$_),@s);($#s==-1)?$_=$b:($_=pop@s,@s=($b,@s));$t=$a;$a=$b;$b=$t}print"
($A,$R,$G)=@ARGV;$_=$A x$A;if($A<2){$_.=$R
x$R;$x++}for(;$x<$G;$x++){$t=$R;$t=$A if$x%2;$_.=$t x
substr$_,$x+1,1}print((substr$_,0,$G),"\n");
$x=$ARGV[0];$y=$ARGV[1];$p=0;while(length($_)<=$ARGV[2]){$_.=$x;m/(.{$p})(\d)/;
$_.=$x x($2-1);($x,$y)=($y,$x);$p++}chop
while(length($_)>$ARGV[2]);print$_."\n";
$a=$ARGV[0];$b=$ARGV[1];$c=$ARGV[2];$d=0;$e=$a;$f=$a;$o='';while(length
$o<$c){$o.=$e x$f;if($e==$a){$e=$b}else{$e=$a};$f=substr
$o,++$d,1;if(!$f){$f=$b}}$o=substr $o,0,$c;print "$o\n";
($a,$b,$c)=@ARGV;sub w{$e=$_[0];$d[$_]=$e for(@d..@d+$_[1]-
1);}w($a,$a);if($a<2){w($b,$b);$f++}while(@d<$c){$f++;if($e!=$a){w($a,$d[$f]
)}else{w($b,$d[$f])}}print substr(join("",@d),0,$c),"\n";
($x,$y,$c)=@ARGV;if ($x==$y&&$y==1){print"1"x$c,"\n";exit;}$o=$x
x$x;$z=$y;$i=1;if($x==1){$o.=$y x$y;$i++;$z=$x}while(length($o)<=$c){$o.=$z
x substr($o,$i,1);$i++;$z=($z eq $x)?$y:$x}print substr($o,0,$c),"\n";
($o,$e,$n)=@ARGV;for($x=0;$x<$o;$x++){g($o);$p++;}if($o==1){for($x=0;$x<$e;$x++
){g($e);$p++;}}$c=substr$s,$p,1;while($l<$n){g($c);$p++;$c=substr$s,$p,1;}pr
int substr$s,0,$n;print"\n";sub
g{($z)=@_;$l+=$z;$r=$ARGV[$w++%2];for($x=0;$x<$z;$x++){$s.=$r;}}
-l print map@@[$.++]=$ARGV[--@@[$@]||++$@,$@&1],1..pop
-l eval'$l=@a;map$l-=$_*!!$l,@a;push@a,$d=$ARGV[!!$l^$d==$ARGV[0]];'x
pop;print@a
-l eval'$l=$s++;map$l-=$_*!!$l,/./g;s/$/$d=$ARGV[!!$l^$d==$ARGV[0]]/e;'x
-l eval'$l=@a=/./g;map$l-=$_*!!$l,@a;s/$/$ARGV[!!$l^$a[-1]==$ARGV[0]]/;'x
-l $,=pop;$a=\substr$_="@ARGV "x$,,0,$,;s/(.) /$+x
substr$_,$i++,1/ewhile$i<$,;print$$a
-l $c=pop;$a=\substr$_="@ARGV "x$c,0,$c;eval's/(.) /$+x
substr$_,$i++,1/e;'x500;print$$a
-l $_=\substr$@=1x pop,0;$@="";substr($@.=$ARGV[$|--],-
1)x=substr$@,$_,1for$"..500;print$$_
-l eval'if($l=@a=/./g){$i++until($l-=$a[$i])<1}
$i=!s/$/$ARGV[($a[-1]==$ARGV[0])^!!$l]/;'x
$$a=$a=pop;$b=pop;s/(.+) (.+)/$2 $1/,$$2||=$$1&&"$2 $$1"for(<>)x2e3;print"$$b
-l map$_=pop|$$_,$b,$a;/ (.*)/,$$1=$`for<>;s/,|$/ $a,$b /;s/( .+
).+\1/$1/?print/ (.*) /:do$0
$$a=$a=pop;$b=pop;/(.+) (.+)/,$$2||=$$1&&"$2 $$1",$$1||=$$2&&"$1
$$2"for(@F=<>)x@F;print"$$b
95, mtve (would be rejected after 2.5 years, due to $ARGV problem) 
-lp INIT{$0=pop;$x=pop}/ /,${$'}=$`}{s/.+/${$&}/guntil$_="$x
INIT{$l=pop;$c=pop}%r=%R=reverse@F;0while$R{$c}=$p,$c=$r{$p=$c};$_=$l;s//$l
/while$l=$R{$l}
-lp / /;${$'}=$`}INIT{$l=pop;$f=pop}{do{@$f=@t=(@t,$f)}while$f=$$f;s//
$l/,$l=$$l until@$l;s//@$l/
-l $_=pop|$$_ for$b,$a;/ (.*)/,$$1=$`for<>;s/0|^$/$a 0 $b/;$a|$b?do$0:s/( .+
|\bRo).+\b\1/$1/+print
-lp / /;${$'}=$`}BEGIN{$l=pop;$f=pop}{do{@$f=@t=(@t,$f)}while$f=$$f;s//
$l/,$l=$$l until@$l;s//@$l/
-l $_=pop|$$_ for$b,$a;/ (.*)/,$$1=$`for<>;s/0|^$/$a 0 $b/;$a|$b?do$0:s/( .+
|\bRo).+\b\1/$1/+print
-l $_=pop|$$_ for$b,$a;/ (.*)/,$$1=$`for<>;s/0|^$/$a 0 $b/;$a|$b?do$0:s/( .+
|\bRo).+\b\1/$1/+print
$/+=$a=pop;$b=pop;$x=<>;sub k{print"@_\n"x/^$b/;s/ *$_[0]
*//^/^$_[1]$/&&k($_,@_)for$x=~/.+$/mg}k$a
-l map$_=pop|$$_,$b,$a;/ (.*)/,$$1=$`for<>;s/,|^$/ $a,$b /,$a|$b?do$0:s/( .+
$"=/ (.+)/,$$1=$`for<STDIN>;s//@ARGV
/;s/1/ @{[map$_=$$_,@ARGV]} /until
-0 sub f{@_&&f(/(.+) @_
/),@_}$_=<STDIN>;$_=" @{[reverse(f shift),f pop]}
";s/( .+ ).*\1/$1/;s/^ | $//g;print
-p0 BEGIN{$o=pop;$i=pop}sub f{"@_",/(.+) @_$/m&&f($1)}$_=" @{[f($i),reverse
";s/( .* ).*\1/$1/;s/^ | $//g
sub f{@_&&f("@c"=~/(\S+) @_
/),@_}@c=<STDIN>;s// @{[reverse(f shift),f pop]}
/;s/( .+ ).*\1/$1/;s/^ | $//g;print
-lp / /;$b{$'}=$`}BEGIN{$l=pop;$f=pop}{{s/ ?$/ $f/;$$f=$_;redo
if$f=$b{$f}}$_='';s// $l/,$l=$b{$l}until$$l;s//$$l/
-l $t=pop;$f=pop;/
(.*)/,$$1=$`for<>;s##$f\xA3$t#;while(($t=$$t)|($f=$$f)){s#\xA3# $f\xA3$t
#}s#( .+ |\bRo).+\b\1#$1#;print
-lp0 INIT{@a=pop;@b=pop}for$x(\@a,\@b){push@$x,$1while/(.+) $$x[-
1]$/m}pop@a;$_="@{[@b,reverse@a]}";s/( .+ ).*\1/$1/
-lp0 BEGIN{$R=$r=pop;$L=$l=pop}$L.=$".($l=$1)while s/(.+) $l$//m;$R=($r=$1)."
$R"while/(.+) $r$/m;$_=$L;s/\b$r.*/$R/
-p0 INIT{$;=pop;@$=$:=pop}splice@$,++$%,0,$:while$%-=$|,$:=/(.+) $:
/?$1:$;x--$|;$_="@$
-l @g=pop;@f=pop;/ $g[0]$/?@g=($`,@g):push@f,/(.*) $f[-
1]$/for(<>)x1e3;$f="@f"=~/(.*( |^)$_)( |$)/?$1:"$f $_"for@g;print$f
-pl INIT{$;=pop;$f=pop}/ /;$;{$'}=$`}{$_=$f.$;while$f=~s/\S+$/$&
$;{$&}/+$;=~s/^\S+/$;{$&} $&/;s/(^| )(.+) .* \2($| )/$1$2$3/
-lnaF BEGIN{$d=pop;$s=pop}push@{$r{$_}},@F for@F}{sub d{print"@_"if($_=@_[-
1])eq$d;local$v{$_}=1;$v{$_}||d(@_,$_)for@{$r{$_}}}d$s
@c=<STDIN>;for(t,f){@$_=$$_=pop;push@$_,$$_=$1while"@c"=~/(\S+) $$_
/;$a{$_}++for@$_}@a=grep{$a{$_}<2or!$i++}@f,reverse@t;print"@a
-l $e=pop;@c=pop;chop(@h=<>);for$c(@c){$c=~/\S+$/;$p=$&;map{push@c,"$c
$m",$_=''if/ /,$m=$`eq$p?$':$' eq$p&&$`}@h}print+(grep/$e/,@c)[0]
-l /(.*) (.*)/,$t{$2}=$1for<STDIN>;$r='Roma';sub
k{@x=($x=pop);push@x,$x=$t{$x}while$x ne$r;@x}@j=(k(shift),reverse k
pop);for$l(@j){@_=@j[$p+1..@j];if(grep/^$l$/,@_){do{splice@j,$p,1}until$j[$p
]eq$l}++$p}print
join' ',@j
$$a=$a=pop;$b=pop;s/(.+) (.+)/$2 $1/,$$2||=$$1&&"$2 $$1"for(<>)x2e3;print"$$b
-l map$_=pop|$$_,$b,$a;/ (.*)/,$$1=$`for<>;s/,|$/ $a,$b /;s/( .+
).+\1/$1/?print/ (.*) /:do$0
$$a=$a=pop;$b=pop;/(.+) (.+)/,$$2||=$$1&&"$2 $$1",$$1||=$$2&&"$1
$$2"for(@F=<>)x@F;print"$$b
95, mtve (would be rejected after 2.5 years, due to $ARGV problem) 
-lp INIT{$0=pop;$x=pop}/ /,${$'}=$`}{s/.+/${$&}/guntil$_="$x
INIT{$l=pop;$c=pop}%r=%R=reverse@F;0while$R{$c}=$p,$c=$r{$p=$c};$_=$l;s//$l
/while$l=$R{$l}
-lp / /;${$'}=$`}INIT{$l=pop;$f=pop}{do{@$f=@t=(@t,$f)}while$f=$$f;s//
$l/,$l=$$l until@$l;s//@$l/
-l $_=pop|$$_ for$b,$a;/ (.*)/,$$1=$`for<>;s/0|^$/$a 0 $b/;$a|$b?do$0:s/( .+
|\bRo).+\b\1/$1/+print
-lp / /;${$'}=$`}BEGIN{$l=pop;$f=pop}{do{@$f=@t=(@t,$f)}while$f=$$f;s//
$l/,$l=$$l until@$l;s//@$l/
-l $_=pop|$$_ for$b,$a;/ (.*)/,$$1=$`for<>;s/0|^$/$a 0 $b/;$a|$b?do$0:s/( .+
|\bRo).+\b\1/$1/+print
-l $_=pop|$$_ for$b,$a;/ (.*)/,$$1=$`for<>;s/0|^$/$a 0 $b/;$a|$b?do$0:s/( .+
|\bRo).+\b\1/$1/+print
$/+=$a=pop;$b=pop;$x=<>;sub k{print"@_\n"x/^$b/;s/ *$_[0]
*//^/^$_[1]$/&&k($_,@_)for$x=~/.+$/mg}k$a
-l map$_=pop|$$_,$b,$a;/ (.*)/,$$1=$`for<>;s/,|^$/ $a,$b /,$a|$b?do$0:s/( .+
$"=/ (.+)/,$$1=$`for<STDIN>;s//@ARGV
/;s/1/ @{[map$_=$$_,@ARGV]} /until
-0 sub f{@_&&f(/(.+) @_
/),@_}$_=<STDIN>;$_=" @{[reverse(f shift),f pop]}
";s/( .+ ).*\1/$1/;s/^ | $//g;print
-p0 BEGIN{$o=pop;$i=pop}sub f{"@_",/(.+) @_$/m&&f($1)}$_=" @{[f($i),reverse
";s/( .* ).*\1/$1/;s/^ | $//g
sub f{@_&&f("@c"=~/(\S+) @_
/),@_}@c=<STDIN>;s// @{[reverse(f shift),f pop]}
/;s/( .+ ).*\1/$1/;s/^ | $//g;print
-lp / /;$b{$'}=$`}BEGIN{$l=pop;$f=pop}{{s/ ?$/ $f/;$$f=$_;redo
if$f=$b{$f}}$_='';s// $l/,$l=$b{$l}until$$l;s//$$l/
-l $t=pop;$f=pop;/
(.*)/,$$1=$`for<>;s##$f\xA3$t#;while(($t=$$t)|($f=$$f)){s#\xA3# $f\xA3$t
#}s#( .+ |\bRo).+\b\1#$1#;print
-lp0 INIT{@a=pop;@b=pop}for$x(\@a,\@b){push@$x,$1while/(.+) $$x[-
1]$/m}pop@a;$_="@{[@b,reverse@a]}";s/( .+ ).*\1/$1/
-lp0 BEGIN{$R=$r=pop;$L=$l=pop}$L.=$".($l=$1)while s/(.+) $l$//m;$R=($r=$1)."
$R"while/(.+) $r$/m;$_=$L;s/\b$r.*/$R/
-p0 INIT{$;=pop;@$=$:=pop}splice@$,++$%,0,$:while$%-=$|,$:=/(.+) $:
/?$1:$;x--$|;$_="@$
-l @g=pop;@f=pop;/ $g[0]$/?@g=($`,@g):push@f,/(.*) $f[-
1]$/for(<>)x1e3;$f="@f"=~/(.*( |^)$_)( |$)/?$1:"$f $_"for@g;print$f
-pl INIT{$;=pop;$f=pop}/ /;$;{$'}=$`}{$_=$f.$;while$f=~s/\S+$/$&
$;{$&}/+$;=~s/^\S+/$;{$&} $&/;s/(^| )(.+) .* \2($| )/$1$2$3/
-lnaF BEGIN{$d=pop;$s=pop}push@{$r{$_}},@F for@F}{sub d{print"@_"if($_=@_[-
1])eq$d;local$v{$_}=1;$v{$_}||d(@_,$_)for@{$r{$_}}}d$s
@c=<STDIN>;for(t,f){@$_=$$_=pop;push@$_,$$_=$1while"@c"=~/(\S+) $$_
/;$a{$_}++for@$_}@a=grep{$a{$_}<2or!$i++}@f,reverse@t;print"@a
-l $e=pop;@c=pop;chop(@h=<>);for$c(@c){$c=~/\S+$/;$p=$&;map{push@c,"$c
$m",$_=''if/ /,$m=$`eq$p?$':$' eq$p&&$`}@h}print+(grep/$e/,@c)[0]
-l /(.*) (.*)/,$t{$2}=$1for<STDIN>;$r='Roma';sub
k{@x=($x=pop);push@x,$x=$t{$x}while$x ne$r;@x}@j=(k(shift),reverse k
pop);for$l(@j){@_=@j[$p+1..@j];if(grep/^$l$/,@_){do{splice@j,$p,1}until$j[$p
BEGIN{$^H<<=map$~.=$_%5&&pop,0..76}s/./.{1,3}(.{5}){6,8}$&/g;$_="$`"x($~x17)
=~/$_.*(??{grep$c{$_%38}++,%c=@+})/x
BEGIN{$^H=1<<map$~.=$_%5&&pop,0..20}s/./(.{5}){4,6}$&.{0,2}/g;$_="$`"x($~x17
)=~/$_.?(??{grep$c{$_%27}++,%c=@+})/x
sub f{$\=~/@ARGV[@_]$/x&&!$`|grep!@_|abs"@_"-~$_<6&abs"@_"%4-
~$_%4<2&"@_"!~~$_&&f(~$_,@_),0..15}f&&print while$\=<STDIN>
-p INIT{\$$_{--$=*5>>2}while$_=pop}sub b{local$p=-
$_.$p;!@_!=grep$p!~$_&&b(@_)&($_+$p)=~/$_|\b[1456]$/,%{+pop}}$_ x=b/./g
print grep{@a=0;@a=map$&eq$ARGV[$n=$_]?map$_&&/ $n /|1<abs$n%4-$_%4|5<abs$n-
$_?@0:" $n $_",@a:@0,0..15while/./g;@a}<STDIN>
-p INIT{push@$_,--$=*5>>2while$_=pop}sub b{local$p=-
$_.$p;!($n=pop)!=grep$p!~$_&($_+$p)=~/$_|\b[1456]$/&b(@_),@$n}$_ x=b/./g
-p INIT{push@$_,32|$;++/4+$;while$_=pop}sub
b{my($p,$n,@L)=@_;!$n|!!grep$p!~$_&b("$_ $p",@L)&($_-
$p)=~/$_|\b[1456]$/,@$n}$_ x=b/^|./g
sub r{my$i;map{$_=$l++,r($i-1),$_=$b[--$l]if(abs$i-"@_"<6&abs$i++%4-
"@_"%4<2|!$l)&$b[$l]eq$_}@ARGV;$f|=$l==@b}@b=/./g,r&&print,$f=0for<STDIN>
sub f{my($l,$x,@s)=($_,@_);grep{local@u=@u;!@u|abs($l%4-$_%4)<2&abs($l-
$_)<6&&$ARGV[$_]eq$x&!$u[$_]++&&!@s|f(@s)}0..15}print grep{f/./g}<STDIN>
sub c{@_<3||grep$_[1]eq$ARGV[$_]&abs$_%4-$_[0]%4<2&abs$_-
$_[0]<6&&c(local$ARGV[$_]=$_,@_[2..$#_]),0..15}print
grep{split//;grep{c$_,@_}0..15}<STDIN>
push@{$z{pop||$/}},int$_/.8for-19..0;sub
r{local$_=$_;for$d(@{$z{$f&&=chop}}){r(local$c=$d,$d-
=25),$d+=25if!$c|1<<$c+6-$d&7335}$f}$f=1,r||print for<>
sub k{my($a,$b,$i)=@_;ord==ord$a&(!$#_|2>abs$i%4-$b%4&6>abs$i-
$b)&&($_=uc,k(substr($a,1),$i),$_=lc),$i++for@ARGV;$s|=$a!~/./}print
grep{$s=0,k$_}<STDIN>
-naF// INIT{@a=splice@ARGV}sub
g{my$n=$_;if((E^$F[$i++])eq($a[$n]^=E)){$.*=$#F!=$i;(abs($_-
$n)>5|abs(($n&3)-($_&3))>>1or&g)for@I}$a[$n]^=E;$i--}g for@I=0..42;$.||print
push@L,shift,++$x%4&&()for%::;for$w(<>){map(f($_,$w),0..18)&&print$w}sub
f{my($p,$w)=@_;$w!~s/.//||$p>=0&&$L[$p]eq$&&&!local$L[$p]&&map f($p+$_,$w),-
sub r{my($c,$R)=@_;$ARGV[$c]ne chop$R?():local$ARGV[$c]|$R?map{r($c+$_,$R)}(-
5,-1,3)x($c%4),-4,4,(-3,1,5)x($c%4!=3):1}$#ARGV=42;map{print if
map{r$_,$`}(!/$/..15)}<STDIN>
-p sub n{local$b[$s=pop];local@f=map{$_+$s,$s-
$_}1,4,5,6;!($l=shift)||&p}INIT{@b=((1)x5,map{$_%4&&(),pop}0..15)}($l,@_)=/.
/g;@f=0..@b;$_ x=!!&p;sub p{map{n@_,$_}grep$b[$_]eq$l,@f}
-n BEGIN{1while($a[$i++/4*5]=pop)}sub
R{my($i,@a)=@_;ord($a[$i]^=$s[$j++])?$j<@s?0:print pop@x:map{R($i+$_,@a)}(-
6..-4,-1,1,4..6);--$j}@x=$_;@s=split//;$#a=$i=30;R($i,@a)while($i--)
d{my($p,$w,@l)=@_;if($w=~s/^$l[$p]//){$l[$p]=0;print($o),$o=''if$/eq$w;d($p+
$_,$w,@l)for-6..-4,-
1,1,4..6}}while($o=<STDIN>){d$_,$o,(0,@ARGV)[1..4,0,5..8,0,9..12,0,13..16,(0
-ln BEGIN{map$b.=pop,1..16}sub r{local($_,$c,$d)=($_,$d);for$l(chop
or$f=0){until(($d=index$b,$l,$d)<0){(0,$w=4&(~$c^$d),0,!$w,1,!$w)[$c+1?abs$c
-$d:4]&&r(substr(local$b=$b,$d)^=A),$d++}}$f}$d=$f=-1,r||print
I:for(<STDIN>){for$y(0..3){for$x(0..3){t($y,$x,$_,@ARGV)&&print&&next I}}}sub
t{my($y,$x,$w,@g)=@_;${for$Y(-1..1){for$X(-
1..1){t($y+$Y,$x+$X,$w,@g)|!$w&&return
1}}}if($;=chop$w)eq$/|!(($x|$y)&4)&$g[$y*4+$x]=~s/$;/_/}
($i="@ARGV")=~s/(.{5} .)/ $1/g;sub i{my($l,$r,$j,$i)=($_[0]=~/(.)(.*)/)or
print,next i;$_[2]&&($i-$_[2])!~/^-
?(2|7|9|11)$/||(substr($j=$_[1],$i,1)=0,i($r,$j,$i))while($i=index$_[1],$l,+
+$i)>0}i:while(<STDIN>){i$_,$i}
INIT{(@g,@ARGV)=@ARGV}$i=!pop@F;for$@(@F){@;=$i++?map{/\d+/;map$g[$;=$&+$_]e
q$@&$;>-1&!(1+index$'," $; ")?"$; $& $'":(),$&%4>2?(-5,-4,-1,3,4):$&%4?(-
5..-3,-1,1,3..5):(-4,-3,1,4,5)}@;:grep$g[$_]eq$@,0..@g}$_=""if!@
-n INIT{@a=@ARGV;@ARGV=()}sub f{if($_[0]-(@w=/./g)){for
my$i(0..$#a){if($a[$i]eq$w[$_[0]]&&!$f{$i}){local$f{$i}=1;if($_[1]==-
1||(($b=abs$i-
$_[1])!=2&&$b<6&&!(($i%4==0&&$_[1]%4==3)||($i%4==3&&$_[1]%4==0)))){f($_[0]+1
,$i)}}}}else{$m++||print}}f($m=0,-1)
-l for(0..15){$r=$_%4;my@a;if($_>3){push@a,$_-4;push@a,$_-5if$r;push@a,$_-
3if$r!=3}push@a,$_-
1if$r;push@a,$_+1if$r!=3;if($_<12){push@a,$_+4;push@a,$_+3if$r;push@a,$_+5if
$r!=3}$v[$_]=\@a}W:for(<STDIN>){chomp;@n=map{[$_]}0..15;for$l(split//,$_){my
@e;for$r(@c=grep{$ARGV[$_->[-1]]eq$l}@n){@a=@{$r};for$c(@{$v[$a[-
1]]}){push@e,[@a,$c]unless grep/^$c$/,@a}}@n=@e;next W unless@c}print}
-paF^...| $a[$`]=@;[@a[@F]]-=@;=$&+s/ .*/$"x@;."-"x$&/e*@
-pa $a[$`]=@;[@a[@F[2..9]]]-=@;=$&*s/ .*/$"x@;."-"x$&/e+@
-pa \@F[@a[@F[2..9]]];$a[$_]=$&- s/ .*/$"x$#F."-"x$&/e+@F
-lpa \@;[@e[@F[2..9]]];@;=$e[$_=$..$"x@;."-"x$']=$'-/ /+@
-pa \@;[@a[@F[2..9]]];@;=$a[$`]=$&- s/ .*/$"x@;."-"x$&/e+@
-lpa \@q[@e[@F[2..9]]];@q=$e[$_=$..$"x@q."-"x$']=@q-/ /+$'
-lpa \@F[@e[@F[2..9]]];$e[$.]=@F-/ /+$';$_=$..$"x$#F."-"x$'
-lpa @s=++$a;\$s[@$_]for/^...|./g;$_="@s ".'-'x$F[1];@$a=//g
-ap @a=!s! .*!\@a[@p{@F[2..9]}];$p{$`}=$#a+$&;" @a".'-'x$&!e
-pa s^ .*^(sort@L[@F[2..9]],b)[8].a
x$&^e;$L[$.]=b
-pl $a[$.]|=$"x$a[chop]=~y///cwhile/ . /;s/.$/$a[$.].="-"x$&/e
-lpa @q=/ /;\@q[@e[@F[2..9]]];$e[$_]=$#q+$';$_=$..$"x@q."-"x$'
-pla ($m,$n,@f)=@F;$m|=$_&$"x70for@l[@f],pp;$_=$l[$.]=$m.'-'x$n
-pla $e[$_="$. $n"]=($n=(sort@e[@F[2..9]])[-1]."-"x$F[1])&$"x80
-ap s# .*#$p{$`}|=$"x y///cfor@p{@F[2..9]};$".($p{$`}.='-'x$&)#e
-apl $_=(sort map"$. @$_",@F[2..9])[-1].'-'x$F[1];$#{$.}=y///c-2
-pal $h[$_="$. $x"]=$"x99&($x=(sort@h[@F[2..$#F]])[-1].'-'x$F[1])
-lp $,=s/ .//;$_>$,?$,=$_:0for@a[split];$a[$_=$`.$"x$,.'-'x$&]=$&+$,
-lpa / ./;$_="$` ".$"x(sort{$b-$a}@l[@F[2..9]])[0].'-'x$&;$l[$`]=y|||c-2
-lpa $s=(sort{$b-$a}@e[@F[2..9]])[0];$e[$_=$F[0].$"x++$s."-"x$F[1]]=$F[1]+$s
-pla $_=(sort map{$"x$g[$_-1]}@F[2..$#F])[-1]."-"x$F[1];push@g,y///c;s/^/$. /
-lna $s=(sort{$a-$b}@e[@F[2..9]])[-1];print$.,$",$"x$s,'-
'x$F[1];$e[$.]=$s+$F[1]
-lpa $s=1;map{$s=$e[$_]if$e[$_]>$s}@F[2..9];$e[$_=$F[0].$"x$s."-
"x$F[1]]=$F[1]+$s
-lna $s=0;($i,$l,@d)=@F;map{$s=$_ if$s<$_}@e[@d];print"$i ",' 'x$s,'-
'x$l;$e[$i]=$s+$l
-anl ($n,$l,@F)=@F;$m=0;map{$m=$t[$_]if$t[$_]>$m}@F;$t[$n]=$m+$l;print$n,'
'x($m+1),'-'x$l
-lna ($i,$l,@d)=@F;map{$e[$i]=$_}sort{$a-$b}@e[@d];print"$i ".' 'x$e[$i].'-
'x$l;$e[$i]+=$l
-lna my$s;map{$s=$e[$_]if$e[$_]>$s}@F[2..9];$e[$F[0]]=$s+$F[1];print$F[0]."
"x++$s."-"x$F[1]
split;$i=shift@_;$l=shift@_;my$s;map{$s=$e[$_]if($e[$_]>$s)}@_;$e[$i]=$l+$s;
print$i,(map" ",0..$s),(map"-",1..$l),"\n"
-p0 s!\w+!$_.=$=.$&;s/0$&6//?$'=~y/0//:$&!eg
-p0 s^\w+^$_.=$=.$&;s/0$&6//?$'=~y/0//:$&^ge
-p0 s!\w+!$_.=$=.$&;s/0$&6//?split 6,$':$&!eg
-p s/\w+/($a.=-$&)=~s!-$&-!-!?-$'=~y!-!!:$&/eg
-p0 s/\w+/$_.="0$&";s!0$&0!0!?split 0,$':$&/eg
-p0 s/\w+/$_.="\x00$&";s!\x00$&\x00!\x00!+$'=~y!\x00!!||$&/eg
-p0 s!\w+!$_.="$&
";s/^$&
^//m?$'=~y/
//:$&!ge
-p s!\w+!($s.=-$&)=~s#\b$&-##?-$'=~y/-//:$&!eg
-p s#\w+#($a.=" 1$&")=~s!1$& !!?$'=~y/1//:$&#ge
-p s!\w+!($/.="$&
")=~s/^$&
^//m?$'=~y/
//:$&!ge
-p s!\w+!($n.="$&,")=~s/\b$&,\b//?$'=~y/,//:$&!ge
-p s!\w+!($w.=$&.$")=~s/\b$& \b//?$'=~y/ //:$&!eg
-p s#\w+#($a.="
$&")=~s/\b$&
//?$'=~y/
//+1:$&#ge
s^\w+^($s.=_.$&)=~s/_$&_/_/?1+$'=~y/_//:$&^ge
s^\w+^($s.=$".$&)=~s/\b$& //?1+$'=~y/ //:$&^ge
-p0 s#\w+#($l.=";$&")!~s/;$&;/;/?$&:1+$'=~y/;//#eg
-p0 s!\w+!$s.=" $&";$s=~s#\b$& ##?1+$'=~y/ //:$&!eg
-p0 s#\w+#s!\b($&)\b.*\G!$&^$1!se?map/\W+/g,$&:$&#eg
-p s/\w+/$_+=~$_>~($a=$w{$&})for%w;$w{$&}=1;$a|$&/ge
s/\w+/map$_+=$_<($z=$x{$&})|!$z,%x;$x{$&}=1;$z|$&/eg
-p s/\w+/$_+=!$x|$_<($x=$M{$&})for%M;$M{$&}=1;$x|$&/ge
-p0 s#\w+#$`=~/.*\b$&\b/s?1+keys%{{$'=~/\b\w*/g}}:$&#eg
-p0 s/\w+/$_+=!$z|$_<($z=$x{$&})for%x;$x{$&}=1;$z|$&/eg
-p s/\w+/$*=$h{$&};$_+=$_<$*|!$*for%h;$h{$&}=1;$*|$&/eg
-p s/\w+/$_+=!($,=$w{$&})||$_<$,for%w;$w{$&}=1;$,||$&/ge
-p s/\w+/$H=$w{$&};map$_+=$_<$H|!$H,%w;$w{$&}=1;$H|$&/ge
-p s/\w+/$H=$w{$&};map$_+=$_<$H|!$H,%w;$w{$&}=1;$H or$&/ge
-p s/\w+/$_+=$_<($x=$M{$&})for%M;$M{$&}=++$w;$x?$w-$x:$&/ge
-p s#\w+#$x=keys%{$M{$&}};$M{$&}={};++$_->{$&}for%M;$x||$&#eg
-p s%\w+%$i=$j=0;@a=($&,grep++$i*!s/^$&$/$j=$i/e,@a);$j||$&%eg
-p0 s#\w+#my%s;$`=~/.*\b$&\b/s?grep!$s{$_}++,$'=~/\w+|/g:$&#eg
-p s'\w+'@a{@a=($&,@a)}=0..@a;splice@a,$i,1if$i=$a{$&};$i||$&'ge
-p0 s/\w+/map{$_++if!($z=$x{$&})||$_<$z}values%x;$x{$&}=1;$z||$&/eg
-p0 s/\w+/map{$_++if!($z=$x{$&})||$_<$z}values%x;$x{$&}=1;$z||$&/eg
-p0 s#(.*((\b(\pL|_)+)\b.*))\b\3\b#"$1".(@a=$2=~/[A-Za-z_]+/g)#es&&do$0
-p0 s#(\w+)(?=(.*?\b\1\b))?#$x=keys%$1||$1;%$1=map{$_,1}$2=~/(\w+)/g;$x#ges
-p s/\w+/(($a=(grep{$x[$_]eq$&}1..unshift@x,$&)[0])&&splice@x,$a,1)?$a:$&/eg
s#(.*)(\b[\pL_]+\b)(.+)\b\2\b#"$1$2$3".keys%{{split/([\W\d]+)/,$3}}#se&&redo
-alp0 s!.+!$;[map%$z,@$z{$&,$_}]=$z=$_.$&for@F!eg;$_=pop@
-alp0 s!.+!$;[@$z{$&,$_}=%$z]=$z=$_.$&for@F,@F!eg;$_=pop@
-lp0a $"='|'while$_=$x++,s/.//,grep$'!~/^$_(@F)$|^(@F)$_$/,@F
-p0a $_="$F[$?+=!++$^C]$F[$^C]
"while~-2**@F^($$_|=2**$?|2**$^C)
-ap0 $_="$F[$i=$j]$F[$j=rand@F]
"until($$_|=1<<$i|1<<$j)+1>>@F
-ap0 @F=sort{rand 2}@F until$_="@F ",s! !$/x$|--!eg,/
/,s/^$'//
-lap0 s#.+#$_[$_{$^G=$_.$&}+=map$^G=~/$_/,@F]=$^Gfor@F#eg;$_=pop@_
-ap0 }{@F=sort{$_.="$a$b
"x2;rand 2}@F until($_)=/^(.+
)\1{$#F}/
-alp0 sub f{splice@F,rand@F,1}$;=f.f;$;eq f.f||redo while@F;$_=$
-lp0a s/.+/ @{[map"$&$_ $_$&",@F]} /g;($_)=/(\d+)(.*
.* \1 )*.*$/
-lap0 s#.+#$_[$_{$^G=$_.$&}-=/$&/-map$^G=~/$_/,@F]=$^Gfor@F#eg;$_=pop@_
-lp0a $"='|',$_=glob"{,0,1}"x9until//>grep$'!~/^(@F)$_$|^$_(@F)$/,@F
-lap0 for$f(@F){\@{$_.$f}{\$_,\$f}for@F}($_)=grep/\d/&@F==keys%$_,%::
-lp0a $"=',',$_=<{@F}{@F}>until$"='|',//>grep$'!~/^(@F)$_$|^$_(@F)$/,@F
#for$a(@F){$\=$a.$&if!grep{(${$a.$&}.="$a
$&")!~/\b$_
/}@F}#eg
-0ap $_=(map{$i=$_;map{$j=$_;grep/$i/&&++$k{$_}>2*$#F,map$_.$j,@F}@F}@F)[0]
-lp0a *$_=\(sort{"1$a"-"1$b"}@F)[$_-3]for 1..4;"$3$2 $2$3"=~/$4$1|$1$4/;$_=$&
-lp0a for$=(@F){@;=map{$*=$_;grep$*eq$_,@;?@;:@*}@*=map{$_.$=,$=.$_}@F}$_=pop@
-lp0a for$=(@F){@;=grep{$*=$_;grep$*eq$_,@;?@;:@*}@*=map{$_.$=,$=.$_}@F}$_=pop@
-l chomp(@a=<>);0until($a{$_=$a[$i=$j].$a[$j=rand@a]}|=1<<$i|1<<$j)+1>>@a;print
for$=(@F){@;=grep{$*=$_;grep$*eq$_,@;?@;:@*}@*=map{$_.$=,$=.$_}@F}$_=pop@
$"="|";($_)=map{//;map{($t=$'.$_)x!grep$t!~/^$_(@_)$|^(@_)$_$/,@_}@_}@_=spli
\@H{@F};$"=',';for$s(glob"{@{[keys%H]}}"x2){$a=$h{$s}+=grep$s=~$_,@F;$m=$a
if$a>$m}$_={reverse%h}->{$m}
for$"(@_=split){$l+=length$";$h{$".$_}+=$_.$"eq$".$_?0:1for@_}$_=(sort{$h{$b
}<=>$h{$a}}grep{$l/@_*2==length}keys%h)[0]
@X=split;for$i(0..$#X){for(0..$#X){$Y{$X[$i].$X[$_]}++if$i^$_}}z:while(($",$
d)=each%Y){for(@X){next z if$"!~/$_/}$a=$d,$_=$"if$d>$a}
@X=split;for$i(0..$#X){for(0..$#X){$Y{$X[$i].$X[$_]}++if$i^$_}}z:while(($",$
d)=each%Y){for(@X){next z if$"!~/$_/}$a=$d,$_=$"if$d>=$a}
-lp0aF/\n/ sub f{B:while(@_){$s=pop;for$i(@_){$t=pop;next B
if/^($s$t|$t$s)$/;@_=($t,@_)}return}last}$a=pop@F;while(@F){$b=pop@F;$_=$a.$
b;f@F;$_=$b.$a;f@F;@F=($b,@F)}
@X=split;$K=9;for$;(@X){$,=length$;;$K=$,if$,<$K;$G=$,if$,>$G;$Y{$;.$_}++for
(@X)}z:while(($",$d)=each%Y){for(@X){next z
if$"!~/$_/}$a=$d,$_=$"if$d>$a&&length($")==$K+$G}
-lp0 $"="";@i=split;@p=f($#i,@i);$_="@p";sub
f{my($c,$a,$b,@i)=@_;if(@i){($x,$y)=f($#i,@i);(($a.$b)=~/^($x$y|$y$x)$/)?($a
,$b):(($b.$a)=~/^($x$y|$y$x)$/)?($b,$a):$c+1?f($c-
1,$a,@i,$b):()}else{$a,$b}}
-lp0 $"="";@i=split;($p,$q)=f($#i,@i);$_=$p.$q;sub
f{my($c,$a,$b,@i)=@_;if(@i){($x,$y,$z)=f($#i,@i);(($x.$y)=~/^($a$b|$b$a)$/)?
($x,$y):$z&&(($y.$x)=~/^($a$b|$b$a)$/)?($y,$x):$c?f($c-
1,$a,@i,$b):()}else{$a,$b,1}}
-lp0 $"="";@i=split;($p,$q)=f($#i,@i);$_=$p.$q;sub
f{my($c,$a,$b,@i)=@_;if(@i){($x,$y,$z)=f($#i,@i);(($x.$y)=~/^($a$b|$b$a)$/)?
($x,$y,$y.$x eq reverse $1):$z&&(($y.$x)=~/^($a$b|$b$a)$/)?($y,$x):$c?f($c-
1,$a,@i,$b):()}else{$a,$b,1}}

char*_ = "'""/*";
#include <stdio.h>
#define m 21
#define o(l, k) for(l=0; l<k; l++)
#define n(k) o(T, k)


              int E,L,O,R,G[42][m],h[2][42][m],g[3][8],c
              [42][42][2],f[42]; char d[42]; void v( int
              b,int a,int j){ printf("\33[%d;%df\33[4%d"
              "m  ",a,b,j); } void u(){ int T,e; n(42)o(
              e,m)if(h[0][T][e]-h[1][T][e]){ v(e+4+e,T+2
              ,h[0][T][e]+1?h[0][T][e]:0); h[1][T][e]=h[
              0][T][e]; } fflush(stdout); } void q(int l
                            ,int k,int p){
                            int T,e,a; L=0
                            ; O=1; while(O
                            ){ n(4&&L){ e=
                            k+c[l] [T][0];
                            h[0][L-1+c[l][
                            T][1]][p?20-e:
e]=-1; } n(4){                                          e=k+c[l][T][0]; a=L+c[l][T][
1]+1; if(a==42                                          || h[0][a][p?20-e:e]+1){ O=0
; } } n(4){ e=                                          k+c[l][T][0]; h[0][L + c[l][
T][1]][p?20-e:                                          e]=g[1][f[p?19+l:l]]; } L++;
u(); } n(42) {                                          o(e,m)if(h[0][T][e]<0)break;
o(a, m&&e==m){                                          for(L=T; L; L--) { h[0][L][a
]=h[0][L-1] [a                                          ]; } h[0][0][a]=-1; } } u();
}int main(){ int T,e,t,r,i,s              ,D,V,K; printf("\33[2J\33[?25l"); n(8)g[i=
1][T]=7-T; R--; n(42) o(e,m)              G[T][e]--; while(fgets(d,42,stdin)) { r=++
R; n(17){ e=d[T]-48; d[T]=0;              if ((e&7)==e) { g[0][e] ++; G[R][T+2]=e; }
} } n(8)if(g[0][7-T]){ t=g[i              ][O]; g[i][O++]=g[i][T]; g[i][T]=t; } n(8)
g[2][g[i][T]]=T; n(R+i)o(e,m              )if(G[T][e]+i) G[T][e]=g[2][G[T][e]]; n(19
)o(t,2){ f[T+t+T]=(T["+%#,4"              "5>GP9$5-,#C?NX"]-35)>>t*3&7; o(e,4){ c[T]
[e][t]=("5'<$=$8)Ih$=h9i8'9"              "t=)83)l4(99(g9>##>4(" [T+t+T]-35)>>e*2&3;
} } n(15) { s=T>9?m:(T&3)-3?15:36;o(e,s)o(t,2)c[T+19][e][t]="6*6,8*6.608.6264826668\
865::(+;0(6+6-6/8,61638065678469.;88))()3(6,8*6.608.6264826668865:+;4)-*6-6/616365,\
-6715690.5;,89,81+,(023096/:40(8-7751)2)65;695(855(+*8)+;4**+4(((6.608.626482666886\
5:+;4+4)0(8)6/61638065678469.;88)-4,4*8+4(((60(/6264826668865:+;4-616365676993-9:54\
+-14).;./347.+18*):1;-*0-975/)936.+:4*,80987(887(0(*)4.*""/4,4*8+4(((6264826668865:\
+;4/4-4+8-4)0(8)6365678469.;88)1/(6*6,6.60626466686:8)8-8*818.8582/9863(+;/""*6,6.6\
0626466686:4(8)8-8*818.8582/9863(+;/,6.60626466686:8-818.8582/9864*4+4(0())+;/.6062\
6466686:8/8380/7844,4-4*4+4(0())69+;/0626466686:818582/9864.4/4,4-4*4+4(0())+;" [e+E
+e+t]-40; E+=s+s; } n(45){ if(T>i) { v(2,T,7); v(46,T,7); } v(2+T,44,7); } T=0; o(e,
42)o(t,m)h[T][e][t]--; while(R+i) { s = D=0; if (r-R) { n(19) if (G[R+i][T]+i) V=T/2
; else if(G[R][T]+i) s++; if(s) { if(V>4){ V=9-V; D++; } V+=29; n(20) q(c[V][T][0],c
[V][T][i],D); } } n(19) if((L=G[R][T])+i) { O=T-L; e=O>9; t=e?18-O :O; o(K,((t&3)-3?
16:37)){ if(K){ L=c[t+19][K-i][0]; O=c[t+19][K-i][i] ; } q(L,O,K && e); } } if(s) q(
c[V][20][0], c[V][20][i], D); R--; } printf("\33[47;1f\33[?25h\33[40m"); return 0; }

#include <stdlib.h>
#include <curses.h>
#include <time.h>
#include <X11/Xlib.h>
#include <X11/keysym.h>
#define F(x,y,w,h,c) G(c),XFillRectangle(A,B,D,x,y,w,h),G(3)
#define G(c) XSetForeground(A,D,C[c].pixel)
#define H(d) addch(y?y-e?ACS_VLINE:ACS_L##d:ACS_U##d)
#define I(i,c) init_pair(i,COLOR_##c,COLOR_##c)
#define J(a,b) j==X[(int[]){ KEY_##b,XK_##a} ]
#define K(q,r,s,t,u,v,w) (q=!!(w)*z[p v]>>8,(1<<(3*!!((((r)>>t)^(s))&u)))*!!q)
#define L z[p=rand()&63]

int c[9],e,f,g,               h,i,j,k,l,m,n,q               ,r,s,t,u,v,w,x,
y,X, z[64]; GC                D; Display * A;               Window B;  char
o[]="tdpsf\73!"               "&e!&e!&e\1",*Y               =o,b[64];XColor
C[8]; XEvent E;               int  R  (  )  {               XDrawString(A,B
,D,348,58, b, e               ); XNextEvent (               A, &E);  return
XLookupKeysym(&               E.xkey,0)*! (E.               type^KeyPress);
} void P(){ g =               DefaultScreen((               A=XOpenDisplay(
               0 ) ) ) ;   do                XAllocNamedColor
               (    A       ,                DefaultColormap(
               A,g),5*x+"#fff"               "\0#f00\0#0f0\0"
               "#000",C+x,C+4)               ; while(++x^4) ;
               XMapWindow(A,B=              XCreateSimpleWindow
               (A,RootWindow(A               ,g),0,0,460,300
               ,0, C[3].pixel,               C->pixel ) )  ;
XSelectInput(A,               B,KeyPressMask|               ExposureMask);D
=XCreateGC(A,B,               0,0); } void a(               ){ for(y=0; y<=
e; y++)if(X)for               (x=k; y%3==0&&y               ^e&&x<k+t; x+=6
)XDrawRectangle               (A,B,D,3+6*x,6+               12 *y, 36, 36);
else{ move(y,k)               ; H(LCORNER ) ;               for(x=0; ++x^t;
)addch(x%6?y%3?               32:ACS_HLINE: y               &&y-e?ACS_VLINE
: ACS_HLINE)  ;               H(RCORNER); } }               void  Q  ( )  {
               initscr ( )   ;               start_color( );
               keypad(stdscr,1               ); curs_set(0);
               I(1, RED); I(2,               GREEN ) ; I(3 ,
               WHITE); } void                d(){ for(k=!x ;
               k^t; X?F(u,v,6,               12,i):mvaddch(v
               ,u,32|COLOR_PAIR              (i))){ u=X+(1+5
               *X)*(x+((i=~e?!               !e*((((e-1)>>k)
&1)+1):3)>2?4:1               )*(k/2)); v=X+(               1+11*X)*(1+3*y+
k++%2); } } int               S(){ mvaddstr(t               ,58,b); refresh
();return getch               (); } int main(               int p,char**V){
((X=*++V&&**V==               88)?P:Q)(); for               (srand(time(0))
; ( *Y++)--; );               for(f=++n; k^64               ; !L&&(z[p]=++k
)); L|=*z<<8; g               =p&7; h = p /8;               for(--l; j^113;
J(Up,UP) ? m?h?               h--:1:w?w--:i:J               (Down,DOWN)?m?h
               ^7?h++: r :w^7?               w++:l: J( Left,
               LEFT)?m?g?g--:3               : 7 : J (Right,
               RIGHT)?m ? g^7?               g++:9:s:j==10||
               J(Return,ENTER)               ?m?z[p=8*h+g]>>
               8?m--:((((r=K(x               ,x-1,l,t,3,-1,g
               )+K(y,l,y-1,t,3               ,+1,g^7)+K(i,i-
               1,l,1,21,-8,h)+               K(e,l,e-1,1,21,
+8,h^7))+3)&~3)               ==k)?z[p]|= ++l               <<8,c[w]=0, l=~
--m, s += r * (               ")%##!!!!"[--q]               -33),f++:m:c[w]
?l=c[w]-!m++:n^               64?c[w]=z[n++]&               127,q++:X:k){ p
=k=X&&!(F(0, 0,               460,300,0)); t=               48; e=24; a( );
k=t+2; t/=8; a(               ); e=3; k+=8; a               (); for(; p^64;
j^7?(void)j:d()               ){ x=2+t*(j=p%8               ); y=p/8; e=z[p
++]>>8; d( ); x               +=8; e =c[y]; }               x+=8; y=0; e=l+

1; d() ; x+=m*(t*g-50)-9; y=m?h:w; t-=2; e=-1; d(); e=sprintf(b,o,s,f,(f*s)
                 >>6); j=(X?R:S)(); } return X||endwin(); }

#include<stdio.h>
#include<stdlib.h>
#include<ctype.h>

int u,z,q[0400],O[0x101],o[0401],I[257],w[258][0403],W[0x100],Z[0x103],c[0403],k
,i,j,n,l,p,m;const char*J[0416],*M[0400];FILE*K[280],*s[0x102];void f(char*n,int
a){char*e=n;while(*e!='\0'){if(tolower((int)*e)!=*e)fputc(040,stderr);fputc((*e)
-a,stderr);e+=1;}(void)fputc('\n',stderr);}int y(int a,int b);int t(int i,int j)
{int k=i&j,l=i^j,n,m=1;for(n=1;k>=n;n<<=1)if(k&n)m=y(m,1<<n|1<<(n-1));return m>1
?y(m,1<<l):1<<l;}int y(int a,int b){int n,i=0x0,j;if((n=w[a][b]))return n;for(;a
>>i;++i)for(j=0x0;b>>j;j++)if(((a>>i)&1)&&((b>>j)&1))n^=t(i,j);return w[a][b]=w[
b][a]=n;}void a(void){for(i=0;i<z;i++){n=0;if(!i[I]){for(j=0;j<u;++j)if(i[O]==q[
j])n=Z[j];}else for(j=0;j<u;j++)n^=w[Z[j]][w[I[i]][W[w[o[j]][O[i]^q[j]]]]];c[i]=
n;}}void X(int v,int u){char*y=0;v-=1;switch(v){case(0x2):y ="HckngfVqQrgpKprwv"
"Hkng"; BC(4):y="JempihXsStirMrtyxJmpi"; BC(0):y="PointValueTooLarge"; BC 0x1:y=
"EvqmjdbufJoqvuQpjou";BC(6):y="TuOtv{zLorky";BC(3):y="WrrPdq|RxwsxwSrlqwv";BC(5)
:y="GfiFwlzrjsyX~syf}"; BC(07):y="UvV|{w|{Mpslz";}if(u)exit(0); f(y,v);exit(1);}
int main(int t,const char*T[]){for(i=00;i<0x100;++i)for(j=0;j<=i;++j)if(1==y(i,j
))W[i]=j,W[j]=i;for(k=0x1;k<t;k++){p=0;for(l=0;(T[k][l]>=toupper('0'))&&(T[k][l]
<=tolower('9'));l++){p=p*10+(T[k][l]-'0');if(p>=256)X(1,0);}if(T[k][l]=='-'){for
(m=0;m<u;m++)if(q[m]==p)X(2,0);q[u]=p;J[u]=T[k]+l+1;K[u]=fopen(J[u],"r");if(!u[K
])X(3,0);u++;}else if(T[k][l]=='+'){if(z>=256)X(4,0); O[z]=p;M[z]=T[k]+l+1;s[z]=
fopen(M[z],"w");if(!s[z])X(5,0);z++;}else X(6,0);}if(!(u!=0))X(7,0);if(!(z!= 0))
X(8,0);for(i=0;i<u;i++){n=1;for(j=0;j<u; j+=1)if(j!=i)n=w[n][q[i]^q[j]];o[i]=n;}
for(i=0;i<z;i++){n=1;for(j=0;j<u;j++)n=w[n][O[i]^q[j]];I[i]=n;}while(!(0)){for(k
=0;k<u;k++){int n;n=getc(K[k]); if(n==EOF)X(42,1); Z[k]=n;}a();for(k=0;k<z;k++)(
void)putc(c[k],s[k]);}X(11,1);}
