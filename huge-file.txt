Bacon ipsum dolor amet excepteur pancetta ut aute pork chop. Quis consectetur meatloaf bacon landjaeger, minim ut eu ad esse pancetta kielbasa excepteur. Shank sint aliqua cillum strip steak shankle kevin swine flank,
shoulder elit. Meatloaf beef ribs laboris, tenderloin in t-bone prosciutto. Leberkas velit adipisicing, tri-tip rump filet mignon officia ut in bacon chicken ham hock aliqua turducken cupidatat.

Ex fatback shank, andouille laborum eiusmod nulla landjaeger dolor chuck. Boudin mollit incididunt enim et. Cillum prosciutto leberkas cupidatat do dolore. Pork belly in jowl, tri-tip hamburger culpa meatball pork chop
consectetur bacon. Pancetta pig aliquip cupidatat, pariatur landjaeger brisket sint nulla salami anim nostrud porchetta. Sed jerky elit, filet mignon turducken biltong velit adipisicing est pariatur ad.

Culpa pork belly consectetur tempor ullamco. Pariatur bresaola voluptate, laboris fugiat officia adipisicing mollit proident duis corned beef. Brisket sed t-bone porchetta flank jerky, landjaeger ball tip velit leberkas.
Sunt pork chop pancetta ex aliquip fugiat.

Qui tempor shankle corned beef irure, anim pariatur rump velit. Sirloin boudin t-bone picanha, short loin shoulder strip steak ribeye. Lorem boudin spare ribs short loin pork nisi pork belly corned beef, sunt ground
round. In chicken lorem ullamco proident venison id spare ribs fatback prosciutto.

Venison jerky commodo sirloin. Boudin leberkas kielbasa swine filet mignon minim venison ham, commodo short loin deserunt. Picanha jerky bresaola tail, culpa ham incididunt tongue adipisicing in. Cillum ham sint pork
chop labore jowl, quis hamburger et incididunt ea landjaeger alcatra. Chicken tail rump lorem est irure. Biltong eu cow shankle boudin. Ground round irure duis, kielbasa sunt ut bresaola elit boudin andouille ball tip.

Bacon ipsum dolor amet shankle proident ham culpa short ribs occaecat magna sirloin do ball tip officia fugiat tempor lorem brisket. Fatback deserunt
ham hock quis beef mollit, veniam ad leberkas labore short loin capicola ribeye. Voluptate corned beef pork loin, ham sunt pork belly ut. Ad quis
reprehenderit, pork belly fatback tri-tip ipsum ut sirloin. Id commodo ipsum, enim beef venison nisi short ribs boudin ham biltong qui. Chicken enim
qui pancetta pig ea proident fatback est rump spare ribs porchetta. Meatloaf proident fatback, minim esse ipsum short loin elit pork eiusmod.

Short ribs nostrud ut sunt, ut pig jowl quis jerky laborum pariatur. Aliqua minim laboris cow t-bone doner. Ut beef ribs dolore biltong. Proident rump
consequat minim pariatur.  Rump turkey anim voluptate, porchetta occaecat reprehenderit meatloaf ribeye biltong et jerky fugiat. Ground round turkey
tri-tip jerky magna nostrud, kevin elit. Beef cupim biltong cupidatat short loin, lorem meatloaf turducken jowl tongue minim porchetta aliquip. Pork
chop magna sausage in dolor biltong alcatra pork belly. Prosciutto labore filet mignon, voluptate meatloaf irure bresaola turkey sausage in sed
leberkas tongue deserunt jerky.  Tempor excepteur aliqua, sint dolore elit tri-tip cillum.

Strip steak consequat non lorem voluptate porchetta nisi. Shoulder sirloin sausage jerky duis alcatra tenderloin. Nostrud lorem cillum, shank
turducken est nisi salami beef ribs ground round ball tip boudin non. Labore swine dolore, kielbasa strip steak culpa est. Voluptate labore magna
hamburger jowl cillum. Reprehenderit cupim tempor enim irure duis dolor.

Turkey sirloin sausage in pork loin ut. Fugiat leberkas sirloin landjaeger strip steak dolor short loin consequat deserunt sint pork chop. Velit
bresaola ham, filet mignon proident fugiat sausage flank pariatur. Pork landjaeger meatloaf pariatur, consectetur enim proident.

Bacon ipsum dolor amet venison nisi tail fatback pariatur turkey
capicola short ribs dolore in in voluptate. Short loin kevin chicken
incididunt, tri-tip short ribs bresaola in sint pork belly ham
shoulder brisket hamburger. Mollit cillum turkey eu laborum, tempor
commodo picanha bresaola sausage duis beef ribs chuck alcatra.
Pastrami non ea ball tip t-bone. Reprehenderit short loin aliquip,
tail kielbasa pork chop magna nulla pork. Sirloin dolor ut ea occaecat
dolore tenderloin irure do jowl. Drumstick t-bone picanha, dolor minim
nulla laboris tri-tip ham hock reprehenderit.

/*-
 * Copyright (c) 1982, 1986, 1989, 1991, 1993
 *      The Regents of the University of California.  All rights reserved.
 * (c) UNIX System Laboratories, Inc.
 * All or some portions of this file are derived from material licensed
 * to the University of California by American Telephone and Telegraph
 * Co. or Unix System Laboratories, Inc. and are reproduced herein with
 * the permission of UNIX System Laboratories, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *      @(#)kern_sig.c  8.7 (Berkeley) 4/18/94
 */

#include <sys/cdefs.h>
__FBSDID("$FreeBSD: releng/9.1/sys/kern/kern_sig.c 234455 2012-04-19 10:36:23Z kib $");

#include "opt_compat.h"
#include "opt_kdtrace.h"
#include "opt_ktrace.h"
#include "opt_core.h"
#include "opt_procdesc.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/signalvar.h>
#include <sys/vnode.h>
#include <sys/acct.h>
#include <sys/capability.h>
#include <sys/condvar.h>
#include <sys/event.h>
#include <sys/fcntl.h>
#include <sys/imgact.h>
#include <sys/kernel.h>
#include <sys/ktr.h>
#include <sys/ktrace.h>
#include <sys/lock.h>
#include <sys/malloc.h>
#include <sys/mutex.h>
#include <sys/namei.h>
#include <sys/proc.h>
#include <sys/procdesc.h>
#include <sys/posix4.h>
#include <sys/pioctl.h>
#include <sys/racct.h>
#include <sys/resourcevar.h>
#include <sys/sdt.h>
#include <sys/sbuf.h>
#include <sys/sleepqueue.h>
#include <sys/smp.h>
#include <sys/stat.h>
#include <sys/sx.h>
#include <sys/syscallsubr.h>
#include <sys/sysctl.h>
#include <sys/sysent.h>
#include <sys/syslog.h>
#include <sys/sysproto.h>
#include <sys/timers.h>
#include <sys/unistd.h>
#include <sys/wait.h>
#include <vm/vm.h>
#include <vm/vm_extern.h>
#include <vm/uma.h>

#include <sys/jail.h>

#include <machine/cpu.h>

#include <security/audit/audit.h>

#define ONSIG   32              /* NSIG for osig* syscalls.  XXX. */

SDT_PROVIDER_DECLARE(proc);
SDT_PROBE_DEFINE(proc, kernel, , signal_send, signal-send);
SDT_PROBE_ARGTYPE(proc, kernel, , signal_send, 0, "struct thread *");
SDT_PROBE_ARGTYPE(proc, kernel, , signal_send, 1, "struct proc *");
SDT_PROBE_ARGTYPE(proc, kernel, , signal_send, 2, "int");
SDT_PROBE_DEFINE(proc, kernel, , signal_clear, signal-clear);
SDT_PROBE_ARGTYPE(proc, kernel, , signal_clear, 0, "int");
SDT_PROBE_ARGTYPE(proc, kernel, , signal_clear, 1, "ksiginfo_t *");
SDT_PROBE_DEFINE(proc, kernel, , signal_discard, signal-discard);
SDT_PROBE_ARGTYPE(proc, kernel, , signal_discard, 0, "struct thread *");
SDT_PROBE_ARGTYPE(proc, kernel, , signal_discard, 1, "struct proc *");
SDT_PROBE_ARGTYPE(proc, kernel, , signal_discard, 2, "int");

static int      coredump(struct thread *);
static char     *expand_name(const char *, uid_t, pid_t, struct thread *, int);
static int      killpg1(struct thread *td, int sig, int pgid, int all,
                    ksiginfo_t *ksi);
static int      issignal(struct thread *td, int stop_allowed);
static int      sigprop(int sig);
static void     tdsigwakeup(struct thread *, int, sig_t, int);
static void     sig_suspend_threads(struct thread *, struct proc *, int);
static int      filt_sigattach(struct knote *kn);
static void     filt_sigdetach(struct knote *kn);
static int      filt_signal(struct knote *kn, long hint);
static struct thread *sigtd(struct proc *p, int sig, int prop);
static void     sigqueue_start(void);

static uma_zone_t       ksiginfo_zone = NULL;
struct filterops sig_filtops = {
        .f_isfd = 0,
        .f_attach = filt_sigattach,
        .f_detach = filt_sigdetach,
        .f_event = filt_signal,
};

static int      kern_logsigexit = 1;
SYSCTL_INT(_kern, KERN_LOGSIGEXIT, logsigexit, CTLFLAG_RW, 
    &kern_logsigexit, 0, 
    "Log processes quitting on abnormal signals to syslog(3)");

static int      kern_forcesigexit = 1;
SYSCTL_INT(_kern, OID_AUTO, forcesigexit, CTLFLAG_RW,
    &kern_forcesigexit, 0, "Force trap signal to be handled");

SYSCTL_NODE(_kern, OID_AUTO, sigqueue, CTLFLAG_RW, 0, "POSIX real time signal");

static int      max_pending_per_proc = 128;
SYSCTL_INT(_kern_sigqueue, OID_AUTO, max_pending_per_proc, CTLFLAG_RW,
    &max_pending_per_proc, 0, "Max pending signals per proc");

static int      preallocate_siginfo = 1024;
TUNABLE_INT("kern.sigqueue.preallocate", &preallocate_siginfo);
SYSCTL_INT(_kern_sigqueue, OID_AUTO, preallocate, CTLFLAG_RD,
    &preallocate_siginfo, 0, "Preallocated signal memory size");

static int      signal_overflow = 0;
SYSCTL_INT(_kern_sigqueue, OID_AUTO, overflow, CTLFLAG_RD,
    &signal_overflow, 0, "Number of signals overflew");

static int      signal_alloc_fail = 0;
SYSCTL_INT(_kern_sigqueue, OID_AUTO, alloc_fail, CTLFLAG_RD,
    &signal_alloc_fail, 0, "signals failed to be allocated");

SYSINIT(signal, SI_SUB_P1003_1B, SI_ORDER_FIRST+3, sigqueue_start, NULL);

/*
 * Policy -- Can ucred cr1 send SIGIO to process cr2?
 * Should use cr_cansignal() once cr_cansignal() allows SIGIO and SIGURG
 * in the right situations.
 */
#define CANSIGIO(cr1, cr2) \
        ((cr1)->cr_uid == 0 || \
            (cr1)->cr_ruid == (cr2)->cr_ruid || \
            (cr1)->cr_uid == (cr2)->cr_ruid || \
            (cr1)->cr_ruid == (cr2)->cr_uid || \
            (cr1)->cr_uid == (cr2)->cr_uid)

static int      sugid_coredump;
SYSCTL_INT(_kern, OID_AUTO, sugid_coredump, CTLFLAG_RW, 
    &sugid_coredump, 0, "Allow setuid and setgid processes to dump core");

static int      do_coredump = 1;
SYSCTL_INT(_kern, OID_AUTO, coredump, CTLFLAG_RW,
        &do_coredump, 0, "Enable/Disable coredumps");

static int      set_core_nodump_flag = 0;
SYSCTL_INT(_kern, OID_AUTO, nodump_coredump, CTLFLAG_RW, &set_core_nodump_flag,
        0, "Enable setting the NODUMP flag on coredump files");

/*
 * Signal properties and actions.
 * The array below categorizes the signals and their default actions
 * according to the following properties:
 */
#define SA_KILL         0x01            /* terminates process by default */
#define SA_CORE         0x02            /* ditto and coredumps */
#define SA_STOP         0x04            /* suspend process */
#define SA_TTYSTOP      0x08            /* ditto, from tty */
#define SA_IGNORE       0x10            /* ignore by default */
#define SA_CONT         0x20            /* continue if suspended */
#define SA_CANTMASK     0x40            /* non-maskable, catchable */
#define SA_PROC         0x80            /* deliverable to any thread */

static int sigproptbl[NSIG] = {
        SA_KILL|SA_PROC,                /* SIGHUP */
        SA_KILL|SA_PROC,                /* SIGINT */
        SA_KILL|SA_CORE|SA_PROC,        /* SIGQUIT */
        SA_KILL|SA_CORE,                /* SIGILL */
        SA_KILL|SA_CORE,                /* SIGTRAP */
        SA_KILL|SA_CORE,                /* SIGABRT */
        SA_KILL|SA_CORE|SA_PROC,        /* SIGEMT */
        SA_KILL|SA_CORE,                /* SIGFPE */
        SA_KILL|SA_PROC,                /* SIGKILL */
        SA_KILL|SA_CORE,                /* SIGBUS */
        SA_KILL|SA_CORE,                /* SIGSEGV */
        SA_KILL|SA_CORE,                /* SIGSYS */
        SA_KILL|SA_PROC,                /* SIGPIPE */
        SA_KILL|SA_PROC,                /* SIGALRM */
        SA_KILL|SA_PROC,                /* SIGTERM */
        SA_IGNORE|SA_PROC,              /* SIGURG */
        SA_STOP|SA_PROC,                /* SIGSTOP */
        SA_STOP|SA_TTYSTOP|SA_PROC,     /* SIGTSTP */
        SA_IGNORE|SA_CONT|SA_PROC,      /* SIGCONT */
        SA_IGNORE|SA_PROC,              /* SIGCHLD */
        SA_STOP|SA_TTYSTOP|SA_PROC,     /* SIGTTIN */
        SA_STOP|SA_TTYSTOP|SA_PROC,     /* SIGTTOU */
        SA_IGNORE|SA_PROC,              /* SIGIO */
        SA_KILL,                        /* SIGXCPU */
        SA_KILL,                        /* SIGXFSZ */
        SA_KILL|SA_PROC,                /* SIGVTALRM */
        SA_KILL|SA_PROC,                /* SIGPROF */
        SA_IGNORE|SA_PROC,              /* SIGWINCH  */
        SA_IGNORE|SA_PROC,              /* SIGINFO */
        SA_KILL|SA_PROC,                /* SIGUSR1 */
        SA_KILL|SA_PROC,                /* SIGUSR2 */
};

static void reschedule_signals(struct proc *p, sigset_t block, int flags);

static void
sigqueue_start(void)
{
        ksiginfo_zone = uma_zcreate("ksiginfo", sizeof(ksiginfo_t),
                NULL, NULL, NULL, NULL, UMA_ALIGN_PTR, 0);
        uma_prealloc(ksiginfo_zone, preallocate_siginfo);
        p31b_setcfg(CTL_P1003_1B_REALTIME_SIGNALS, _POSIX_REALTIME_SIGNALS);
        p31b_setcfg(CTL_P1003_1B_RTSIG_MAX, SIGRTMAX - SIGRTMIN + 1);
        p31b_setcfg(CTL_P1003_1B_SIGQUEUE_MAX, max_pending_per_proc);
}

ksiginfo_t *
ksiginfo_alloc(int wait)
{
        int flags;

        flags = M_ZERO;
        if (! wait)
                flags |= M_NOWAIT;
        if (ksiginfo_zone != NULL)
                return ((ksiginfo_t *)uma_zalloc(ksiginfo_zone, flags));
        return (NULL);
}

void
ksiginfo_free(ksiginfo_t *ksi)
{
        uma_zfree(ksiginfo_zone, ksi);
}

static __inline int
ksiginfo_tryfree(ksiginfo_t *ksi)
{
        if (!(ksi->ksi_flags & KSI_EXT)) {
                uma_zfree(ksiginfo_zone, ksi);
                return (1);
        }
        return (0);
}

void
sigqueue_init(sigqueue_t *list, struct proc *p)
{
        SIGEMPTYSET(list->sq_signals);
        SIGEMPTYSET(list->sq_kill);
        TAILQ_INIT(&list->sq_list);
        list->sq_proc = p;
        list->sq_flags = SQ_INIT;
}

/*
 * Get a signal's ksiginfo.
 * Return:
 *      0       -       signal not found
 *      others  -       signal number
 */ 
static int
sigqueue_get(sigqueue_t *sq, int signo, ksiginfo_t *si)
{
        struct proc *p = sq->sq_proc;
        struct ksiginfo *ksi, *next;
        int count = 0;

        KASSERT(sq->sq_flags & SQ_INIT, ("sigqueue not inited"));

        if (!SIGISMEMBER(sq->sq_signals, signo))
                return (0);

        if (SIGISMEMBER(sq->sq_kill, signo)) {
                count++;
                SIGDELSET(sq->sq_kill, signo);
        }

        TAILQ_FOREACH_SAFE(ksi, &sq->sq_list, ksi_link, next) {
                if (ksi->ksi_signo == signo) {
                        if (count == 0) {
                                TAILQ_REMOVE(&sq->sq_list, ksi, ksi_link);
                                ksi->ksi_sigq = NULL;
                                ksiginfo_copy(ksi, si);
                                if (ksiginfo_tryfree(ksi) && p != NULL)
                                        p->p_pendingcnt--;
                        }
                        if (++count > 1)
                                break;
                }
        }

        if (count <= 1)
                SIGDELSET(sq->sq_signals, signo);
        si->ksi_signo = signo;
        return (signo);
}

void
sigqueue_take(ksiginfo_t *ksi)
{
        struct ksiginfo *kp;
        struct proc     *p;
        sigqueue_t      *sq;

        if (ksi == NULL || (sq = ksi->ksi_sigq) == NULL)
                return;

        p = sq->sq_proc;
        TAILQ_REMOVE(&sq->sq_list, ksi, ksi_link);
        ksi->ksi_sigq = NULL;
        if (!(ksi->ksi_flags & KSI_EXT) && p != NULL)
                p->p_pendingcnt--;

        for (kp = TAILQ_FIRST(&sq->sq_list); kp != NULL;
             kp = TAILQ_NEXT(kp, ksi_link)) {
                if (kp->ksi_signo == ksi->ksi_signo)
                        break;
        }
        if (kp == NULL && !SIGISMEMBER(sq->sq_kill, ksi->ksi_signo))
                SIGDELSET(sq->sq_signals, ksi->ksi_signo);
}

static int
sigqueue_add(sigqueue_t *sq, int signo, ksiginfo_t *si)
{
        struct proc *p = sq->sq_proc;
        struct ksiginfo *ksi;
        int ret = 0;

        KASSERT(sq->sq_flags & SQ_INIT, ("sigqueue not inited"));
        
        if (signo == SIGKILL || signo == SIGSTOP || si == NULL) {
                SIGADDSET(sq->sq_kill, signo);
                goto out_set_bit;
        }

        /* directly insert the ksi, don't copy it */
        if (si->ksi_flags & KSI_INS) {
                if (si->ksi_flags & KSI_HEAD)
                        TAILQ_INSERT_HEAD(&sq->sq_list, si, ksi_link);
                else
                        TAILQ_INSERT_TAIL(&sq->sq_list, si, ksi_link);
                si->ksi_sigq = sq;
                goto out_set_bit;
        }

        if (__predict_false(ksiginfo_zone == NULL)) {
                SIGADDSET(sq->sq_kill, signo);
                goto out_set_bit;
        }
        
        if (p != NULL && p->p_pendingcnt >= max_pending_per_proc) {
                signal_overflow++;
                ret = EAGAIN;
        } else if ((ksi = ksiginfo_alloc(0)) == NULL) {
                signal_alloc_fail++;
                ret = EAGAIN;
        } else {
                if (p != NULL)
                        p->p_pendingcnt++;
                ksiginfo_copy(si, ksi);
                ksi->ksi_signo = signo;
                if (si->ksi_flags & KSI_HEAD)
                        TAILQ_INSERT_HEAD(&sq->sq_list, ksi, ksi_link);
                else
                        TAILQ_INSERT_TAIL(&sq->sq_list, ksi, ksi_link);
                ksi->ksi_sigq = sq;
        }

        if ((si->ksi_flags & KSI_TRAP) != 0 ||
            (si->ksi_flags & KSI_SIGQ) == 0) {
                if (ret != 0)
                        SIGADDSET(sq->sq_kill, signo);
                ret = 0;
                goto out_set_bit;
        }

        if (ret != 0)
                return (ret);
        
out_set_bit:
        SIGADDSET(sq->sq_signals, signo);
        return (ret);
}

void
sigqueue_flush(sigqueue_t *sq)
{
        struct proc *p = sq->sq_proc;
        ksiginfo_t *ksi;

        KASSERT(sq->sq_flags & SQ_INIT, ("sigqueue not inited"));

        if (p != NULL)
                PROC_LOCK_ASSERT(p, MA_OWNED);

        while ((ksi = TAILQ_FIRST(&sq->sq_list)) != NULL) {
                TAILQ_REMOVE(&sq->sq_list, ksi, ksi_link);
                ksi->ksi_sigq = NULL;
                if (ksiginfo_tryfree(ksi) && p != NULL)
                        p->p_pendingcnt--;
        }

        SIGEMPTYSET(sq->sq_signals);
        SIGEMPTYSET(sq->sq_kill);
}

static void
sigqueue_move_set(sigqueue_t *src, sigqueue_t *dst, const sigset_t *set)
{
        sigset_t tmp;
        struct proc *p1, *p2;
        ksiginfo_t *ksi, *next;

        KASSERT(src->sq_flags & SQ_INIT, ("src sigqueue not inited"));
        KASSERT(dst->sq_flags & SQ_INIT, ("dst sigqueue not inited"));
        p1 = src->sq_proc;
        p2 = dst->sq_proc;
        /* Move siginfo to target list */
        TAILQ_FOREACH_SAFE(ksi, &src->sq_list, ksi_link, next) {
                if (SIGISMEMBER(*set, ksi->ksi_signo)) {
                        TAILQ_REMOVE(&src->sq_list, ksi, ksi_link);
                        if (p1 != NULL)
                                p1->p_pendingcnt--;
                        TAILQ_INSERT_TAIL(&dst->sq_list, ksi, ksi_link);
                        ksi->ksi_sigq = dst;
                        if (p2 != NULL)
                                p2->p_pendingcnt++;
                }
        }

        /* Move pending bits to target list */
        tmp = src->sq_kill;
        SIGSETAND(tmp, *set);
        SIGSETOR(dst->sq_kill, tmp);
        SIGSETNAND(src->sq_kill, tmp);

        tmp = src->sq_signals;
        SIGSETAND(tmp, *set);
        SIGSETOR(dst->sq_signals, tmp);
        SIGSETNAND(src->sq_signals, tmp);
}

#if 0
static void
sigqueue_move(sigqueue_t *src, sigqueue_t *dst, int signo)
{
        sigset_t set;

        SIGEMPTYSET(set);
        SIGADDSET(set, signo);
        sigqueue_move_set(src, dst, &set);
}
#endif

static void
sigqueue_delete_set(sigqueue_t *sq, const sigset_t *set)
{
        struct proc *p = sq->sq_proc;
        ksiginfo_t *ksi, *next;

        KASSERT(sq->sq_flags & SQ_INIT, ("src sigqueue not inited"));

        /* Remove siginfo queue */
        TAILQ_FOREACH_SAFE(ksi, &sq->sq_list, ksi_link, next) {
                if (SIGISMEMBER(*set, ksi->ksi_signo)) {
                        TAILQ_REMOVE(&sq->sq_list, ksi, ksi_link);
                        ksi->ksi_sigq = NULL;
                        if (ksiginfo_tryfree(ksi) && p != NULL)
                                p->p_pendingcnt--;
                }
        }
        SIGSETNAND(sq->sq_kill, *set);
        SIGSETNAND(sq->sq_signals, *set);
}

void
sigqueue_delete(sigqueue_t *sq, int signo)
{
        sigset_t set;

        SIGEMPTYSET(set);
        SIGADDSET(set, signo);
        sigqueue_delete_set(sq, &set);
}

/* Remove a set of signals for a process */
static void
sigqueue_delete_set_proc(struct proc *p, const sigset_t *set)
{
        sigqueue_t worklist;
        struct thread *td0;

        PROC_LOCK_ASSERT(p, MA_OWNED);

        sigqueue_init(&worklist, NULL);
        sigqueue_move_set(&p->p_sigqueue, &worklist, set);

        FOREACH_THREAD_IN_PROC(p, td0)
                sigqueue_move_set(&td0->td_sigqueue, &worklist, set);

        sigqueue_flush(&worklist);
}

void
sigqueue_delete_proc(struct proc *p, int signo)
{
        sigset_t set;

        SIGEMPTYSET(set);
        SIGADDSET(set, signo);
        sigqueue_delete_set_proc(p, &set);
}

static void
sigqueue_delete_stopmask_proc(struct proc *p)
{
        sigset_t set;

        SIGEMPTYSET(set);
        SIGADDSET(set, SIGSTOP);
        SIGADDSET(set, SIGTSTP);
        SIGADDSET(set, SIGTTIN);
        SIGADDSET(set, SIGTTOU);
        sigqueue_delete_set_proc(p, &set);
}

/*
 * Determine signal that should be delivered to process p, the current
 * process, 0 if none.  If there is a pending stop signal with default
 * action, the process stops in issignal().
 */
int
cursig(struct thread *td, int stop_allowed)
{
        PROC_LOCK_ASSERT(td->td_proc, MA_OWNED);
        KASSERT(stop_allowed == SIG_STOP_ALLOWED ||
            stop_allowed == SIG_STOP_NOT_ALLOWED, ("cursig: stop_allowed"));
        mtx_assert(&td->td_proc->p_sigacts->ps_mtx, MA_OWNED);
        THREAD_LOCK_ASSERT(td, MA_NOTOWNED);
        return (SIGPENDING(td) ? issignal(td, stop_allowed) : 0);
}

/*
 * Arrange for ast() to handle unmasked pending signals on return to user
 * mode.  This must be called whenever a signal is added to td_sigqueue or
 * unmasked in td_sigmask.
 */
void
signotify(struct thread *td)
{
        struct proc *p;

        p = td->td_proc;

        PROC_LOCK_ASSERT(p, MA_OWNED);

        if (SIGPENDING(td)) {
                thread_lock(td);
                td->td_flags |= TDF_NEEDSIGCHK | TDF_ASTPENDING;
                thread_unlock(td);
        }
}

int
sigonstack(size_t sp)
{
        struct thread *td = curthread;

        return ((td->td_pflags & TDP_ALTSTACK) ?
#if defined(COMPAT_43)
            ((td->td_sigstk.ss_size == 0) ?
                (td->td_sigstk.ss_flags & SS_ONSTACK) :
                ((sp - (size_t)td->td_sigstk.ss_sp) < td->td_sigstk.ss_size))
#else
            ((sp - (size_t)td->td_sigstk.ss_sp) < td->td_sigstk.ss_size)
#endif
            : 0);
}

static __inline int
sigprop(int sig)
{

        if (sig > 0 && sig < NSIG)
                return (sigproptbl[_SIG_IDX(sig)]);
        return (0);
}

int
sig_ffs(sigset_t *set)
{
        int i;

        for (i = 0; i < _SIG_WORDS; i++)
                if (set->__bits[i])
                        return (ffs(set->__bits[i]) + (i * 32));
        return (0);
}

/*
 * kern_sigaction
 * sigaction
 * freebsd4_sigaction
 * osigaction
 */
int
kern_sigaction(td, sig, act, oact, flags)
        struct thread *td;
        register int sig;
        struct sigaction *act, *oact;
        int flags;
{
        struct sigacts *ps;
        struct proc *p = td->td_proc;

        if (!_SIG_VALID(sig))
                return (EINVAL);

        PROC_LOCK(p);
        ps = p->p_sigacts;
        mtx_lock(&ps->ps_mtx);
        if (oact) {
                oact->sa_mask = ps->ps_catchmask[_SIG_IDX(sig)];
                oact->sa_flags = 0;
                if (SIGISMEMBER(ps->ps_sigonstack, sig))
                        oact->sa_flags |= SA_ONSTACK;
                if (!SIGISMEMBER(ps->ps_sigintr, sig))
                        oact->sa_flags |= SA_RESTART;
                if (SIGISMEMBER(ps->ps_sigreset, sig))
                        oact->sa_flags |= SA_RESETHAND;
                if (SIGISMEMBER(ps->ps_signodefer, sig))
                        oact->sa_flags |= SA_NODEFER;
                if (SIGISMEMBER(ps->ps_siginfo, sig)) {
                        oact->sa_flags |= SA_SIGINFO;
                        oact->sa_sigaction =
                            (__siginfohandler_t *)ps->ps_sigact[_SIG_IDX(sig)];
                } else
                        oact->sa_handler = ps->ps_sigact[_SIG_IDX(sig)];
                if (sig == SIGCHLD && ps->ps_flag & PS_NOCLDSTOP)
                        oact->sa_flags |= SA_NOCLDSTOP;
                if (sig == SIGCHLD && ps->ps_flag & PS_NOCLDWAIT)
                        oact->sa_flags |= SA_NOCLDWAIT;
        }
        if (act) {
                if ((sig == SIGKILL || sig == SIGSTOP) &&
                    act->sa_handler != SIG_DFL) {
                        mtx_unlock(&ps->ps_mtx);
                        PROC_UNLOCK(p);
                        return (EINVAL);
                }

                /*
                 * Change setting atomically.
                 */

                ps->ps_catchmask[_SIG_IDX(sig)] = act->sa_mask;
                SIG_CANTMASK(ps->ps_catchmask[_SIG_IDX(sig)]);
                if (act->sa_flags & SA_SIGINFO) {
                        ps->ps_sigact[_SIG_IDX(sig)] =
                            (__sighandler_t *)act->sa_sigaction;
                        SIGADDSET(ps->ps_siginfo, sig);
                } else {
                        ps->ps_sigact[_SIG_IDX(sig)] = act->sa_handler;
                        SIGDELSET(ps->ps_siginfo, sig);
                }
                if (!(act->sa_flags & SA_RESTART))
                        SIGADDSET(ps->ps_sigintr, sig);
                else
                        SIGDELSET(ps->ps_sigintr, sig);
                if (act->sa_flags & SA_ONSTACK)
                        SIGADDSET(ps->ps_sigonstack, sig);
                else
                        SIGDELSET(ps->ps_sigonstack, sig);
                if (act->sa_flags & SA_RESETHAND)
                        SIGADDSET(ps->ps_sigreset, sig);
                else
                        SIGDELSET(ps->ps_sigreset, sig);
                if (act->sa_flags & SA_NODEFER)
                        SIGADDSET(ps->ps_signodefer, sig);
                else
                        SIGDELSET(ps->ps_signodefer, sig);
                if (sig == SIGCHLD) {
                        if (act->sa_flags & SA_NOCLDSTOP)
                                ps->ps_flag |= PS_NOCLDSTOP;
                        else
                                ps->ps_flag &= ~PS_NOCLDSTOP;
                        if (act->sa_flags & SA_NOCLDWAIT) {
                                /*
                                 * Paranoia: since SA_NOCLDWAIT is implemented
                                 * by reparenting the dying child to PID 1 (and
                                 * trust it to reap the zombie), PID 1 itself
                                 * is forbidden to set SA_NOCLDWAIT.
                                 */
                                if (p->p_pid == 1)
                                        ps->ps_flag &= ~PS_NOCLDWAIT;
                                else
                                        ps->ps_flag |= PS_NOCLDWAIT;
                        } else
                                ps->ps_flag &= ~PS_NOCLDWAIT;
                        if (ps->ps_sigact[_SIG_IDX(SIGCHLD)] == SIG_IGN)
                                ps->ps_flag |= PS_CLDSIGIGN;
                        else
                                ps->ps_flag &= ~PS_CLDSIGIGN;
                }
                /*
                 * Set bit in ps_sigignore for signals that are set to SIG_IGN,
                 * and for signals set to SIG_DFL where the default is to
                 * ignore. However, don't put SIGCONT in ps_sigignore, as we
                 * have to restart the process.
                 */
                if (ps->ps_sigact[_SIG_IDX(sig)] == SIG_IGN ||
                    (sigprop(sig) & SA_IGNORE &&
                     ps->ps_sigact[_SIG_IDX(sig)] == SIG_DFL)) {
                        /* never to be seen again */
                        sigqueue_delete_proc(p, sig);
                        if (sig != SIGCONT)
                                /* easier in psignal */
                                SIGADDSET(ps->ps_sigignore, sig);
                        SIGDELSET(ps->ps_sigcatch, sig);
                } else {
                        SIGDELSET(ps->ps_sigignore, sig);
                        if (ps->ps_sigact[_SIG_IDX(sig)] == SIG_DFL)
                                SIGDELSET(ps->ps_sigcatch, sig);
                        else
                                SIGADDSET(ps->ps_sigcatch, sig);
                }
#ifdef COMPAT_FREEBSD4
                if (ps->ps_sigact[_SIG_IDX(sig)] == SIG_IGN ||
                    ps->ps_sigact[_SIG_IDX(sig)] == SIG_DFL ||
                    (flags & KSA_FREEBSD4) == 0)
                        SIGDELSET(ps->ps_freebsd4, sig);
                else
                        SIGADDSET(ps->ps_freebsd4, sig);
#endif
#ifdef COMPAT_43
                if (ps->ps_sigact[_SIG_IDX(sig)] == SIG_IGN ||
                    ps->ps_sigact[_SIG_IDX(sig)] == SIG_DFL ||
                    (flags & KSA_OSIGSET) == 0)
                        SIGDELSET(ps->ps_osigset, sig);
                else
                        SIGADDSET(ps->ps_osigset, sig);
#endif
        }
        mtx_unlock(&ps->ps_mtx);
        PROC_UNLOCK(p);
        return (0);
}

#ifndef _SYS_SYSPROTO_H_
struct sigaction_args {
        int     sig;
        struct  sigaction *act;
        struct  sigaction *oact;
};
#endif
int
sys_sigaction(td, uap)
        struct thread *td;
        register struct sigaction_args *uap;
{
        struct sigaction act, oact;
        register struct sigaction *actp, *oactp;
        int error;

        actp = (uap->act != NULL) ? &act : NULL;
        oactp = (uap->oact != NULL) ? &oact : NULL;
        if (actp) {
                error = copyin(uap->act, actp, sizeof(act));
                if (error)
                        return (error);
        }
        error = kern_sigaction(td, uap->sig, actp, oactp, 0);
        if (oactp && !error)
                error = copyout(oactp, uap->oact, sizeof(oact));
        return (error);
}

#ifdef COMPAT_FREEBSD4
#ifndef _SYS_SYSPROTO_H_
struct freebsd4_sigaction_args {
        int     sig;
        struct  sigaction *act;
        struct  sigaction *oact;
};
#endif
int
freebsd4_sigaction(td, uap)
        struct thread *td;
        register struct freebsd4_sigaction_args *uap;
{
        struct sigaction act, oact;
        register struct sigaction *actp, *oactp;
        int error;


        actp = (uap->act != NULL) ? &act : NULL;
        oactp = (uap->oact != NULL) ? &oact : NULL;
        if (actp) {
                error = copyin(uap->act, actp, sizeof(act));
                if (error)
                        return (error);
        }
        error = kern_sigaction(td, uap->sig, actp, oactp, KSA_FREEBSD4);
        if (oactp && !error)
                error = copyout(oactp, uap->oact, sizeof(oact));
        return (error);
}
#endif  /* COMAPT_FREEBSD4 */

#ifdef COMPAT_43        /* XXX - COMPAT_FBSD3 */
#ifndef _SYS_SYSPROTO_H_
struct osigaction_args {
        int     signum;
        struct  osigaction *nsa;
        struct  osigaction *osa;
};
#endif
int
osigaction(td, uap)
        struct thread *td;
        register struct osigaction_args *uap;
{
        struct osigaction sa;
        struct sigaction nsa, osa;
        register struct sigaction *nsap, *osap;
        int error;

        if (uap->signum <= 0 || uap->signum >= ONSIG)
                return (EINVAL);

        nsap = (uap->nsa != NULL) ? &nsa : NULL;
        osap = (uap->osa != NULL) ? &osa : NULL;

        if (nsap) {
                error = copyin(uap->nsa, &sa, sizeof(sa));
                if (error)
                        return (error);
                nsap->sa_handler = sa.sa_handler;
                nsap->sa_flags = sa.sa_flags;
                OSIG2SIG(sa.sa_mask, nsap->sa_mask);
        }
        error = kern_sigaction(td, uap->signum, nsap, osap, KSA_OSIGSET);
        if (osap && !error) {
                sa.sa_handler = osap->sa_handler;
                sa.sa_flags = osap->sa_flags;
                SIG2OSIG(osap->sa_mask, sa.sa_mask);
                error = copyout(&sa, uap->osa, sizeof(sa));
        }
        return (error);
}

#if !defined(__i386__)
/* Avoid replicating the same stub everywhere */
int
osigreturn(td, uap)
        struct thread *td;
        struct osigreturn_args *uap;
{

        return (nosys(td, (struct nosys_args *)uap));
}
#endif
#endif /* COMPAT_43 */

/*
 * Initialize signal state for process 0;
 * set to ignore signals that are ignored by default.
 */
void
siginit(p)
        struct proc *p;
{
        register int i;
        struct sigacts *ps;

        PROC_LOCK(p);
        ps = p->p_sigacts;
        mtx_lock(&ps->ps_mtx);
        for (i = 1; i <= NSIG; i++)
                if (sigprop(i) & SA_IGNORE && i != SIGCONT)
                        SIGADDSET(ps->ps_sigignore, i);
        mtx_unlock(&ps->ps_mtx);
        PROC_UNLOCK(p);
}

/*
 * Reset signals for an exec of the specified process.
 */
void
execsigs(struct proc *p)
{
        struct sigacts *ps;
        int sig;
        struct thread *td;

        /*
         * Reset caught signals.  Held signals remain held
         * through td_sigmask (unless they were caught,
         * and are now ignored by default).
         */
        PROC_LOCK_ASSERT(p, MA_OWNED);
        td = FIRST_THREAD_IN_PROC(p);
        ps = p->p_sigacts;
        mtx_lock(&ps->ps_mtx);
        while (SIGNOTEMPTY(ps->ps_sigcatch)) {
                sig = sig_ffs(&ps->ps_sigcatch);
                SIGDELSET(ps->ps_sigcatch, sig);
                if (sigprop(sig) & SA_IGNORE) {
                        if (sig != SIGCONT)
                                SIGADDSET(ps->ps_sigignore, sig);
                        sigqueue_delete_proc(p, sig);
                }
                ps->ps_sigact[_SIG_IDX(sig)] = SIG_DFL;
        }
        /*
         * Reset stack state to the user stack.
         * Clear set of signals caught on the signal stack.
         */
        td->td_sigstk.ss_flags = SS_DISABLE;
        td->td_sigstk.ss_size = 0;
        td->td_sigstk.ss_sp = 0;
        td->td_pflags &= ~TDP_ALTSTACK;
        /*
         * Reset no zombies if child dies flag as Solaris does.
         */
        ps->ps_flag &= ~(PS_NOCLDWAIT | PS_CLDSIGIGN);
        if (ps->ps_sigact[_SIG_IDX(SIGCHLD)] == SIG_IGN)
                ps->ps_sigact[_SIG_IDX(SIGCHLD)] = SIG_DFL;
        mtx_unlock(&ps->ps_mtx);
}

/*
 * kern_sigprocmask()
 *
 *      Manipulate signal mask.
 */
int
kern_sigprocmask(struct thread *td, int how, sigset_t *set, sigset_t *oset,
    int flags)
{
        sigset_t new_block, oset1;
        struct proc *p;
        int error;

        p = td->td_proc;
        if (!(flags & SIGPROCMASK_PROC_LOCKED))
                PROC_LOCK(p);
        if (oset != NULL)
                *oset = td->td_sigmask;

        error = 0;
        if (set != NULL) {
                switch (how) {
                case SIG_BLOCK:
                        SIG_CANTMASK(*set);
                        oset1 = td->td_sigmask;
                        SIGSETOR(td->td_sigmask, *set);
                        new_block = td->td_sigmask;
                        SIGSETNAND(new_block, oset1);
                        break;
                case SIG_UNBLOCK:
                        SIGSETNAND(td->td_sigmask, *set);
                        signotify(td);
                        goto out;
                case SIG_SETMASK:
                        SIG_CANTMASK(*set);
                        oset1 = td->td_sigmask;
                        if (flags & SIGPROCMASK_OLD)
                                SIGSETLO(td->td_sigmask, *set);
                        else
                                td->td_sigmask = *set;
                        new_block = td->td_sigmask;
                        SIGSETNAND(new_block, oset1);
                        signotify(td);
                        break;
                default:
                        error = EINVAL;
                        goto out;
                }

                /*
                 * The new_block set contains signals that were not previously
                 * blocked, but are blocked now.
                 *
                 * In case we block any signal that was not previously blocked
                 * for td, and process has the signal pending, try to schedule
                 * signal delivery to some thread that does not block the
                 * signal, possibly waking it up.
                 */
                if (p->p_numthreads != 1)
                        reschedule_signals(p, new_block, flags);
        }

out:
        if (!(flags & SIGPROCMASK_PROC_LOCKED))
                PROC_UNLOCK(p);
        return (error);
}

#ifndef _SYS_SYSPROTO_H_
struct sigprocmask_args {
        int     how;
        const sigset_t *set;
        sigset_t *oset;
};
#endif
int
sys_sigprocmask(td, uap)
        register struct thread *td;
        struct sigprocmask_args *uap;
{
        sigset_t set, oset;
        sigset_t *setp, *osetp;
        int error;

        setp = (uap->set != NULL) ? &set : NULL;
        osetp = (uap->oset != NULL) ? &oset : NULL;
        if (setp) {
                error = copyin(uap->set, setp, sizeof(set));
                if (error)
                        return (error);
        }
        error = kern_sigprocmask(td, uap->how, setp, osetp, 0);
        if (osetp && !error) {
                error = copyout(osetp, uap->oset, sizeof(oset));
        }
        return (error);
}

#ifdef COMPAT_43        /* XXX - COMPAT_FBSD3 */
#ifndef _SYS_SYSPROTO_H_
struct osigprocmask_args {
        int     how;
        osigset_t mask;
};
#endif
int
osigprocmask(td, uap)
        register struct thread *td;
        struct osigprocmask_args *uap;
{
        sigset_t set, oset;
        int error;

        OSIG2SIG(uap->mask, set);
        error = kern_sigprocmask(td, uap->how, &set, &oset, 1);
        SIG2OSIG(oset, td->td_retval[0]);
        return (error);
}
#endif /* COMPAT_43 */

int
sys_sigwait(struct thread *td, struct sigwait_args *uap)
{
        ksiginfo_t ksi;
        sigset_t set;
        int error;

        error = copyin(uap->set, &set, sizeof(set));
        if (error) {
                td->td_retval[0] = error;
                return (0);
        }

        error = kern_sigtimedwait(td, set, &ksi, NULL);
        if (error) {
                if (error == EINTR && td->td_proc->p_osrel < P_OSREL_SIGWAIT)
                        error = ERESTART;
                if (error == ERESTART)
                        return (error);
                td->td_retval[0] = error;
                return (0);
        }

        error = copyout(&ksi.ksi_signo, uap->sig, sizeof(ksi.ksi_signo));
        td->td_retval[0] = error;
        return (0);
}

int
sys_sigtimedwait(struct thread *td, struct sigtimedwait_args *uap)
{
        struct timespec ts;
        struct timespec *timeout;
        sigset_t set;
        ksiginfo_t ksi;
        int error;

        if (uap->timeout) {
                error = copyin(uap->timeout, &ts, sizeof(ts));
                if (error)
                        return (error);

                timeout = &ts;
        } else
                timeout = NULL;

        error = copyin(uap->set, &set, sizeof(set));
        if (error)
                return (error);

        error = kern_sigtimedwait(td, set, &ksi, timeout);
        if (error)
                return (error);

        if (uap->info)
                error = copyout(&ksi.ksi_info, uap->info, sizeof(siginfo_t));

        if (error == 0)
                td->td_retval[0] = ksi.ksi_signo;
        return (error);
}

int
sys_sigwaitinfo(struct thread *td, struct sigwaitinfo_args *uap)
{
        ksiginfo_t ksi;
        sigset_t set;
        int error;

        error = copyin(uap->set, &set, sizeof(set));
        if (error)
                return (error);

        error = kern_sigtimedwait(td, set, &ksi, NULL);
        if (error)
                return (error);

        if (uap->info)
                error = copyout(&ksi.ksi_info, uap->info, sizeof(siginfo_t));
        
        if (error == 0)
                td->td_retval[0] = ksi.ksi_signo;
        return (error);
}

int
kern_sigtimedwait(struct thread *td, sigset_t waitset, ksiginfo_t *ksi,
        struct timespec *timeout)
{
        struct sigacts *ps;
        sigset_t saved_mask, new_block;
        struct proc *p;
        int error, sig, timo, timevalid = 0;
        struct timespec rts, ets, ts;
        struct timeval tv;

        p = td->td_proc;
        error = 0;
        ets.tv_sec = 0;
        ets.tv_nsec = 0;

        if (timeout != NULL) {
                if (timeout->tv_nsec >= 0 && timeout->tv_nsec < 1000000000) {
                        timevalid = 1;
                        getnanouptime(&rts);
                        ets = rts;
                        timespecadd(&ets, timeout);
                }
        }
        ksiginfo_init(ksi);
        /* Some signals can not be waited for. */
        SIG_CANTMASK(waitset);
        ps = p->p_sigacts;
        PROC_LOCK(p);
        saved_mask = td->td_sigmask;
        SIGSETNAND(td->td_sigmask, waitset);
        for (;;) {
                mtx_lock(&ps->ps_mtx);
                sig = cursig(td, SIG_STOP_ALLOWED);
                mtx_unlock(&ps->ps_mtx);
                if (sig != 0 && SIGISMEMBER(waitset, sig)) {
                        if (sigqueue_get(&td->td_sigqueue, sig, ksi) != 0 ||
                            sigqueue_get(&p->p_sigqueue, sig, ksi) != 0) {
                                error = 0;
                                break;
                        }
                }

                if (error != 0)
                        break;

                /*
                 * POSIX says this must be checked after looking for pending
                 * signals.
                 */
                if (timeout != NULL) {
                        if (!timevalid) {
                                error = EINVAL;
                                break;
                        }
                        getnanouptime(&rts);
                        if (timespeccmp(&rts, &ets, >=)) {
                                error = EAGAIN;
                                break;
                        }
                        ts = ets;
                        timespecsub(&ts, &rts);
                        TIMESPEC_TO_TIMEVAL(&tv, &ts);
                        timo = tvtohz(&tv);
                } else {
                        timo = 0;
                }

                error = msleep(ps, &p->p_mtx, PPAUSE|PCATCH, "sigwait", timo);

                if (timeout != NULL) {
                        if (error == ERESTART) {
                                /* Timeout can not be restarted. */
                                error = EINTR;
                        } else if (error == EAGAIN) {
                                /* We will calculate timeout by ourself. */
                                error = 0;
                        }
                }
        }

        new_block = saved_mask;
        SIGSETNAND(new_block, td->td_sigmask);
        td->td_sigmask = saved_mask;
        /*
         * Fewer signals can be delivered to us, reschedule signal
         * notification.
         */
        if (p->p_numthreads != 1)
                reschedule_signals(p, new_block, 0);

        if (error == 0) {
                SDT_PROBE(proc, kernel, , signal_clear, sig, ksi, 0, 0, 0);
                
                if (ksi->ksi_code == SI_TIMER)
                        itimer_accept(p, ksi->ksi_timerid, ksi);

#ifdef KTRACE
                if (KTRPOINT(td, KTR_PSIG)) {
                        sig_t action;

                        mtx_lock(&ps->ps_mtx);
                        action = ps->ps_sigact[_SIG_IDX(sig)];
                        mtx_unlock(&ps->ps_mtx);
                        ktrpsig(sig, action, &td->td_sigmask, ksi->ksi_code);
                }
#endif
                if (sig == SIGKILL)
                        sigexit(td, sig);
        }
        PROC_UNLOCK(p);
        return (error);
}

#ifndef _SYS_SYSPROTO_H_
struct sigpending_args {
        sigset_t        *set;
};
#endif
int
sys_sigpending(td, uap)
        struct thread *td;
        struct sigpending_args *uap;
{
        struct proc *p = td->td_proc;
        sigset_t pending;

        PROC_LOCK(p);
        pending = p->p_sigqueue.sq_signals;
        SIGSETOR(pending, td->td_sigqueue.sq_signals);
        PROC_UNLOCK(p);
        return (copyout(&pending, uap->set, sizeof(sigset_t)));
}

#ifdef COMPAT_43        /* XXX - COMPAT_FBSD3 */
#ifndef _SYS_SYSPROTO_H_
struct osigpending_args {
        int     dummy;
};
#endif
int
osigpending(td, uap)
        struct thread *td;
        struct osigpending_args *uap;
{
        struct proc *p = td->td_proc;
        sigset_t pending;

        PROC_LOCK(p);
        pending = p->p_sigqueue.sq_signals;
        SIGSETOR(pending, td->td_sigqueue.sq_signals);
        PROC_UNLOCK(p);
        SIG2OSIG(pending, td->td_retval[0]);
        return (0);
}
#endif /* COMPAT_43 */

#if defined(COMPAT_43)
/*
 * Generalized interface signal handler, 4.3-compatible.
 */
#ifndef _SYS_SYSPROTO_H_
struct osigvec_args {
        int     signum;
        struct  sigvec *nsv;
        struct  sigvec *osv;
};
#endif
/* ARGSUSED */
int
osigvec(td, uap)
        struct thread *td;
        register struct osigvec_args *uap;
{
        struct sigvec vec;
        struct sigaction nsa, osa;
        register struct sigaction *nsap, *osap;
        int error;

        if (uap->signum <= 0 || uap->signum >= ONSIG)
                return (EINVAL);
        nsap = (uap->nsv != NULL) ? &nsa : NULL;
        osap = (uap->osv != NULL) ? &osa : NULL;
        if (nsap) {
                error = copyin(uap->nsv, &vec, sizeof(vec));
                if (error)
                        return (error);
                nsap->sa_handler = vec.sv_handler;
                OSIG2SIG(vec.sv_mask, nsap->sa_mask);
                nsap->sa_flags = vec.sv_flags;
                nsap->sa_flags ^= SA_RESTART;   /* opposite of SV_INTERRUPT */
        }
        error = kern_sigaction(td, uap->signum, nsap, osap, KSA_OSIGSET);
        if (osap && !error) {
                vec.sv_handler = osap->sa_handler;
                SIG2OSIG(osap->sa_mask, vec.sv_mask);
                vec.sv_flags = osap->sa_flags;
                vec.sv_flags &= ~SA_NOCLDWAIT;
                vec.sv_flags ^= SA_RESTART;
                error = copyout(&vec, uap->osv, sizeof(vec));
        }
        return (error);
}

#ifndef _SYS_SYSPROTO_H_
struct osigblock_args {
        int     mask;
};
#endif
int
osigblock(td, uap)
        register struct thread *td;
        struct osigblock_args *uap;
{
        sigset_t set, oset;

        OSIG2SIG(uap->mask, set);
        kern_sigprocmask(td, SIG_BLOCK, &set, &oset, 0);
        SIG2OSIG(oset, td->td_retval[0]);
        return (0);
}

#ifndef _SYS_SYSPROTO_H_
struct osigsetmask_args {
        int     mask;
};
#endif
int
osigsetmask(td, uap)
        struct thread *td;
        struct osigsetmask_args *uap;
{
        sigset_t set, oset;

        OSIG2SIG(uap->mask, set);
        kern_sigprocmask(td, SIG_SETMASK, &set, &oset, 0);
        SIG2OSIG(oset, td->td_retval[0]);
        return (0);
}
#endif /* COMPAT_43 */

/*
 * Suspend calling thread until signal, providing mask to be set in the
 * meantime. 
 */
#ifndef _SYS_SYSPROTO_H_
struct sigsuspend_args {
        const sigset_t *sigmask;
};
#endif
/* ARGSUSED */
int
sys_sigsuspend(td, uap)
        struct thread *td;
        struct sigsuspend_args *uap;
{
        sigset_t mask;
        int error;

        error = copyin(uap->sigmask, &mask, sizeof(mask));
        if (error)
                return (error);
        return (kern_sigsuspend(td, mask));
}

int
kern_sigsuspend(struct thread *td, sigset_t mask)
{
        struct proc *p = td->td_proc;
        int has_sig, sig;

        /*
         * When returning from sigsuspend, we want
         * the old mask to be restored after the
         * signal handler has finished.  Thus, we
         * save it here and mark the sigacts structure
         * to indicate this.
         */
        PROC_LOCK(p);
        kern_sigprocmask(td, SIG_SETMASK, &mask, &td->td_oldsigmask,
            SIGPROCMASK_PROC_LOCKED);
        td->td_pflags |= TDP_OLDMASK;

        /*
         * Process signals now. Otherwise, we can get spurious wakeup
         * due to signal entered process queue, but delivered to other
         * thread. But sigsuspend should return only on signal
         * delivery.
         */
        (p->p_sysent->sv_set_syscall_retval)(td, EINTR);
        for (has_sig = 0; !has_sig;) {
                while (msleep(&p->p_sigacts, &p->p_mtx, PPAUSE|PCATCH, "pause",
                        0) == 0)
                        /* void */;
                thread_suspend_check(0);
                mtx_lock(&p->p_sigacts->ps_mtx);
                while ((sig = cursig(td, SIG_STOP_ALLOWED)) != 0)
                        has_sig += postsig(sig);
                mtx_unlock(&p->p_sigacts->ps_mtx);
        }
        PROC_UNLOCK(p);
        td->td_errno = EINTR;
        td->td_pflags |= TDP_NERRNO;
        return (EJUSTRETURN);
}

#ifdef COMPAT_43        /* XXX - COMPAT_FBSD3 */
/*
 * Compatibility sigsuspend call for old binaries.  Note nonstandard calling
 * convention: libc stub passes mask, not pointer, to save a copyin.
 */
#ifndef _SYS_SYSPROTO_H_
struct osigsuspend_args {
        osigset_t mask;
};
#endif
/* ARGSUSED */
int
osigsuspend(td, uap)
        struct thread *td;
        struct osigsuspend_args *uap;
{
        sigset_t mask;

        OSIG2SIG(uap->mask, mask);
        return (kern_sigsuspend(td, mask));
}
#endif /* COMPAT_43 */

#if defined(COMPAT_43)
#ifndef _SYS_SYSPROTO_H_
struct osigstack_args {
        struct  sigstack *nss;
        struct  sigstack *oss;
};
#endif
/* ARGSUSED */
int
osigstack(td, uap)
        struct thread *td;
        register struct osigstack_args *uap;
{
        struct sigstack nss, oss;
        int error = 0;

        if (uap->nss != NULL) {
                error = copyin(uap->nss, &nss, sizeof(nss));
                if (error)
                        return (error);
        }
        oss.ss_sp = td->td_sigstk.ss_sp;
        oss.ss_onstack = sigonstack(cpu_getstack(td));
        if (uap->nss != NULL) {
                td->td_sigstk.ss_sp = nss.ss_sp;
                td->td_sigstk.ss_size = 0;
                td->td_sigstk.ss_flags |= nss.ss_onstack & SS_ONSTACK;
                td->td_pflags |= TDP_ALTSTACK;
        }
        if (uap->oss != NULL)
                error = copyout(&oss, uap->oss, sizeof(oss));

        return (error);
}
#endif /* COMPAT_43 */

#ifndef _SYS_SYSPROTO_H_
struct sigaltstack_args {
        stack_t *ss;
        stack_t *oss;
};
#endif
/* ARGSUSED */
int
sys_sigaltstack(td, uap)
        struct thread *td;
        register struct sigaltstack_args *uap;
{
        stack_t ss, oss;
        int error;

        if (uap->ss != NULL) {
                error = copyin(uap->ss, &ss, sizeof(ss));
                if (error)
                        return (error);
        }
        error = kern_sigaltstack(td, (uap->ss != NULL) ? &ss : NULL,
            (uap->oss != NULL) ? &oss : NULL);
        if (error)
                return (error);
        if (uap->oss != NULL)
                error = copyout(&oss, uap->oss, sizeof(stack_t));
        return (error);
}

int
kern_sigaltstack(struct thread *td, stack_t *ss, stack_t *oss)
{
        struct proc *p = td->td_proc;
        int oonstack;

        oonstack = sigonstack(cpu_getstack(td));

        if (oss != NULL) {
                *oss = td->td_sigstk;
                oss->ss_flags = (td->td_pflags & TDP_ALTSTACK)
                    ? ((oonstack) ? SS_ONSTACK : 0) : SS_DISABLE;
        }

        if (ss != NULL) {
                if (oonstack)
                        return (EPERM);
                if ((ss->ss_flags & ~SS_DISABLE) != 0)
                        return (EINVAL);
                if (!(ss->ss_flags & SS_DISABLE)) {
                        if (ss->ss_size < p->p_sysent->sv_minsigstksz)
                                return (ENOMEM);

                        td->td_sigstk = *ss;
                        td->td_pflags |= TDP_ALTSTACK;
                } else {
                        td->td_pflags &= ~TDP_ALTSTACK;
                }
        }
        return (0);
}

/*
 * Common code for kill process group/broadcast kill.
 * cp is calling process.
 */
static int
killpg1(struct thread *td, int sig, int pgid, int all, ksiginfo_t *ksi)
{
        struct proc *p;
        struct pgrp *pgrp;
        int nfound = 0;

        if (all) {
                /*
                 * broadcast
                 */
                sx_slock(&allproc_lock);
                FOREACH_PROC_IN_SYSTEM(p) {
                        PROC_LOCK(p);
                        if (p->p_pid <= 1 || p->p_flag & P_SYSTEM ||
                            p == td->td_proc || p->p_state == PRS_NEW) {
                                PROC_UNLOCK(p);
                                continue;
                        }
                        if (p_cansignal(td, p, sig) == 0) {
                                nfound++;
                                if (sig)
                                        pksignal(p, sig, ksi);
                        }
                        PROC_UNLOCK(p);
                }
                sx_sunlock(&allproc_lock);
        } else {
                sx_slock(&proctree_lock);
                if (pgid == 0) {
                        /*
                         * zero pgid means send to my process group.
                         */
                        pgrp = td->td_proc->p_pgrp;
                        PGRP_LOCK(pgrp);
                } else {
                        pgrp = pgfind(pgid);
                        if (pgrp == NULL) {
                                sx_sunlock(&proctree_lock);
                                return (ESRCH);
                        }
                }
                sx_sunlock(&proctree_lock);
                LIST_FOREACH(p, &pgrp->pg_members, p_pglist) {
                        PROC_LOCK(p);         
                        if (p->p_pid <= 1 || p->p_flag & P_SYSTEM ||
                            p->p_state == PRS_NEW) {
                                PROC_UNLOCK(p);
                                continue;
                        }
                        if (p_cansignal(td, p, sig) == 0) {
                                nfound++;
                                if (sig)
                                        pksignal(p, sig, ksi);
                        }
                        PROC_UNLOCK(p);
                }
                PGRP_UNLOCK(pgrp);
        }
        return (nfound ? 0 : ESRCH);
}

#ifndef _SYS_SYSPROTO_H_
struct kill_args {
        int     pid;
        int     signum;
};
#endif
/* ARGSUSED */
int
sys_kill(struct thread *td, struct kill_args *uap)
{
        ksiginfo_t ksi;
        struct proc *p;
        int error;

        AUDIT_ARG_SIGNUM(uap->signum);
        AUDIT_ARG_PID(uap->pid);
        if ((u_int)uap->signum > _SIG_MAXSIG)
                return (EINVAL);

        ksiginfo_init(&ksi);
        ksi.ksi_signo = uap->signum;
        ksi.ksi_code = SI_USER;
        ksi.ksi_pid = td->td_proc->p_pid;
        ksi.ksi_uid = td->td_ucred->cr_ruid;

        if (uap->pid > 0) {
                /* kill single process */
                if ((p = pfind(uap->pid)) == NULL) {
                        if ((p = zpfind(uap->pid)) == NULL)
                                return (ESRCH);
                }
                AUDIT_ARG_PROCESS(p);
                error = p_cansignal(td, p, uap->signum);
                if (error == 0 && uap->signum)
                        pksignal(p, uap->signum, &ksi);
                PROC_UNLOCK(p);
                return (error);
        }
        switch (uap->pid) {
        case -1:                /* broadcast signal */
                return (killpg1(td, uap->signum, 0, 1, &ksi));
        case 0:                 /* signal own process group */
                return (killpg1(td, uap->signum, 0, 0, &ksi));
        default:                /* negative explicit process group */
                return (killpg1(td, uap->signum, -uap->pid, 0, &ksi));
        }
        /* NOTREACHED */
}

int
sys_pdkill(td, uap)
        struct thread *td;
        struct pdkill_args *uap;
{
#ifdef PROCDESC
        struct proc *p;
        int error;

        AUDIT_ARG_SIGNUM(uap->signum);
        AUDIT_ARG_FD(uap->fd);
        if ((u_int)uap->signum > _SIG_MAXSIG)
                return (EINVAL);

        error = procdesc_find(td, uap->fd, CAP_PDKILL, &p);
        if (error)
                return (error);
        AUDIT_ARG_PROCESS(p);
        error = p_cansignal(td, p, uap->signum);
        if (error == 0 && uap->signum)
                kern_psignal(p, uap->signum);
        PROC_UNLOCK(p);
        return (error);
#else
        return (ENOSYS);
#endif
}

#if defined(COMPAT_43)
#ifndef _SYS_SYSPROTO_H_
struct okillpg_args {
        int     pgid;
        int     signum;
};
#endif
/* ARGSUSED */
int
okillpg(struct thread *td, struct okillpg_args *uap)
{
        ksiginfo_t ksi;

        AUDIT_ARG_SIGNUM(uap->signum);
        AUDIT_ARG_PID(uap->pgid);
        if ((u_int)uap->signum > _SIG_MAXSIG)
                return (EINVAL);

        ksiginfo_init(&ksi);
        ksi.ksi_signo = uap->signum;
        ksi.ksi_code = SI_USER;
        ksi.ksi_pid = td->td_proc->p_pid;
        ksi.ksi_uid = td->td_ucred->cr_ruid;
        return (killpg1(td, uap->signum, uap->pgid, 0, &ksi));
}
#endif /* COMPAT_43 */

#ifndef _SYS_SYSPROTO_H_
struct sigqueue_args {
        pid_t pid;
        int signum;
        /* union sigval */ void *value;
};
#endif
int
sys_sigqueue(struct thread *td, struct sigqueue_args *uap)
{
        ksiginfo_t ksi;
        struct proc *p;
        int error;

        if ((u_int)uap->signum > _SIG_MAXSIG)
                return (EINVAL);

        /*
         * Specification says sigqueue can only send signal to
         * single process.
         */
        if (uap->pid <= 0)
                return (EINVAL);

        if ((p = pfind(uap->pid)) == NULL) {
                if ((p = zpfind(uap->pid)) == NULL)
                        return (ESRCH);
        }
        error = p_cansignal(td, p, uap->signum);
        if (error == 0 && uap->signum != 0) {
                ksiginfo_init(&ksi);
                ksi.ksi_flags = KSI_SIGQ;
                ksi.ksi_signo = uap->signum;
                ksi.ksi_code = SI_QUEUE;
                ksi.ksi_pid = td->td_proc->p_pid;
                ksi.ksi_uid = td->td_ucred->cr_ruid;
                ksi.ksi_value.sival_ptr = uap->value;
                error = pksignal(p, ksi.ksi_signo, &ksi);
        }
        PROC_UNLOCK(p);
        return (error);
}

/*
 * Send a signal to a process group.
 */
void
gsignal(int pgid, int sig, ksiginfo_t *ksi)
{
        struct pgrp *pgrp;

        if (pgid != 0) {
                sx_slock(&proctree_lock);
                pgrp = pgfind(pgid);
                sx_sunlock(&proctree_lock);
                if (pgrp != NULL) {
                        pgsignal(pgrp, sig, 0, ksi);
                        PGRP_UNLOCK(pgrp);
                }
        }
}

/*
 * Send a signal to a process group.  If checktty is 1,
 * limit to members which have a controlling terminal.
 */
void
pgsignal(struct pgrp *pgrp, int sig, int checkctty, ksiginfo_t *ksi)
{
        struct proc *p;

        if (pgrp) {
                PGRP_LOCK_ASSERT(pgrp, MA_OWNED);
                LIST_FOREACH(p, &pgrp->pg_members, p_pglist) {
                        PROC_LOCK(p);
                        if (p->p_state == PRS_NORMAL &&
                            (checkctty == 0 || p->p_flag & P_CONTROLT))
                                pksignal(p, sig, ksi);
                        PROC_UNLOCK(p);
                }
        }
}

/*
 * Send a signal caused by a trap to the current thread.  If it will be
 * caught immediately, deliver it with correct code.  Otherwise, post it
 * normally.
 */
void
trapsignal(struct thread *td, ksiginfo_t *ksi)
{
        struct sigacts *ps;
        sigset_t mask;
        struct proc *p;
        int sig;
        int code;

        p = td->td_proc;
        sig = ksi->ksi_signo;
        code = ksi->ksi_code;
        KASSERT(_SIG_VALID(sig), ("invalid signal"));

        PROC_LOCK(p);
        ps = p->p_sigacts;
        mtx_lock(&ps->ps_mtx);
        if ((p->p_flag & P_TRACED) == 0 && SIGISMEMBER(ps->ps_sigcatch, sig) &&
            !SIGISMEMBER(td->td_sigmask, sig)) {
                td->td_ru.ru_nsignals++;
#ifdef KTRACE
                if (KTRPOINT(curthread, KTR_PSIG))
                        ktrpsig(sig, ps->ps_sigact[_SIG_IDX(sig)],
                            &td->td_sigmask, code);
#endif
                (*p->p_sysent->sv_sendsig)(ps->ps_sigact[_SIG_IDX(sig)], 
                                ksi, &td->td_sigmask);
                mask = ps->ps_catchmask[_SIG_IDX(sig)];
                if (!SIGISMEMBER(ps->ps_signodefer, sig))
                        SIGADDSET(mask, sig);
                kern_sigprocmask(td, SIG_BLOCK, &mask, NULL,
                    SIGPROCMASK_PROC_LOCKED | SIGPROCMASK_PS_LOCKED);
                if (SIGISMEMBER(ps->ps_sigreset, sig)) {
                        /*
                         * See kern_sigaction() for origin of this code.
                         */
                        SIGDELSET(ps->ps_sigcatch, sig);
                        if (sig != SIGCONT &&
                            sigprop(sig) & SA_IGNORE)
                                SIGADDSET(ps->ps_sigignore, sig);
                        ps->ps_sigact[_SIG_IDX(sig)] = SIG_DFL;
                }
                mtx_unlock(&ps->ps_mtx);
        } else {
                /*
                 * Avoid a possible infinite loop if the thread
                 * masking the signal or process is ignoring the
                 * signal.
                 */
                if (kern_forcesigexit &&
                    (SIGISMEMBER(td->td_sigmask, sig) ||
                     ps->ps_sigact[_SIG_IDX(sig)] == SIG_IGN)) {
                        SIGDELSET(td->td_sigmask, sig);
                        SIGDELSET(ps->ps_sigcatch, sig);
                        SIGDELSET(ps->ps_sigignore, sig);
                        ps->ps_sigact[_SIG_IDX(sig)] = SIG_DFL;
                }
                mtx_unlock(&ps->ps_mtx);
                p->p_code = code;       /* XXX for core dump/debugger */
                p->p_sig = sig;         /* XXX to verify code */
                tdsendsignal(p, td, sig, ksi);
        }
        PROC_UNLOCK(p);
}

static struct thread *
sigtd(struct proc *p, int sig, int prop)
{
        struct thread *td, *signal_td;

        PROC_LOCK_ASSERT(p, MA_OWNED);

        /*
         * Check if current thread can handle the signal without
         * switching context to another thread.
         */
        if (curproc == p && !SIGISMEMBER(curthread->td_sigmask, sig))
                return (curthread);
        signal_td = NULL;
        FOREACH_THREAD_IN_PROC(p, td) {
                if (!SIGISMEMBER(td->td_sigmask, sig)) {
                        signal_td = td;
                        break;
                }
        }
        if (signal_td == NULL)
                signal_td = FIRST_THREAD_IN_PROC(p);
        return (signal_td);
}

/*
 * Send the signal to the process.  If the signal has an action, the action
 * is usually performed by the target process rather than the caller; we add
 * the signal to the set of pending signals for the process.
 *
 * Exceptions:
 *   o When a stop signal is sent to a sleeping process that takes the
 *     default action, the process is stopped without awakening it.
 *   o SIGCONT restarts stopped processes (or puts them back to sleep)
 *     regardless of the signal action (eg, blocked or ignored).
 *
 * Other ignored signals are discarded immediately.
 * 
 * NB: This function may be entered from the debugger via the "kill" DDB
 * command.  There is little that can be done to mitigate the possibly messy
 * side effects of this unwise possibility.
 */
void
kern_psignal(struct proc *p, int sig)
{
        ksiginfo_t ksi;

        ksiginfo_init(&ksi);
        ksi.ksi_signo = sig;
        ksi.ksi_code = SI_KERNEL;
        (void) tdsendsignal(p, NULL, sig, &ksi);
}

int
pksignal(struct proc *p, int sig, ksiginfo_t *ksi)
{

        return (tdsendsignal(p, NULL, sig, ksi));
}

/* Utility function for finding a thread to send signal event to. */
int
sigev_findtd(struct proc *p ,struct sigevent *sigev, struct thread **ttd)
{
        struct thread *td;

        if (sigev->sigev_notify == SIGEV_THREAD_ID) {
                td = tdfind(sigev->sigev_notify_thread_id, p->p_pid);
                if (td == NULL)
                        return (ESRCH);
                *ttd = td;
        } else {
                *ttd = NULL;
                PROC_LOCK(p);
        }
        return (0);
}

void
tdsignal(struct thread *td, int sig)
{
        ksiginfo_t ksi;

        ksiginfo_init(&ksi);
        ksi.ksi_signo = sig;
        ksi.ksi_code = SI_KERNEL;
        (void) tdsendsignal(td->td_proc, td, sig, &ksi);
}

void
tdksignal(struct thread *td, int sig, ksiginfo_t *ksi)
{

        (void) tdsendsignal(td->td_proc, td, sig, ksi);
}

int
tdsendsignal(struct proc *p, struct thread *td, int sig, ksiginfo_t *ksi)
{
        sig_t action;
        sigqueue_t *sigqueue;
        int prop;
        struct sigacts *ps;
        int intrval;
        int ret = 0;
        int wakeup_swapper;

        MPASS(td == NULL || p == td->td_proc);
        PROC_LOCK_ASSERT(p, MA_OWNED);

        if (!_SIG_VALID(sig))
                panic("%s(): invalid signal %d", __func__, sig);

        KASSERT(ksi == NULL || !KSI_ONQ(ksi), ("%s: ksi on queue", __func__));

        /*
         * IEEE Std 1003.1-2001: return success when killing a zombie.
         */
        if (p->p_state == PRS_ZOMBIE) {
                if (ksi && (ksi->ksi_flags & KSI_INS))
                        ksiginfo_tryfree(ksi);
                return (ret);
        }

        ps = p->p_sigacts;
        KNOTE_LOCKED(&p->p_klist, NOTE_SIGNAL | sig);
        prop = sigprop(sig);

        if (td == NULL) {
                td = sigtd(p, sig, prop);
                sigqueue = &p->p_sigqueue;
        } else {
                KASSERT(td->td_proc == p, ("invalid thread"));
                sigqueue = &td->td_sigqueue;
        }

        SDT_PROBE(proc, kernel, , signal_send, td, p, sig, 0, 0 );

        /*
         * If the signal is being ignored,
         * then we forget about it immediately.
         * (Note: we don't set SIGCONT in ps_sigignore,
         * and if it is set to SIG_IGN,
         * action will be SIG_DFL here.)
         */
        mtx_lock(&ps->ps_mtx);
        if (SIGISMEMBER(ps->ps_sigignore, sig)) {
                SDT_PROBE(proc, kernel, , signal_discard, td, p, sig, 0, 0 );

                mtx_unlock(&ps->ps_mtx);
                if (ksi && (ksi->ksi_flags & KSI_INS))
                        ksiginfo_tryfree(ksi);
                return (ret);
        }
        if (SIGISMEMBER(td->td_sigmask, sig))
                action = SIG_HOLD;
        else if (SIGISMEMBER(ps->ps_sigcatch, sig))
                action = SIG_CATCH;
        else
                action = SIG_DFL;
        if (SIGISMEMBER(ps->ps_sigintr, sig))
                intrval = EINTR;
        else
                intrval = ERESTART;
        mtx_unlock(&ps->ps_mtx);

        if (prop & SA_CONT)
                sigqueue_delete_stopmask_proc(p);
        else if (prop & SA_STOP) {
                /*
                 * If sending a tty stop signal to a member of an orphaned
                 * process group, discard the signal here if the action
                 * is default; don't stop the process below if sleeping,
                 * and don't clear any pending SIGCONT.
                 */
                if ((prop & SA_TTYSTOP) &&
                    (p->p_pgrp->pg_jobc == 0) &&
                    (action == SIG_DFL)) {
                        if (ksi && (ksi->ksi_flags & KSI_INS))
                                ksiginfo_tryfree(ksi);
                        return (ret);
                }
                sigqueue_delete_proc(p, SIGCONT);
                if (p->p_flag & P_CONTINUED) {
                        p->p_flag &= ~P_CONTINUED;
                        PROC_LOCK(p->p_pptr);
                        sigqueue_take(p->p_ksi);
                        PROC_UNLOCK(p->p_pptr);
                }
        }

        ret = sigqueue_add(sigqueue, sig, ksi);
        if (ret != 0)
                return (ret);
        signotify(td);
        /*
         * Defer further processing for signals which are held,
         * except that stopped processes must be continued by SIGCONT.
         */
        if (action == SIG_HOLD &&
            !((prop & SA_CONT) && (p->p_flag & P_STOPPED_SIG)))
                return (ret);
        /*
         * SIGKILL: Remove procfs STOPEVENTs.
         */
        if (sig == SIGKILL) {
                /* from procfs_ioctl.c: PIOCBIC */
                p->p_stops = 0;
                /* from procfs_ioctl.c: PIOCCONT */
                p->p_step = 0;
                wakeup(&p->p_step);
        }
        /*
         * Some signals have a process-wide effect and a per-thread
         * component.  Most processing occurs when the process next
         * tries to cross the user boundary, however there are some
         * times when processing needs to be done immediatly, such as
         * waking up threads so that they can cross the user boundary.
         * We try do the per-process part here.
         */
        if (P_SHOULDSTOP(p)) {
                if (sig == SIGKILL) {
                        /*
                         * If traced process is already stopped,
                         * then no further action is necessary.
                         */
                        if (p->p_flag & P_TRACED)
                                goto out;
                        /*
                         * SIGKILL sets process running.
                         * It will die elsewhere.
                         * All threads must be restarted.
                         */
                        p->p_flag &= ~P_STOPPED_SIG;
                        goto runfast;
                }

                if (prop & SA_CONT) {
                        /*
                         * If traced process is already stopped,
                         * then no further action is necessary.
                         */
                        if (p->p_flag & P_TRACED)
                                goto out;
                        /*
                         * If SIGCONT is default (or ignored), we continue the
                         * process but don't leave the signal in sigqueue as
                         * it has no further action.  If SIGCONT is held, we
                         * continue the process and leave the signal in
                         * sigqueue.  If the process catches SIGCONT, let it
                         * handle the signal itself.  If it isn't waiting on
                         * an event, it goes back to run state.
                         * Otherwise, process goes back to sleep state.
                         */
                        p->p_flag &= ~P_STOPPED_SIG;
                        PROC_SLOCK(p);
                        if (p->p_numthreads == p->p_suspcount) {
                                PROC_SUNLOCK(p);
                                p->p_flag |= P_CONTINUED;
                                p->p_xstat = SIGCONT;
                                PROC_LOCK(p->p_pptr);
                                childproc_continued(p);
                                PROC_UNLOCK(p->p_pptr);
                                PROC_SLOCK(p);
                        }
                        if (action == SIG_DFL) {
                                thread_unsuspend(p);
                                PROC_SUNLOCK(p);
                                sigqueue_delete(sigqueue, sig);
                                goto out;
                        }
                        if (action == SIG_CATCH) {
                                /*
                                 * The process wants to catch it so it needs
                                 * to run at least one thread, but which one?
                                 */
                                PROC_SUNLOCK(p);
                                goto runfast;
                        }
                        /*
                         * The signal is not ignored or caught.
                         */
                        thread_unsuspend(p);
                        PROC_SUNLOCK(p);
                        goto out;
                }

                if (prop & SA_STOP) {
                        /*
                         * If traced process is already stopped,
                         * then no further action is necessary.
                         */
                        if (p->p_flag & P_TRACED)
                                goto out;
                        /*
                         * Already stopped, don't need to stop again
                         * (If we did the shell could get confused).
                         * Just make sure the signal STOP bit set.
                         */
                        p->p_flag |= P_STOPPED_SIG;
                        sigqueue_delete(sigqueue, sig);
                        goto out;
                }

                /*
                 * All other kinds of signals:
                 * If a thread is sleeping interruptibly, simulate a
                 * wakeup so that when it is continued it will be made
                 * runnable and can look at the signal.  However, don't make
                 * the PROCESS runnable, leave it stopped.
                 * It may run a bit until it hits a thread_suspend_check().
                 */
                wakeup_swapper = 0;
                PROC_SLOCK(p);
                thread_lock(td);
                if (TD_ON_SLEEPQ(td) && (td->td_flags & TDF_SINTR))
                        wakeup_swapper = sleepq_abort(td, intrval);
                thread_unlock(td);
                PROC_SUNLOCK(p);
                if (wakeup_swapper)
                        kick_proc0();
                goto out;
                /*
                 * Mutexes are short lived. Threads waiting on them will
                 * hit thread_suspend_check() soon.
                 */
        } else if (p->p_state == PRS_NORMAL) {
                if (p->p_flag & P_TRACED || action == SIG_CATCH) {
                        tdsigwakeup(td, sig, action, intrval);
                        goto out;
                }

                MPASS(action == SIG_DFL);

                if (prop & SA_STOP) {
                        if (p->p_flag & P_PPWAIT)
                                goto out;
                        p->p_flag |= P_STOPPED_SIG;
                        p->p_xstat = sig;
                        PROC_SLOCK(p);
                        sig_suspend_threads(td, p, 1);
                        if (p->p_numthreads == p->p_suspcount) {
                                /*
                                 * only thread sending signal to another
                                 * process can reach here, if thread is sending
                                 * signal to its process, because thread does
                                 * not suspend itself here, p_numthreads
                                 * should never be equal to p_suspcount.
                                 */
                                thread_stopped(p);
                                PROC_SUNLOCK(p);
                                sigqueue_delete_proc(p, p->p_xstat);
                        } else
                                PROC_SUNLOCK(p);
                        goto out;
                }
        } else {
                /* Not in "NORMAL" state. discard the signal. */
                sigqueue_delete(sigqueue, sig);
                goto out;
        }

        /*
         * The process is not stopped so we need to apply the signal to all the
         * running threads.
         */
runfast:
        tdsigwakeup(td, sig, action, intrval);
        PROC_SLOCK(p);
        thread_unsuspend(p);
        PROC_SUNLOCK(p);
out:
        /* If we jump here, proc slock should not be owned. */
        PROC_SLOCK_ASSERT(p, MA_NOTOWNED);
        return (ret);
}

/*
 * The force of a signal has been directed against a single
 * thread.  We need to see what we can do about knocking it
 * out of any sleep it may be in etc.
 */
static void
tdsigwakeup(struct thread *td, int sig, sig_t action, int intrval)
{
        struct proc *p = td->td_proc;
        register int prop;
        int wakeup_swapper;

        wakeup_swapper = 0;
        PROC_LOCK_ASSERT(p, MA_OWNED);
        prop = sigprop(sig);

        PROC_SLOCK(p);
        thread_lock(td);
        /*
         * Bring the priority of a thread up if we want it to get
         * killed in this lifetime.
         */
        if (action == SIG_DFL && (prop & SA_KILL) && td->td_priority > PUSER)
                sched_prio(td, PUSER);
        if (TD_ON_SLEEPQ(td)) {
                /*
                 * If thread is sleeping uninterruptibly
                 * we can't interrupt the sleep... the signal will
                 * be noticed when the process returns through
                 * trap() or syscall().
                 */
                if ((td->td_flags & TDF_SINTR) == 0)
                        goto out;
                /*
                 * If SIGCONT is default (or ignored) and process is
                 * asleep, we are finished; the process should not
                 * be awakened.
                 */
                if ((prop & SA_CONT) && action == SIG_DFL) {
                        thread_unlock(td);
                        PROC_SUNLOCK(p);
                        sigqueue_delete(&p->p_sigqueue, sig);
                        /*
                         * It may be on either list in this state.
                         * Remove from both for now.
                         */
                        sigqueue_delete(&td->td_sigqueue, sig);
                        return;
                }

                /*
                 * Give low priority threads a better chance to run.
                 */
                if (td->td_priority > PUSER)
                        sched_prio(td, PUSER);

                wakeup_swapper = sleepq_abort(td, intrval);
        } else {
                /*
                 * Other states do nothing with the signal immediately,
                 * other than kicking ourselves if we are running.
                 * It will either never be noticed, or noticed very soon.
                 */
#ifdef SMP
                if (TD_IS_RUNNING(td) && td != curthread)
                        forward_signal(td);
#endif
        }
out:
        PROC_SUNLOCK(p);
        thread_unlock(td);
        if (wakeup_swapper)
                kick_proc0();
}

static void
sig_suspend_threads(struct thread *td, struct proc *p, int sending)
{
        struct thread *td2;
        int wakeup_swapper;

        PROC_LOCK_ASSERT(p, MA_OWNED);
        PROC_SLOCK_ASSERT(p, MA_OWNED);

        wakeup_swapper = 0;
        FOREACH_THREAD_IN_PROC(p, td2) {
                thread_lock(td2);
                td2->td_flags |= TDF_ASTPENDING | TDF_NEEDSUSPCHK;
                if ((TD_IS_SLEEPING(td2) || TD_IS_SWAPPED(td2)) &&
                    (td2->td_flags & TDF_SINTR)) {
                        if (td2->td_flags & TDF_SBDRY) {
                                if (TD_IS_SUSPENDED(td2))
                                        wakeup_swapper |=
                                            thread_unsuspend_one(td2);
                                if (TD_ON_SLEEPQ(td2))
                                        wakeup_swapper |=
                                            sleepq_abort(td2, ERESTART);
                        } else if (!TD_IS_SUSPENDED(td2)) {
                                thread_suspend_one(td2);
                        }
                } else if (!TD_IS_SUSPENDED(td2)) {
                        if (sending || td != td2)
                                td2->td_flags |= TDF_ASTPENDING;
#ifdef SMP
                        if (TD_IS_RUNNING(td2) && td2 != td)
                                forward_signal(td2);
#endif
                }
                thread_unlock(td2);
        }
        if (wakeup_swapper)
                kick_proc0();
}

int
ptracestop(struct thread *td, int sig)
{
        struct proc *p = td->td_proc;

        PROC_LOCK_ASSERT(p, MA_OWNED);
        WITNESS_WARN(WARN_GIANTOK | WARN_SLEEPOK,
            &p->p_mtx.lock_object, "Stopping for traced signal");

        td->td_dbgflags |= TDB_XSIG;
        td->td_xsig = sig;
        PROC_SLOCK(p);
        while ((p->p_flag & P_TRACED) && (td->td_dbgflags & TDB_XSIG)) {
                if (p->p_flag & P_SINGLE_EXIT) {
                        td->td_dbgflags &= ~TDB_XSIG;
                        PROC_SUNLOCK(p);
                        return (sig);
                }
                /*
                 * Just make wait() to work, the last stopped thread
                 * will win.
                 */
                p->p_xstat = sig;
                p->p_xthread = td;
                p->p_flag |= (P_STOPPED_SIG|P_STOPPED_TRACE);
                sig_suspend_threads(td, p, 0);
                if ((td->td_dbgflags & TDB_STOPATFORK) != 0) {
                        td->td_dbgflags &= ~TDB_STOPATFORK;
                        cv_broadcast(&p->p_dbgwait);
                }
stopme:
                thread_suspend_switch(td);
                if (!(p->p_flag & P_TRACED)) {
                        break;
                }
                if (td->td_dbgflags & TDB_SUSPEND) {
                        if (p->p_flag & P_SINGLE_EXIT)
                                break;
                        goto stopme;
                }
        }
        PROC_SUNLOCK(p);
        return (td->td_xsig);
}

static void
reschedule_signals(struct proc *p, sigset_t block, int flags)
{
        struct sigacts *ps;
        struct thread *td;
        int sig;

        PROC_LOCK_ASSERT(p, MA_OWNED);
        if (SIGISEMPTY(p->p_siglist))
                return;
        ps = p->p_sigacts;
        SIGSETAND(block, p->p_siglist);
        while ((sig = sig_ffs(&block)) != 0) {
                SIGDELSET(block, sig);
                td = sigtd(p, sig, 0);
                signotify(td);
                if (!(flags & SIGPROCMASK_PS_LOCKED))
                        mtx_lock(&ps->ps_mtx);
                if (p->p_flag & P_TRACED || SIGISMEMBER(ps->ps_sigcatch, sig))
                        tdsigwakeup(td, sig, SIG_CATCH,
                            (SIGISMEMBER(ps->ps_sigintr, sig) ? EINTR :
                             ERESTART));
                if (!(flags & SIGPROCMASK_PS_LOCKED))
                        mtx_unlock(&ps->ps_mtx);
        }
}

void
tdsigcleanup(struct thread *td)
{
        struct proc *p;
        sigset_t unblocked;

        p = td->td_proc;
        PROC_LOCK_ASSERT(p, MA_OWNED);

        sigqueue_flush(&td->td_sigqueue);
        if (p->p_numthreads == 1)
                return;

        /*
         * Since we cannot handle signals, notify signal post code
         * about this by filling the sigmask.
         *
         * Also, if needed, wake up thread(s) that do not block the
         * same signals as the exiting thread, since the thread might
         * have been selected for delivery and woken up.
         */
        SIGFILLSET(unblocked);
        SIGSETNAND(unblocked, td->td_sigmask);
        SIGFILLSET(td->td_sigmask);
        reschedule_signals(p, unblocked, 0);

}

/*
 * If the current process has received a signal (should be caught or cause
 * termination, should interrupt current syscall), return the signal number.
 * Stop signals with default action are processed immediately, then cleared;
 * they aren't returned.  This is checked after each entry to the system for
 * a syscall or trap (though this can usually be done without calling issignal
 * by checking the pending signal masks in cursig.) The normal call
 * sequence is
 *
 *      while (sig = cursig(curthread))
 *              postsig(sig);
 */
static int
issignal(struct thread *td, int stop_allowed)
{
        struct proc *p;
        struct sigacts *ps;
        struct sigqueue *queue;
        sigset_t sigpending;
        int sig, prop, newsig;

        p = td->td_proc;
        ps = p->p_sigacts;
        mtx_assert(&ps->ps_mtx, MA_OWNED);
        PROC_LOCK_ASSERT(p, MA_OWNED);
        for (;;) {
                int traced = (p->p_flag & P_TRACED) || (p->p_stops & S_SIG);

                sigpending = td->td_sigqueue.sq_signals;
                SIGSETOR(sigpending, p->p_sigqueue.sq_signals);
                SIGSETNAND(sigpending, td->td_sigmask);

                if (p->p_flag & P_PPWAIT)
                        SIG_STOPSIGMASK(sigpending);
                if (SIGISEMPTY(sigpending))     /* no signal to send */
                        return (0);
                sig = sig_ffs(&sigpending);

                if (p->p_stops & S_SIG) {
                        mtx_unlock(&ps->ps_mtx);
                        stopevent(p, S_SIG, sig);
                        mtx_lock(&ps->ps_mtx);
                }

                /*
                 * We should see pending but ignored signals
                 * only if P_TRACED was on when they were posted.
                 */
                if (SIGISMEMBER(ps->ps_sigignore, sig) && (traced == 0)) {
                        sigqueue_delete(&td->td_sigqueue, sig);
                        sigqueue_delete(&p->p_sigqueue, sig);
                        continue;
                }
                if (p->p_flag & P_TRACED && (p->p_flag & P_PPWAIT) == 0) {
                        /*
                         * If traced, always stop.
                         * Remove old signal from queue before the stop.
                         * XXX shrug off debugger, it causes siginfo to
                         * be thrown away.
                         */
                        queue = &td->td_sigqueue;
                        td->td_dbgksi.ksi_signo = 0;
                        if (sigqueue_get(queue, sig, &td->td_dbgksi) == 0) {
                                queue = &p->p_sigqueue;
                                sigqueue_get(queue, sig, &td->td_dbgksi);
                        }

                        mtx_unlock(&ps->ps_mtx);
                        newsig = ptracestop(td, sig);
                        mtx_lock(&ps->ps_mtx);

                        if (sig != newsig) {

                                /*
                                 * If parent wants us to take the signal,
                                 * then it will leave it in p->p_xstat;
                                 * otherwise we just look for signals again.
                                */
                                if (newsig == 0)
                                        continue;
                                sig = newsig;

                                /*
                                 * Put the new signal into td_sigqueue. If the
                                 * signal is being masked, look for other signals.
                                 */
                                sigqueue_add(queue, sig, NULL);
                                if (SIGISMEMBER(td->td_sigmask, sig))
                                        continue;
                                signotify(td);
                        } else {
                                if (td->td_dbgksi.ksi_signo != 0) {
                                        td->td_dbgksi.ksi_flags |= KSI_HEAD;
                                        if (sigqueue_add(&td->td_sigqueue, sig,
                                            &td->td_dbgksi) != 0)
                                                td->td_dbgksi.ksi_signo = 0;
                                }
                                if (td->td_dbgksi.ksi_signo == 0)
                                        sigqueue_add(&td->td_sigqueue, sig,
                                            NULL);
                        }

                        /*
                         * If the traced bit got turned off, go back up
                         * to the top to rescan signals.  This ensures
                         * that p_sig* and p_sigact are consistent.
                         */
                        if ((p->p_flag & P_TRACED) == 0)
                                continue;
                }

                prop = sigprop(sig);

                /*
                 * Decide whether the signal should be returned.
                 * Return the signal's number, or fall through
                 * to clear it from the pending mask.
                 */
                switch ((intptr_t)p->p_sigacts->ps_sigact[_SIG_IDX(sig)]) {

                case (intptr_t)SIG_DFL:
                        /*
                         * Don't take default actions on system processes.
                         */
                        if (p->p_pid <= 1) {
#ifdef DIAGNOSTIC
                                /*
                                 * Are you sure you want to ignore SIGSEGV
                                 * in init? XXX
                                 */
                                printf("Process (pid %lu) got signal %d\n",
                                        (u_long)p->p_pid, sig);
#endif
                                break;          /* == ignore */
                        }
                        /*
                         * If there is a pending stop signal to process
                         * with default action, stop here,
                         * then clear the signal.  However,
                         * if process is member of an orphaned
                         * process group, ignore tty stop signals.
                         */
                        if (prop & SA_STOP) {
                                if (p->p_flag & P_TRACED ||
                                    (p->p_pgrp->pg_jobc == 0 &&
                                     prop & SA_TTYSTOP))
                                        break;  /* == ignore */

                                /* Ignore, but do not drop the stop signal. */
                                if (stop_allowed != SIG_STOP_ALLOWED)
                                        return (sig);
                                mtx_unlock(&ps->ps_mtx);
                                WITNESS_WARN(WARN_GIANTOK | WARN_SLEEPOK,
                                    &p->p_mtx.lock_object, "Catching SIGSTOP");
                                p->p_flag |= P_STOPPED_SIG;
                                p->p_xstat = sig;
                                PROC_SLOCK(p);
                                sig_suspend_threads(td, p, 0);
                                thread_suspend_switch(td);
                                PROC_SUNLOCK(p);
                                mtx_lock(&ps->ps_mtx);
                                break;
                        } else if (prop & SA_IGNORE) {
                                /*
                                 * Except for SIGCONT, shouldn't get here.
                                 * Default action is to ignore; drop it.
                                 */
                                break;          /* == ignore */
                        } else
                                return (sig);
                        /*NOTREACHED*/

                case (intptr_t)SIG_IGN:
                        /*
                         * Masking above should prevent us ever trying
                         * to take action on an ignored signal other
                         * than SIGCONT, unless process is traced.
                         */
                        if ((prop & SA_CONT) == 0 &&
                            (p->p_flag & P_TRACED) == 0)
                                printf("issignal\n");
                        break;          /* == ignore */

                default:
                        /*
                         * This signal has an action, let
                         * postsig() process it.
                         */
                        return (sig);
                }
                sigqueue_delete(&td->td_sigqueue, sig);         /* take the signal! */
                sigqueue_delete(&p->p_sigqueue, sig);
        }
        /* NOTREACHED */
}

void
thread_stopped(struct proc *p)
{
        int n;

        PROC_LOCK_ASSERT(p, MA_OWNED);
        PROC_SLOCK_ASSERT(p, MA_OWNED);
        n = p->p_suspcount;
        if (p == curproc)
                n++;
        if ((p->p_flag & P_STOPPED_SIG) && (n == p->p_numthreads)) {
                PROC_SUNLOCK(p);
                p->p_flag &= ~P_WAITED;
                PROC_LOCK(p->p_pptr);
                childproc_stopped(p, (p->p_flag & P_TRACED) ?
                        CLD_TRAPPED : CLD_STOPPED);
                PROC_UNLOCK(p->p_pptr);
                PROC_SLOCK(p);
        }
}
 
/*
 * Take the action for the specified signal
 * from the current set of pending signals.
 */
int
postsig(sig)
        register int sig;
{
        struct thread *td = curthread;
        register struct proc *p = td->td_proc;
        struct sigacts *ps;
        sig_t action;
        ksiginfo_t ksi;
        sigset_t returnmask, mask;

        KASSERT(sig != 0, ("postsig"));

        PROC_LOCK_ASSERT(p, MA_OWNED);
        ps = p->p_sigacts;
        mtx_assert(&ps->ps_mtx, MA_OWNED);
        ksiginfo_init(&ksi);
        if (sigqueue_get(&td->td_sigqueue, sig, &ksi) == 0 &&
            sigqueue_get(&p->p_sigqueue, sig, &ksi) == 0)
                return (0);
        ksi.ksi_signo = sig;
        if (ksi.ksi_code == SI_TIMER)
                itimer_accept(p, ksi.ksi_timerid, &ksi);
        action = ps->ps_sigact[_SIG_IDX(sig)];
#ifdef KTRACE
        if (KTRPOINT(td, KTR_PSIG))
                ktrpsig(sig, action, td->td_pflags & TDP_OLDMASK ?
                    &td->td_oldsigmask : &td->td_sigmask, ksi.ksi_code);
#endif
        if (p->p_stops & S_SIG) {
                mtx_unlock(&ps->ps_mtx);
                stopevent(p, S_SIG, sig);
                mtx_lock(&ps->ps_mtx);
        }

        if (action == SIG_DFL) {
                /*
                 * Default action, where the default is to kill
                 * the process.  (Other cases were ignored above.)
                 */
                mtx_unlock(&ps->ps_mtx);
                sigexit(td, sig);
                /* NOTREACHED */
        } else {
                /*
                 * If we get here, the signal must be caught.
                 */
                KASSERT(action != SIG_IGN && !SIGISMEMBER(td->td_sigmask, sig),
                    ("postsig action"));
                /*
                 * Set the new mask value and also defer further
                 * occurrences of this signal.
                 *
                 * Special case: user has done a sigsuspend.  Here the
                 * current mask is not of interest, but rather the
                 * mask from before the sigsuspend is what we want
                 * restored after the signal processing is completed.
                 */
                if (td->td_pflags & TDP_OLDMASK) {
                        returnmask = td->td_oldsigmask;
                        td->td_pflags &= ~TDP_OLDMASK;
                } else
                        returnmask = td->td_sigmask;

                mask = ps->ps_catchmask[_SIG_IDX(sig)];
                if (!SIGISMEMBER(ps->ps_signodefer, sig))
                        SIGADDSET(mask, sig);
                kern_sigprocmask(td, SIG_BLOCK, &mask, NULL,
                    SIGPROCMASK_PROC_LOCKED | SIGPROCMASK_PS_LOCKED);

                if (SIGISMEMBER(ps->ps_sigreset, sig)) {
                        /*
                         * See kern_sigaction() for origin of this code.
                         */
                        SIGDELSET(ps->ps_sigcatch, sig);
                        if (sig != SIGCONT &&
                            sigprop(sig) & SA_IGNORE)
                                SIGADDSET(ps->ps_sigignore, sig);
                        ps->ps_sigact[_SIG_IDX(sig)] = SIG_DFL;
                }
                td->td_ru.ru_nsignals++;
                if (p->p_sig == sig) {
                        p->p_code = 0;
                        p->p_sig = 0;
                }
                (*p->p_sysent->sv_sendsig)(action, &ksi, &returnmask);
        }
        return (1);
}

/*
 * Kill the current process for stated reason.
 */
void
killproc(p, why)
        struct proc *p;
        char *why;
{

        PROC_LOCK_ASSERT(p, MA_OWNED);
        CTR3(KTR_PROC, "killproc: proc %p (pid %d, %s)",
                p, p->p_pid, p->p_comm);
        log(LOG_ERR, "pid %d (%s), uid %d, was killed: %s\n", p->p_pid, p->p_comm,
                p->p_ucred ? p->p_ucred->cr_uid : -1, why);
        p->p_flag |= P_WKILLED;
        kern_psignal(p, SIGKILL);
}

/*
 * Force the current process to exit with the specified signal, dumping core
 * if appropriate.  We bypass the normal tests for masked and caught signals,
 * allowing unrecoverable failures to terminate the process without changing
 * signal state.  Mark the accounting record with the signal termination.
 * If dumping core, save the signal number for the debugger.  Calls exit and
 * does not return.
 */
void
sigexit(td, sig)
        struct thread *td;
        int sig;
{
        struct proc *p = td->td_proc;

        PROC_LOCK_ASSERT(p, MA_OWNED);
        p->p_acflag |= AXSIG;
        /*
         * We must be single-threading to generate a core dump.  This
         * ensures that the registers in the core file are up-to-date.
         * Also, the ELF dump handler assumes that the thread list doesn't
         * change out from under it.
         *
         * XXX If another thread attempts to single-thread before us
         *     (e.g. via fork()), we won't get a dump at all.
         */
        if ((sigprop(sig) & SA_CORE) && (thread_single(SINGLE_NO_EXIT) == 0)) {
                p->p_sig = sig;
                /*
                 * Log signals which would cause core dumps
                 * (Log as LOG_INFO to appease those who don't want
                 * these messages.)
                 * XXX : Todo, as well as euid, write out ruid too
                 * Note that coredump() drops proc lock.
                 */
                if (coredump(td) == 0)
                        sig |= WCOREFLAG;
                if (kern_logsigexit)
                        log(LOG_INFO,
                            "pid %d (%s), uid %d: exited on signal %d%s\n",
                            p->p_pid, p->p_comm,
                            td->td_ucred ? td->td_ucred->cr_uid : -1,
                            sig &~ WCOREFLAG,
                            sig & WCOREFLAG ? " (core dumped)" : "");
        } else
                PROC_UNLOCK(p);
        exit1(td, W_EXITCODE(0, sig));
        /* NOTREACHED */
}

/*
 * Send queued SIGCHLD to parent when child process's state
 * is changed.
 */
static void
sigparent(struct proc *p, int reason, int status)
{
        PROC_LOCK_ASSERT(p, MA_OWNED);
        PROC_LOCK_ASSERT(p->p_pptr, MA_OWNED);

        if (p->p_ksi != NULL) {
                p->p_ksi->ksi_signo  = SIGCHLD;
                p->p_ksi->ksi_code   = reason;
                p->p_ksi->ksi_status = status;
                p->p_ksi->ksi_pid    = p->p_pid;
                p->p_ksi->ksi_uid    = p->p_ucred->cr_ruid;
                if (KSI_ONQ(p->p_ksi))
                        return;
        }
        pksignal(p->p_pptr, SIGCHLD, p->p_ksi);
}

static void
childproc_jobstate(struct proc *p, int reason, int status)
{
        struct sigacts *ps;

        PROC_LOCK_ASSERT(p, MA_OWNED);
        PROC_LOCK_ASSERT(p->p_pptr, MA_OWNED);

        /*
         * Wake up parent sleeping in kern_wait(), also send
         * SIGCHLD to parent, but SIGCHLD does not guarantee
         * that parent will awake, because parent may masked
         * the signal.
         */
        p->p_pptr->p_flag |= P_STATCHILD;
        wakeup(p->p_pptr);

        ps = p->p_pptr->p_sigacts;
        mtx_lock(&ps->ps_mtx);
        if ((ps->ps_flag & PS_NOCLDSTOP) == 0) {
                mtx_unlock(&ps->ps_mtx);
                sigparent(p, reason, status);
        } else
                mtx_unlock(&ps->ps_mtx);
}

void
childproc_stopped(struct proc *p, int reason)
{
        childproc_jobstate(p, reason, p->p_xstat);
}

void
childproc_continued(struct proc *p)
{
        childproc_jobstate(p, CLD_CONTINUED, SIGCONT);
}

void
childproc_exited(struct proc *p)
{
        int reason;
        int status = p->p_xstat; /* convert to int */

        reason = CLD_EXITED;
        if (WCOREDUMP(status))
                reason = CLD_DUMPED;
        else if (WIFSIGNALED(status))
                reason = CLD_KILLED;
        /*
         * XXX avoid calling wakeup(p->p_pptr), the work is
         * done in exit1().
         */
        sigparent(p, reason, status);
}

/*
 * We only have 1 character for the core count in the format
 * string, so the range will be 0-9
 */
#define MAX_NUM_CORES 10
static int num_cores = 5;

static int
sysctl_debug_num_cores_check (SYSCTL_HANDLER_ARGS)
{
        int error;
        int new_val;

        new_val = num_cores;
        error = sysctl_handle_int(oidp, &new_val, 0, req);
        if (error != 0 || req->newptr == NULL)
                return (error);
        if (new_val > MAX_NUM_CORES)
                new_val = MAX_NUM_CORES;
        if (new_val < 0)
                new_val = 0;
        num_cores = new_val;
        return (0);
}
SYSCTL_PROC(_debug, OID_AUTO, ncores, CTLTYPE_INT|CTLFLAG_RW, 
            0, sizeof(int), sysctl_debug_num_cores_check, "I", "");

#if defined(COMPRESS_USER_CORES)
int compress_user_cores = 1;
SYSCTL_INT(_kern, OID_AUTO, compress_user_cores, CTLFLAG_RW,
        &compress_user_cores, 0, "");

int compress_user_cores_gzlevel = -1; /* default level */
SYSCTL_INT(_kern, OID_AUTO, compress_user_cores_gzlevel, CTLFLAG_RW,
    &compress_user_cores_gzlevel, -1, "user core gz compression level");

#define GZ_SUFFIX       ".gz"   
#define GZ_SUFFIX_LEN   3       
#endif

static char corefilename[MAXPATHLEN] = {"%N.core"};
SYSCTL_STRING(_kern, OID_AUTO, corefile, CTLFLAG_RW, corefilename,
              sizeof(corefilename), "process corefile name format string");

/*
 * expand_name(name, uid, pid, td, compress)
 * Expand the name described in corefilename, using name, uid, and pid.
 * corefilename is a printf-like string, with three format specifiers:
 *      %N      name of process ("name")
 *      %P      process id (pid)
 *      %U      user id (uid)
 * For example, "%N.core" is the default; they can be disabled completely
 * by using "/dev/null", or all core files can be stored in "/cores/%U/%N-%P".
 * This is controlled by the sysctl variable kern.corefile (see above).
 */
static char *
expand_name(const char *name, uid_t uid, pid_t pid, struct thread *td,
    int compress)
{
        struct sbuf sb;
        const char *format;
        char *temp;
        size_t i;
        int indexpos;
        char *hostname;
        
        hostname = NULL;
        format = corefilename;
        temp = malloc(MAXPATHLEN, M_TEMP, M_NOWAIT | M_ZERO);
        if (temp == NULL)
                return (NULL);
        indexpos = -1;
        (void)sbuf_new(&sb, temp, MAXPATHLEN, SBUF_FIXEDLEN);
        for (i = 0; format[i]; i++) {
                switch (format[i]) {
                case '%':       /* Format character */
                        i++;
                        switch (format[i]) {
                        case '%':
                                sbuf_putc(&sb, '%');
                                break;
                        case 'H':       /* hostname */
                                if (hostname == NULL) {
                                        hostname = malloc(MAXHOSTNAMELEN,
                                            M_TEMP, M_NOWAIT);
                                        if (hostname == NULL) {
                                                log(LOG_ERR,
                                                    "pid %ld (%s), uid (%lu): "
                                                    "unable to alloc memory "
                                                    "for corefile hostname\n",
                                                    (long)pid, name,
                                                    (u_long)uid);
                                                goto nomem;
                                        }
                                }
                                getcredhostname(td->td_ucred, hostname,
                                    MAXHOSTNAMELEN);
                                sbuf_printf(&sb, "%s", hostname);
                                break;
                        case 'I':       /* autoincrementing index */
                                sbuf_printf(&sb, "");
                                indexpos = sbuf_len(&sb) - 1;
                                break;
                        case 'N':       /* process name */
                                sbuf_printf(&sb, "%s", name);
                                break;
                        case 'P':       /* process id */
                                sbuf_printf(&sb, "%u", pid);
                                break;
                        case 'U':       /* user id */
                                sbuf_printf(&sb, "%u", uid);
                                break;
                        default:
                                log(LOG_ERR,
                                    "Unknown format character %c in "
                                    "corename `%s'\n", format[i], format);
                        }
                        break;
                default:
                        sbuf_putc(&sb, format[i]);
                }
        }
        free(hostname, M_TEMP);
#ifdef COMPRESS_USER_CORES
        if (compress) {
                sbuf_printf(&sb, GZ_SUFFIX);
        }
#endif
        if (sbuf_error(&sb) != 0) {
                log(LOG_ERR, "pid %ld (%s), uid (%lu): corename is too "
                    "long\n", (long)pid, name, (u_long)uid);
nomem:
                sbuf_delete(&sb);
                free(temp, M_TEMP);
                return (NULL);
        }
        sbuf_finish(&sb);
        sbuf_delete(&sb);

        /*
         * If the core format has a %I in it, then we need to check
         * for existing corefiles before returning a name.
         * To do this we iterate over 0..num_cores to find a
         * non-existing core file name to use.
         */
        if (indexpos != -1) {
                struct nameidata nd;
                int error, n;
                int flags = O_CREAT | O_EXCL | FWRITE | O_NOFOLLOW;
                int cmode = S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP;
                int vfslocked;

                for (n = 0; n < num_cores; n++) {
                        temp[indexpos] = '' + n;
                        NDINIT(&nd, LOOKUP, NOFOLLOW | MPSAFE, UIO_SYSSPACE,
                            temp, td); 
                        error = vn_open(&nd, &flags, cmode, NULL);
                        if (error) {
                                if (error == EEXIST) {
                                        continue;
                                }
                                log(LOG_ERR,
                                    "pid %d (%s), uid (%u):  Path `%s' failed "
                                    "on initial open test, error = %d\n",
                                    pid, name, uid, temp, error);
                                free(temp, M_TEMP);
                                return (NULL);
                        }
                        vfslocked = NDHASGIANT(&nd);
                        NDFREE(&nd, NDF_ONLY_PNBUF);
                        VOP_UNLOCK(nd.ni_vp, 0);
                        error = vn_close(nd.ni_vp, FWRITE, td->td_ucred, td);
                        VFS_UNLOCK_GIANT(vfslocked);
                        if (error) {
                                log(LOG_ERR,
                                    "pid %d (%s), uid (%u):  Path `%s' failed "
                                    "on close after initial open test, "
                                    "error = %d\n",
                                    pid, name, uid, temp, error);
                                free(temp, M_TEMP);
                                return (NULL);
                        }
                        break;
                }
        }
        return (temp);
}

/*
 * Dump a process' core.  The main routine does some
 * policy checking, and creates the name of the coredump;
 * then it passes on a vnode and a size limit to the process-specific
 * coredump routine if there is one; if there _is not_ one, it returns
 * ENOSYS; otherwise it returns the error from the process-specific routine.
 */

static int
coredump(struct thread *td)
{
        struct proc *p = td->td_proc;
        register struct vnode *vp;
        register struct ucred *cred = td->td_ucred;
        struct flock lf;
        struct nameidata nd;
        struct vattr vattr;
        int error, error1, flags, locked;
        struct mount *mp;
        char *name;                     /* name of corefile */
        off_t limit;
        int vfslocked;
        int compress;

#ifdef COMPRESS_USER_CORES
        compress = compress_user_cores;
#else
        compress = 0;
#endif
        PROC_LOCK_ASSERT(p, MA_OWNED);
        MPASS((p->p_flag & P_HADTHREADS) == 0 || p->p_singlethread == td);
        _STOPEVENT(p, S_CORE, 0);

        name = expand_name(p->p_comm, td->td_ucred->cr_uid, p->p_pid, td,
            compress);
        if (name == NULL) {
                PROC_UNLOCK(p);
#ifdef AUDIT
                audit_proc_coredump(td, NULL, EINVAL);
#endif
                return (EINVAL);
        }
        if (((sugid_coredump == 0) && p->p_flag & P_SUGID) || do_coredump == 0) {
                PROC_UNLOCK(p);
#ifdef AUDIT
                audit_proc_coredump(td, name, EFAULT);
#endif
                free(name, M_TEMP);
                return (EFAULT);
        }
        
        /*
         * Note that the bulk of limit checking is done after
         * the corefile is created.  The exception is if the limit
         * for corefiles is 0, in which case we don't bother
         * creating the corefile at all.  This layout means that
         * a corefile is truncated instead of not being created,
         * if it is larger than the limit.
         */
        limit = (off_t)lim_cur(p, RLIMIT_CORE);
        if (limit == 0 || racct_get_available(p, RACCT_CORE) == 0) {
                PROC_UNLOCK(p);
#ifdef AUDIT
                audit_proc_coredump(td, name, EFBIG);
#endif
                free(name, M_TEMP);
                return (EFBIG);
        }
        PROC_UNLOCK(p);

restart:
        NDINIT(&nd, LOOKUP, NOFOLLOW | MPSAFE, UIO_SYSSPACE, name, td);
        flags = O_CREAT | FWRITE | O_NOFOLLOW;
        error = vn_open_cred(&nd, &flags, S_IRUSR | S_IWUSR, VN_OPEN_NOAUDIT,
            cred, NULL);
        if (error) {
#ifdef AUDIT
                audit_proc_coredump(td, name, error);
#endif
                free(name, M_TEMP);
                return (error);
        }
        vfslocked = NDHASGIANT(&nd);
        NDFREE(&nd, NDF_ONLY_PNBUF);
        vp = nd.ni_vp;

        /* Don't dump to non-regular files or files with links. */
        if (vp->v_type != VREG ||
            VOP_GETATTR(vp, &vattr, cred) || vattr.va_nlink != 1) {
                VOP_UNLOCK(vp, 0);
                error = EFAULT;
                goto close;
        }

        VOP_UNLOCK(vp, 0);
        lf.l_whence = SEEK_SET;
        lf.l_start = 0;
        lf.l_len = 0;
        lf.l_type = F_WRLCK;
        locked = (VOP_ADVLOCK(vp, (caddr_t)p, F_SETLK, &lf, F_FLOCK) == 0);

        if (vn_start_write(vp, &mp, V_NOWAIT) != 0) {
                lf.l_type = F_UNLCK;
                if (locked)
                        VOP_ADVLOCK(vp, (caddr_t)p, F_UNLCK, &lf, F_FLOCK);
                if ((error = vn_close(vp, FWRITE, cred, td)) != 0)
                        goto out;
                if ((error = vn_start_write(NULL, &mp, V_XSLEEP | PCATCH)) != 0)
                        goto out;
                VFS_UNLOCK_GIANT(vfslocked);
                goto restart;
        }

        VATTR_NULL(&vattr);
        vattr.va_size = 0;
        if (set_core_nodump_flag)
                vattr.va_flags = UF_NODUMP;
        vn_lock(vp, LK_EXCLUSIVE | LK_RETRY);
        VOP_SETATTR(vp, &vattr, cred);
        VOP_UNLOCK(vp, 0);
        vn_finished_write(mp);
        PROC_LOCK(p);
        p->p_acflag |= ACORE;
        PROC_UNLOCK(p);

        error = p->p_sysent->sv_coredump ?
          p->p_sysent->sv_coredump(td, vp, limit, compress ? IMGACT_CORE_COMPRESS : 0) :
          ENOSYS;

        if (locked) {
                lf.l_type = F_UNLCK;
                VOP_ADVLOCK(vp, (caddr_t)p, F_UNLCK, &lf, F_FLOCK);
        }
close:
        error1 = vn_close(vp, FWRITE, cred, td);
        if (error == 0)
                error = error1;
out:
#ifdef AUDIT
        audit_proc_coredump(td, name, error);
#endif
        free(name, M_TEMP);
        VFS_UNLOCK_GIANT(vfslocked);
        return (error);
}

/*
 * Nonexistent system call-- signal process (may want to handle it).  Flag
 * error in case process won't see signal immediately (blocked or ignored).
 */
#ifndef _SYS_SYSPROTO_H_
struct nosys_args {
        int     dummy;
};
#endif
/* ARGSUSED */
int
nosys(td, args)
        struct thread *td;
        struct nosys_args *args;
{
        struct proc *p = td->td_proc;

        PROC_LOCK(p);
        kern_psignal(p, SIGSYS);
        PROC_UNLOCK(p);
        return (ENOSYS);
}

/*
 * Send a SIGIO or SIGURG signal to a process or process group using stored
 * credentials rather than those of the current process.
 */
void
pgsigio(sigiop, sig, checkctty)
        struct sigio **sigiop;
        int sig, checkctty;
{
        ksiginfo_t ksi;
        struct sigio *sigio;

        ksiginfo_init(&ksi);
        ksi.ksi_signo = sig;
        ksi.ksi_code = SI_KERNEL;

        SIGIO_LOCK();
        sigio = *sigiop;
        if (sigio == NULL) {
                SIGIO_UNLOCK();
                return;
        }
        if (sigio->sio_pgid > 0) {
                PROC_LOCK(sigio->sio_proc);
                if (CANSIGIO(sigio->sio_ucred, sigio->sio_proc->p_ucred))
                        kern_psignal(sigio->sio_proc, sig);
                PROC_UNLOCK(sigio->sio_proc);
        } else if (sigio->sio_pgid < 0) {
                struct proc *p;

                PGRP_LOCK(sigio->sio_pgrp);
                LIST_FOREACH(p, &sigio->sio_pgrp->pg_members, p_pglist) {
                        PROC_LOCK(p);
                        if (p->p_state == PRS_NORMAL &&
                            CANSIGIO(sigio->sio_ucred, p->p_ucred) &&
                            (checkctty == 0 || (p->p_flag & P_CONTROLT)))
                                kern_psignal(p, sig);
                        PROC_UNLOCK(p);
                }
                PGRP_UNLOCK(sigio->sio_pgrp);
        }
        SIGIO_UNLOCK();
}

static int
filt_sigattach(struct knote *kn)
{
        struct proc *p = curproc;

        kn->kn_ptr.p_proc = p;
        kn->kn_flags |= EV_CLEAR;               /* automatically set */

        knlist_add(&p->p_klist, kn, 0);

        return (0);
}

static void
filt_sigdetach(struct knote *kn)
{
        struct proc *p = kn->kn_ptr.p_proc;

        knlist_remove(&p->p_klist, kn, 0);
}

/*
 * signal knotes are shared with proc knotes, so we apply a mask to 
 * the hint in order to differentiate them from process hints.  This
 * could be avoided by using a signal-specific knote list, but probably
 * isn't worth the trouble.
 */
static int
filt_signal(struct knote *kn, long hint)
{

        if (hint & NOTE_SIGNAL) {
                hint &= ~NOTE_SIGNAL;

                if (kn->kn_id == hint)
                        kn->kn_data++;
        }
        return (kn->kn_data != 0);
}

struct sigacts *
sigacts_alloc(void)
{
        struct sigacts *ps;

        ps = malloc(sizeof(struct sigacts), M_SUBPROC, M_WAITOK | M_ZERO);
        ps->ps_refcnt = 1;
        mtx_init(&ps->ps_mtx, "sigacts", NULL, MTX_DEF);
        return (ps);
}

void
sigacts_free(struct sigacts *ps)
{

        mtx_lock(&ps->ps_mtx);
        ps->ps_refcnt--;
        if (ps->ps_refcnt == 0) {
                mtx_destroy(&ps->ps_mtx);
                free(ps, M_SUBPROC);
        } else
                mtx_unlock(&ps->ps_mtx);
}

struct sigacts *
sigacts_hold(struct sigacts *ps)
{
        mtx_lock(&ps->ps_mtx);
        ps->ps_refcnt++;
        mtx_unlock(&ps->ps_mtx);
        return (ps);
}

void
sigacts_copy(struct sigacts *dest, struct sigacts *src)
{

        KASSERT(dest->ps_refcnt == 1, ("sigacts_copy to shared dest"));
        mtx_lock(&src->ps_mtx);
        bcopy(src, dest, offsetof(struct sigacts, ps_refcnt));
        mtx_unlock(&src->ps_mtx);
}

int
sigacts_shared(struct sigacts *ps)
{
        int shared;

        mtx_lock(&ps->ps_mtx);
        shared = ps->ps_refcnt > 1;
        mtx_unlock(&ps->ps_mtx);
        return (shared);
}

The Project Gutenberg EBook of Tehtaan tytt, by Maria Furuhjelm

This eBook is for the use of anyone anywhere at no cost and with
almost no restrictions whatsoever.  You may copy it, give it away or
re-use it under the terms of the Project Gutenberg License included
with this eBook or online at www.gutenberg.net


Title: Tehtaan tytt

Author: Maria Furuhjelm

Release Date: June 14, 2005 [EBook #16068]

Language: Finnish


*** START OF THIS PROJECT GUTENBERG EBOOK TEHTAAN TYTT ***




Produced by Matti Jrvinen and Tuija Lindholm.





Tehtaan tytt


Kirjoittanut
Maria


Ensimmisen kerran julkaissut
Kansanvalistusseura 1912.




Tehtaantytt.

Kirjoittanut Maria.




Ern syysiltana, kun Tervolan torpan emnt ja hnen vanhin tyttrens
Miina istuivat rukkiensa ress, sanoi Miina yhtkki:

"iti, talveksi min menen tehtaaseen tyhn."

"Mit joutavia", sanoi iti seisauttaen rukkinsa.

"Niin, tll kotona olen raatanut pienest pahasesta, seitsemn,
kahdeksan vanhasta asti, ensin hoitanut lapsia, sitten elukoita, tehnyt
raskasta maatyt ja nyt tahdon pst paremmille ja helpommille
piville."

"Luuletko sin, ett tehdasty sitten on helpompaa?" virkahti Liisa
sisko, joka karstasi villoja uunin ress. "Min puuhaan puutarhassa,
lypsn lehmi tahi teen mit tahansa mieluummin kuin menen tehtaaseen."

"Aina sin siit puutarhastasi puhut", sanoi Miina ylenkatseellisesti.

"Mutta kuinka olet tullut ajatelleeksi tehtaaseen menoa?" kysyi iti.

Miina puuhaili rukkinsa ress ja sanoi: "Nivalan Leena oli kotona
juhannuksena, hn tekee tyt villatehtaassa ja sinne minkin tahdon."

Nyt tuli torpanisnt tupaan ja kvi uunin eteen lmmittelemn.

"Kuules, Antti", sanoi iti, "meidn Miina tahtoo menn tehtaaseen."

Antti ei koskaan jutellut turhia ja siksip hn nytkin vain katseli
tytrtn,

"Niin", sanoi Miina, "tehtaassa on kymmentuntinen typiv ja
pivpalkka voi nousta kahteen markkaan viiteenkymmeneen penniin saakka.
Pyhpivt saa olla vapaana. Tll kotona tytyy pyhinkin keitt
ruokaa, lyps lehmt ja ruokkia elukat. Ja Leenalla oli niin hienot
nappikengt ja ne tehtaantytt syvt vain kahvia ja vehnleip."

"Se on kovin jrjetnt", sanoi iti.

"Ja min olen kuullut, ett niiden tytyy *seist* kaiket pivt", sanoi
Liisa.

"Ents sitten, kyll min jaksan seist", sanoi Miina.

"Ja mit he tekevt muun osan piv?" kysyi Antti hitaasti.

"Enhn min tied", sanoi Miina jurosti. Hn huomasi, ett kaikki olivat
hnt vastaan.

"Jos he aamuisin nousevat neljlt tai viidelt, niin ovathan he jo
viimeistn kello kolmelta lopettaneet tyns."

"En min luule, ett he nousevat niin aikaisin aamusella," sanoi Miina,
"he tekevt tyt vain vhn keskipivll ja iltaisin he menevt
tansseihin tai kokouksiin."

"Sitten en min usko, ett heill on niin suurta palkkaa", sanoi Antti
pttvsti. "Vai kymmenen tuntia..."

"Onpahan, is", innostui Miina sanomaan, "ja tll kotona meidn tytyy
nousta kello neljlt ja ahertaa koko piv myhn iltaan, yhdeksn
asti ja keskiireell kymmeneen, jopa yhteentoistakin saakka."

Antti katsella tuijotti taas tytrtns ja sanoi hitaasti: "sin et
ainakaan nyt silt, kuin olisit tehnyt liiaksi tyt. Punainen ja
pyre olet. Pulskemmaksi et voi tulla kahvista ja vehnleivst. Mutta
mene vaan tehtaaseen, koska et huoli Lintulan Kasperista, talollisen
pojasta."

"Is, kuinka voit sanoa niin", huudahti iti, "kyllhn Miina tarvitaan
kotonakin ja ne tehtaantytt ovat niin kelvottomia."

"En min aio tulla kelvottomaksi", sanoi Miina, "Liisa voi auttaa iti,
hnhn on jo seitsemnnelltoista ja pojat auttavat is."

"Niin, kyllhn tll toimeen tullaan", sanoi Antti ja katseli
tyytyvisen suurikasvuisia, reippaita poikiaan. "Niin, ja saattaahan se
olla hyvkin, ett joku lapsista ansaitsee rahaa."

Is riisui mrjt saappaat jalastaan ja Liisa toi hnelle heti kuivat,
lmpimt sukat ja ehet tallukat. Sitten hn ripusti isn mrjt sukat
nuoralle uunin taakse kuivamaan, sulloi saappaat tyteen heini ja pani
ne mrki jalkineita varten laitetulle telineelle, joka oli kiinnitetty
kattoon.

Kaikki olivat tn iltana jotenkin hiljaiset. Miinan tehtaaseen meno
heit huolestutti. Vain nelivuotias Tiina jutteli nukkensa ja kissansa
kanssa.

Mutta iti oli levoton ja ptti menn pappilaan puhumaan papinrouvan
kanssa.

       *       *       *       *       *

Toimitettuaan aamuaskareensa seuraavana pivn, silitti emnt
hiuksensa, sitoi parhaan huivin phns, pani puhtaan esiliinan eteens
ja meni pappilaan muka viemn lmpimisi papinrouvalle.

"Nyt iti menee kertomaan papinrouvalle, ett Miina aikoo lhte
tehtaaseen", sanoi Matti-veli silmt veitikkamaisessa hymyss katsellen
iti ikkunasta.

"Menkn vaan, ei papinrouva voi kielt minua lhtemst", uhmaili
Miina.

"Mutta et suinkaan sin mene tehtaaseen, jos se papinrouvan mielest on
tuhmasti tehty?" kysyi Liisa.

"Menenphn", vastasi Miina.

Sisarukset vaikenivat. He olivat tottuneet tydellisesti luottamaan
papinrouvan viisauteen ja hyvyyteen, rouvahan oli antanut idille niin
monta hyv neuvoa ja oli ollut perheen ystv niin hyvin surussa kuin
ilossa. -- --

Tervolan emnt istui papinrouvan kanssa pappilan ruokasalissa. Rouva
huomasi kyll, ett hnell oli jotain sydmelln, mutta ei tahtonut
kysy, mit se oli. Kyllphn kertoo, kun enntt, arveli rouva. Kun
kahvit oli juotu ja rouva taas oli ottanut tyn kteens, virkahti Anna:

"Ajatelkaahan, hyv rouva, Miina tahtoo menn tehtaaseen."

"Miina!" huudahti rouva. "Hnenhn on niin hyv olla kotona ja onhan hn
ollut hyvksi avuksi sek sinulle ett miehellesi."

"Niin, onhan hn ollut, mutta hnen mielestn hnell on kotona liiaksi
tyt", naurahti Anna.

"No, miksei hn sitten tahtonut menn naimisiin talollisen pojan
kanssa?"

"Eiphn tahtonut", sanoi Anna hymyillen. "Kas, meidn tyttjen on niin
hyv olla kotona. Vaikka meill on vain torppa, ja tytt ovat saaneet
tehd aika lailla tyt, niin on heidn elmns tyyni ja huoleton. On
vallan toista tehd tyt vierasten luona. Is on ryyppmtn ja
hyvnluontoinen, eik kaikilla torpantytill ole niin hauskaa kotia
eik puutarhaa, eik niin hyv ruokaa kuin meidn tytill on. Miina
kyll tiet, ett elm olisi vallan toisellaista, jos hnell olisi
suuri talous ja ankara anoppi. Ja jos sanon tyden totuuden, niin on
koko Lintulan talo kuin suuri roskalj."

"Mutta nyt Miina tahtoo pois siit hauskasta kodista", ihmetteli
papinrouva.

"Niinhn tuo tahtoo, se Nivalan Leenahan hnet siihen on viekoitellut.
Leena oli kesll pari piv kotona ja nytteli Muualle kauniita
puseroitaan ja nappikenkin ja puhui kahvista ja vehnleivst."

Papinrouva huokasi: "sehn se tavallisesti houkuttelee nuoria tyttj."

"Min pelkn enimmin huonoa esimerkki", sanoi Anna, "Olen kuullut,
ett kaikki tehtaantytt ovat huonoja ihmisi."

"Eihn toki, Anna", sanoi papinrouva vakavasti, "mutta ne raukat tulevat
usein niin nuorina ja kokemattomina tehtaaseen. Ne, joilla ei ole kotia,
asuvat yhdess toisten yht nuorten ja lukemattomien, ehkp jo
turmeltuneiden tyttjen kanssa. He ovat ilman turvaa, joutuvat helposti
huonoon seuraan, eivtk ymmrr arvostella ihmisi. Heill ei ole
ketn, jolta kysyisivt neuvoa, ei ketn, jonka puoleen voisivat
knty. Siksi he helposti joutuvat kiusaukseen ja lankeevat. Mutta
heidn joukossaan on monta hyv ja kunnollista tytt. Ja onhan Miina
saanut kasvaa kahdeksannentoista ikvuoteensa asti hyvss kodissa.
Hnen pitisi voida pysy hyvill teill. Ja sit paitsi hn on vakava
ja kelpo tytt."

"Niin, onhan hn", mynsi Anna, "mutta eik rouva kumminkin kieltisi
hnt menemst tehtaaseen? Menkn ennemmin palvelukseen, jos tahtoo
pois kotoa."

"Min en tekisi oikein, jos sekaantuisin asiaan", sanoi papinrouva
ystvllisesti taputtaen Annaa olkaplle. "Miina on kesst saakka
ajatellut tt asiata, ja vaikka hn minunkin mielestni tekee tyhmsti
jttessn hyvn kotinsa, jossa hnell on tarpeeksi tyt, niin on
parasta, ett nuoret saavat koettaa, milt tuntuu maailmallaolo, kun
eivt en viihdy kotona. Jos on kasvattanut lapsensa Jumalan pelvossa
ja hyviss tavoissa ja opettanut heit tekemn tyt, niin voi
tyyneesti lhett heidt maailmalle. Jos sin nyt kieltisit hnt
menemst, niin hn ehk tekisi tyytymttmsti tyns tll kotona ja
toivoisi vain pois ja kuvittelisi, ett olo tehtaassa olisi niin paljon
parempaa. Mutta jos annat hnen koettaa, niin on mahdollista, ett hn
tulee takaisin jonkun ajan kuluttua. Juuri siksi, ett Miinalla on niin
hyv koti ja ett hn on niin jrkev tytt, toivon min kaiken kyvn
hyvin."

Anna huokasi syvn. Hn oli todellakin toivonut, ett papinrouva
sekaantuisi asiaan, neuvoisi Miinaa, niin, vielp kieltisik hnt
menemst tehtaaseen. Mutta kotimatkalla hn ajatteli tarkemmin asiata
ja tuli lopulta vakuutetuksi siit, ett rouva oli oikeassa.

Kun hn astui tupaan, seisoi Liisa uunin ress laittamassa ruokaa,
Miina kirnusi voita ja pikku Tiina nukkui sngyss. Is ja pojat olivat
metsss.

Molemmat tytt katselivat uteliaina iti, kun hn pani huivinsa arkkuun
ja otti esiin rukkinsa.

"No, mit papinrouva sanoi Miinasta?" kysyi Liisa kiihkesti.

"Rouva arveli, ett antaa vaan Miinan menn, kosk'ei hn en viihdy
kotona", sanoi iti tyyneesti.

Miina nytti hieman nololta. Hn oli varustautunut vastarintaan, eik
sit nyt tarvittukaan. Nivalan Leena oli maininnut, ett Pyhinmiesten
pivst tuli yksi paikka tehtaassa vapaaksi, nyt tytyi vain kirjoittaa
sinne ja laittaa Miinan vaatteet kuntoon. -- --

Viimeist yt makasi Miina kotona vanhassa sngyss Liisan vieress.
Kyyneleet tulivat hnen silmiins ja hnen sydntns ahdisti, kun hn
ajatteli tuntematonta tulevaisuuttaan, hnt pelotti lhte yksin
vierasten ihmisten pariin. Kuinka hn saattoikaan jtt isn, idin ja
sisarukset? Mutta sitten hn taas rupesi ajattelemaan kaikkea, mit
Leena oli kertonut, ja laskiessaan, miten paljon rahaa hn ansaitsisi
yhdess vuodessa, vaipui hn syvn, rauhalliseen uneen.

       *       *       *       *       *

Oli kevt ja kiire pellolla ja puutarhassa. Pitkt kankaat olivat
valkenemaan osoitteena idin ja Liisan ahkeruudesta. Pari lihavaa,
hienokarvaista vasikkaa ammui navetassa. Lampaat kyd, tepastelivat
edestakaisin, kun karsinaa puhdistettiin. Kukko kiekui ja kanat nokkivat
ja kuopivat pihalla lhell tunkiota. Kaikki nytti niin hauskalta ja
iloiselta, mutta Liisa istui portailla ja itki katkerasti.

Silloin astui papinrouva verjst pihalle.

"Mik nyt on htn, rakas lapsi?" kysyi hn slivsti,

"Velli psi palamaan pohjaan", nyyhkytti Liisa, "ja kaikki olivat niin
vihaiset minulle. iti sanoi, ett tuli suuri vahinko, kun ruoka
pilaantui, pojat ilkkuivat ja Tiina sylksi vellin suustaan ja is ....
sanoi, ett se oli puutarhan syy. Mutta ei se sen syy ollut. Tytyihn
minun tietystikin kaivaa multa pehmeksi raparperin ja ruohosipulin
ymprilt, kun minut oli jtetty kotiin pivllist laittamaan. Mutta
min juoksin alinomaan tupaan hmmentmn pataa. Vaan sitten en
huomannutkaan, ett Tiina meni sisn ja ett se pikku ilkimys tynsi
koko hellan tyteen puita, niin ett velli paloi pohjaan. Kun on kdet
tynn ... eik Tiina tee koko pivn muuta kuin pahaa. Mutta min en
tahtonut kannella islle, sill silloin Tiina olisi saanut selkns."

"Se oli hyvin tehty, Liisa, Tiinahan on viel niin pieni ja
ymmrtmtn. l itke en. Min opetan sinua keittmn velli niin,
ettei se koskaan pala pohjaan."

Liisa pyyhki kiireesti kyyneleens. Hn uskoi papinrouvan voivan tehd
mit tahansa ja katseli hnt suurella luottamuksella.

"Milloin teill ensi kerta keitetn puuroa tai velli?" kysyi rouva.

"Lauantaina", vastasi Liisa.

Rouva oli kerran ullakolla nhnyt suurenlaisen nelisnurkkaisen
puulaatikon, jossa oli spill eli hakasella kiinni pantava kansi. Hn
lhetti Liisan pappilaan noutamaan muutamia voilokinpalasta, joita oli
kytetty pianoa pappilaan kuljetettava. Sitten hn naulasi
voilokinpalaset laatikon sispuolelle, sulloi sen heini tyteen ja vei
sen taas ullakolle. Kun kaikki olivat lauantai-aamuna menneet tyhn,
tuli papinrouva Tervolaan. Hn voiteli suuren padan Pohjan voilla, pani
sen puolilleen vett ja pisti sen tulelle. Kun vesi kiehui, vispilitiin
ohraryynit siihen sekaan. Kun Liisa oli huolellisesti hmmentnyt puuroa
noin neljnnestunnin niin, ett koko seos kiivaasti kiehui, nostettiin
pata tulelta, tiukasti sopiva kansi pantiin padan plle ja pata
pistettiin laatikkoon syvlle heiniin. Heintyyny asetettiin
padankannelle ja sitten suljettiin laatikon kansi spill.

"Kun vki tulee pivlliselle, niin on puuro valmista", sanoi
papinrouva.

Liisa katsoi vuoroin rouvaan, vuoroin laatikkoon ja nkytti: "mutta,
mutta..."

"Puuro kypsyy hiljalleen padassa", selitti rouva, "mutta ei saa avata
kantta eik laskea ulos lmmint."

"Mutta ei suinkaan se vaan pala pohjaan?" kysyi Liisa.

"Ei pala", vakuutti rouva.

"Ja kypsyykhn se? Kun ne kaikki tulevat kotiin, on niill nlk kuin
susilla."

"Kyll se kypsyy", vastasi rouva ja katsoi kelloaan.

Sitten hn meni kotiin.

Kun Liisa nki isn, idin ja veljet pihalla, aukaisi hn peloissaan
laatikkonsa.

Kypsn, maukkaan ohrapuuron tuoksu lemusi hnt vastaan padasta. Hn
otti lusikan ja maistoi. Ryynit olivat pehmet ja puuro oli sopivan
paksua. Hn kaasi puuron vatiin. iti pani voisilmn siihen ja sitten he
kaikki istuutuivat pytn.

"Nyt luulen, ett olet tuhlannut voita", sanoi iti sytyn pari
lusikallista.

"Puuro on niin hyv", kiittelivt pojat.

"Niin, mutta sin olet kai keittnyt sen paljaassa maidossa", sanoi
iti.

Liisa nauroi niin, ett hytki.

"Puuro on keitetty paljaaseen veteen ja voita siin on juuri yht
paljon, kuin muulloinkin on ollut", vakuutti hn. "Min olen keittnyt
puuron tiukkakantisessa laatikossa ja siksi se on niin hyv."

iti huomasi nyt laatikon, nki, ettei ollut tulta pesss, ja katsoi
kummissaan tyttn. Pojat juoksivat laatikolle ja tunnustelivat heini.
Aivan oikein, heint olivat viel lmpiset.

"Papinrouva on ihan varmaan ollut tll", sanoi iti, "kyllhn min
nyt muistan, ett hn kerran puhui heiniss keittmisest, mutta en ole
tullut panneeksi sit mieleeni. Kun meill on puita tarpeeksi, niin ei
tule ajatelleeksi semmoista."

"Kyllhn se niinkin on", riensi Liisa sanomaan, "mutta tll tavoin ei
puuro pala pohjaan." Ja sitten hn kertoi, ett papinrouva oli nhnyt
hnen itkevn, kun hnt oli nuhdeltu siksi, ett velli oli pohjaan
palanutta.

"Ei silt rouvalta koskaan konstit puutu", tuumi Antti itsekseen.

Nytks oli Liisasta hauskaa, melkein joka piv hn keitti ruokaa
heinlaatikossa. Milloin laittoi hn puuroa, milloin velli, milloin
perunakeittoa, milloin uunijuustoa. Sill'aikaa kun ruoka kypsyi, teki
hn tyt puutarhassa tahi pihamaalla, juotti vasikat, sytti porsaat ja
piti pikku Tiinaa tyss niin, ettei tm pssyt tekemn niin paljon
pahaa.

Mutta kerran kvi hullusti.

Liisa ei ollut varannut tarpeeksi aikaa hernekeittoa varten ja herneet
olivat vain puolikypst, kun muut perheenjsenet tulivat pivlliselle.
Silloin hnt taas toruttiin ja taas hn itki, mutta hmriss hn otti
pikku Tiinan syliins ja riensi pappilaan. Ja papinrouva antoi hnelle
pienen kirjoituksen, jossa oli neuvoja niille, jotka tahtoivat keitt
heiniss.

*Hernekeiton* tytyy olla heinlaatikossa 5 tahi 6 tuntia. Sen saattaa
jo edellisen iltana kiehauttaa ja pist heinlaatikkoon ja sitten
keitt uudestaan aamulla. Kuutta desilitraa herneit kohti tarvitaan 3
litraa vett. *Riisi-*, *ohra-* ja *tattariryynit* tarvitsevat
kypsykseen 3 tuntia. Nelj desilitraa ryynej kohti tarvitaan 2 litraa
vett tai maitoa. *Mankeloitujen kauraryynien* tarvitsee olla laatikossa
vain tunnin. *Isot ohraryynit* tarvitsevat 5--6 tuntia kypsykseen
laatikossa ja imevt itseens enemmn vett kuin pieniksi survotut
ryynit.

*Lampaanlihaa ja kaalia* valmistetaan seuraavasti: 1 kilo pieniksi
palasiksi leikattua lampaanlihaa, 20 kuorittua perunaa, 1 1/2 litraa
hienoksi leikattua kaalia, 1 litra vett, vhn suolaa, sipulia ja
muutama pippurinjyv keitetn hyvll tulella 20 minuuttia. Pata
asetetaan heinlaatikkoon 4--5 tunniksi. Kantta ei saa nostaa
katsoakseen, onko ruoka valmista, sill silloin psee lmp ulos
laatikosta. Kun on ottanut ruuan heinist, voi sen viel kiehauttaa
tulella. -- Vhn tottumusta ja harjoitusta tarvitaan, jotta oppisi
keittmn heiniss.

       *       *       *       *       *

Miina oli ollut poissa kotoa melkein kaksi vuotta. Hn oli hidas
kirjeiden kirjoittaja ja kotivki tiesi hnest kovin vhn. Alussa hn
kertoi joka viikko panevansa rahaa sstn postisstpankkikirjaansa,
mutta sitten hn rupesi valittamaan, etteivt rahat tahtoneet riitt
hnen menoihinsa. iti lhetti hnelle silloin tllin parin sukkia ja,
kun suutari oli Tervolassa tyss, tehtiin Miinan vanhan mitan mukaan
pari lujia vasikannahkakenki, jotka lhetettiin hnelle kaupunkiin.
Mutta vhn vli Miina kirjoitti vielkin, ett kaikki oli niin
kallista. -- --

Jouluna piti Miinan pst kotiin kolmeksi pivksi. Tervolassa oli ilo
ylimmilln. Kaikki joulupuuhat toimitettiin vikkelsti. Liisa puhdisti
joka nurkan. Tiina juoksi hnen kintereilln ja auttoi hnt. Liisa
harjasi lehmt tavallista huolellisemmin sek leipoi idin kanssa
ohraleipi, joista Miina niin kovasti piti. Pojat loivat teit
pihamaalle, puhdistivat tallin, ajoivat kotiin heini ja olkia ja puita
pyhiksi sek lmmittivt saunan.

Antti oli itse lhtenyt noutamaan Miinaa kotiin ja heidn ajaessaan
pihalle riensivt kaikki tuvasta portaille tulijoita vastaan. Helisev
pakkanen oli purrut Miinan posket ja nennipukan koreanpunaisiksi. Kun
hn tupaan tultuaan oli riisunut saalin pstn, arvelivat kaikki, ett
hn oli jotensakin samannkinen kuin ennenkin. Mutta kun puna poskista
oli haihtunut, huomasi iti, miten kalpeaksi ja laihaksi hnen tyttns
oli muuttunut. Liisa ja Tiina huomasivat heti hnen kirjavan puseronsa
ja leven nahkavyn, joka teki hnet niin hoikaksi vytisilt. Kdet
olivat hienot ja valkoiset. Saattoi tuskin uskoa, ett tm tytt, jonka
tukka oli kammattu korkealle plaelle, oli se entinen vahva,
punaposkinen Miina, jonka vaaleat, paksut palmikot riippuivat niskassa,

"Voi, kuinka hyvlt puuro tll kotona maistuu", virkahti Miina,
sytyn pari lusikallista, "ja kuinka punaisilta ja terveilt te
nyttte", lissi hn katseltuaan vanhempiaan ja sisaruksiaan. "Min
olen niin tottunut nkemn vaan kalpeita tehtaantyttj."

"Niin, sin et ole tullut lihavammaksi kahvista ja vehnleivst", sanoi
is puoleksi leikill.

Miina oli hieman hmilln ja sanoi: "ensi kerran pitkn aikaan minun
on nlk."

"Eik sinun ole nlk joka piv?" kysyi Matti silmt pyrein.

"Ei ole. Ja sit kyllstyy niin kovasti kahviinkin."

"Kyllstyy kahviin!" kirkasi pikku Tiina, joka sai maistaa tt juomaa
vain suurina juhlina ja sunnuntaisin. Kaikki nauroivat, mutta iti
sanoi: "olet matkustanut raittiissa ilmassa, siksi olet saanut
ruokahalun."

"Kai se niin on. Tehtaassa haisee ljylt ja on niin kuuma, enk min
ky ulkona muuta kuin tyhn mennessni ja sielt kotiin tullessani." --
--

Pyhpiviksi oli kaikki ksityt pantu syrjn. Sytettiin vain elukat
ja valmistettiin ateriat. Is ja pojat antoivat hevosille heini ja
kauroja sek toivat puita ja vett. Siksi oli koko perheell hyv aika
istua tuvassa ja puhella tahi oikeammin kuunnella Miinan puhetta, sill
hn kertoi tystn tehtaassa ja elmstn kaupungissa. Miina, joka
aina oli ollut niin harvapuheinen, oli ruvennut puhumaan niin paljon.
Hn oli lukenut kirjoja ja sanomalehti lukutuvassa ja kynyt huveissa
ja kokouksissa.

Kun Anna toisena joulupivn oli lukenut saarnan ja kun kaikki yhdess
olivat veisanneet muutamia virsi, alkoivat he taas puhua tehtaasta.

"Mit te sunnuntaisin teette?" kysyi Liisa.

"Ensin nukutaan oikein kauan ja sitten juodaan kahvia", vastasi Miina,
"ja sitten kherretn hiukset, pannaan parhaat vaatteet ylle ja mennn
jonkun tuttavan tyk kahville. Pivllisen jlkeen taas kvelln.
Hauskinta on silloin niill, joilla on sulhanen. Ja sitten mennn ehk
lukusaliin tahi johonkin kokoukseen."

"Sinunhan piti panna rahaa pankkiin", sanoi is vhn levottomana.
Miinan tehdasty oli koko ajan ollut islle vain rahakysymys.

"Niin, mutta min olen ottanut pois pankista sen vhn, mink sinne
alussa panin", sanoi Miina alakuloisena.

Miina oli ottanut kaikki vaatteensa mukaansa voidakseen nytt
kotovelle koko koreutensa. Hn oli asettanut sisarten ihailtavaksi
hameita, puseroita, pitsej, kaulanauhoja, kenki, rintasolkia,
vaaleanharmaan "saketin" sek valkoisen levelierisen olkihatun, joka
oli vihreit lehti, kirsimarjaterttuja ja omenankukkia tynn. Mutta
iti sanoi: "kyllp tytyy olla suuri palkka, jotta voisi ostaa
tuollaisia vaatteita ja noin paljon sitten! Tuohon koreuteenhan ne rahat
ovat menneet."

"Enhn min voi kyd huivi pss, kun muut ovat hattupisi", sanoi
Miina resti.

"Yksinkertainen olkihattu, jossa on musta tai kirjava nauha, ei maksa
enemp kuin hyv huivi, niin ett ei se hattu paljoakaan rahaa niele",
sanoi iti tyyneesti, "mutta kukat ja tuo muu roska, joka pilaantuu
sateessa ja tomussa, ja kaikki nuo pitsit ja puserot, ne ne rahaa
vievt. En olisi koskaan uskonut, ett sin, Miina, joka olit niin
jrkev, olisit antanut viekoitella itsesi sellaiseen. Kyh tytt ei
tarvitse muuta kuin yhden typuvun ja yhdet pyhvaatteet. Silloin voi
hankkia itselleen myskin hyvt alusvaatteet, mutta sinun hyvt paitasi,
jotka sait kotoa, nyttvt huonoilta, etk sin ole paikannut, etk
pitnyt niit kunnossa."

"Mutta iti, koska luulette minun ehtivn ommella?" virkahti Miina.

Is otti piipun suustaan ja sanoi: "etk sin ehdi ommella itsellesi
niin neljntoista tuntina, jolloin et ole tyss?"

Miina ei heti voinut vastata mitn ja silloin huusi pikku Tiina: "nyt
tulee papinrouva!"

Liisa riensi puhaltamaan hiilosta ja panemaan kahvipannua tulelle ja
iti meni ulos ottamaan vastaan kunnioitettua vierasta.

Tervehdittyn ystvllisesti kaikkia, kntyi papinrouva Miinan
puoleen.

"Minun tytyi oikein tulla tervehtimn sinua, kun kuulin, ett viivyt
kotona vain pari piv", sanoi hn. "Sin olet tullut niin laihaksi ja
kalpeaksi, rakas lapsi."

Miina punastui ja niiasi.

"Min olen sanonut samaa", virkkoi Anna huolestuneena. "Miinahan oli
niin pyre ja punaposkinen."

"Tehdasty on epterveellisemp kuin maaty ja taloustoimet", sanoi
rouva. "Ilma on huono ja sinun tytyy kai seist?"

"Tytyy, koko piv. Ensi alussa olivat jalkani turvonneet ja niit
srki niin, etten saanut unta iltaisin, mutta nyt olen tottunut
seisomaan."

"Mutta hoidatkohan muuten itsesi jrkevsti", kysyi papinrouva
ystvllisesti, "vai eltk kahvilla ja vehnleivll, niinkuin niin
monet muutkin nuoret tylisnaiset."

"Hn on kyllstynyt kahviin", kirkasi pikku Tiina, ja hnen
liinatukkainen pns pilkisti esiin idin tuolin takaa.

"Oi, oi", nauroi papinrouva, "eiks ole parempi saada kahvia vain
silloin tllin, pikku Tiina. Silloin se aina maistuu hyvlt."

"Niin, ja sitten tulee niin terveeksi ja vahvaksi, kun sy maitoa ja
leip", selitti pikku Tiina.

"Ei sit ehdi keitt ruokaa itselleen, kun on vaan tunnin
pivllisaika", sanoi Miina. "Ostetaan vhn vehnleip ja keitetn
pannu kahvia. Se ky niin nopeasti."

"Hnell on vaan neljtoista tuntia joutoaikaa", sanoi Antti
naureskellen, "mitp hn ehtisi keitt ja paistaa."

"Is on niin paha, kun aina vatkuttaa tuota neljntoista tuntia", sanoi
Miina itku kurkussa, "tytyyhn sit nukkua ja levtkin."

"l ole pahoillasi, Miina, leikkihn se is vain laskee", sanoi iti
sovitellen. "Kyllhn sin tiedt, ett meidn tll Tervolassa tytyy
tehd tyt paljon enemmn kuin kymmenen tuntia. Siksihn sin juuri
lksitkin pois kotoa."

"Mutta tll kotona ei tarvitse *seisoa* koko piv."

"Ei, sin sait istua kangaspuissa ja rukin ress", sanoi iti
naurahtaen.

Nyt oli kahvi valmis, ja koska oli juhlapiv, sai pikku Tiinakin
kupillisen sit sek suuren viipaleen vehnleip.

Kun Liisa oli vienyt pois kahvivehkeet, otti hn esiin heinlaatikkonsa
ja rupesi lieden ress valmistelemaan mannaryynipuuroa pivlliseksi.

"Kuuleppas, Miina", sanoi Antti, "keittisit puuroa laatikossa, niinkuin
Liisa tekee." Is nauroi harvoin, mutta nyt hn nauroi oikein sydmens
pohjasta.

"Niin, sehn ky erinomaisesti", virkahti iti ihastuksissaan.

Miina katseli hmmstyneen laatikkoa. Hn luuli, ett he laskivat
leikki. Mutta Liisa alkoi innokkaasti selitt, kuinka hn teki, ja
vakuutti, ett puuro tahi mik muu ruoka tahansa kiehui itsekseen
laatikossa. Papinrouva oli opettanut sen heille.

"Is osui oikeaan", sanoi rouva. "Vhll vaivalla ja huolella voit
hankkia itsellesi hyv ja terveellist ruokaa sill palkalla, mik
sinulla on. Mutta vaivaa siit on, eivtk rahat silloin riit
ylellisiin koristuksiin. Min nin Helsingiss tyttj, joita asui kuusi
yhdess pieness huoneessa, he sivt silli ja leip ja joivat kahvia
plle, voidakseen sunnuntaisin kyd hienoissa vaatteissa ja hatuissa
sek huvitella itsen sirkuksessa, tansseissa ja teatterissa. Mutta
semmoiset tytt menettvt pian terveytens, ja jos he menevt
naimisiin, niin heist tulee heikkoja ja kivulloisia vaimoja ja heidn
lapsensa ovat sairaalloisia tai kuolevat ensimisell ikvuodellaan. Jos
tahdot koettaa syd snnllisesti sek muuten el jrkevsti, niin
saat nhd, ett pian tulet vahvaksi ja terveeksi, ett teet tyt
ilolla ja innolla sek tunnet olevasi nuori ja reipas. Min tunnen tuon
tehtaan, jossa teet tyt. Mutta miss sin asut?"

"Min asun leipuri Koskelinilla Nivalan Leenan kanssa."

"Hyv. Leipuri ja hnen vaimonsa ovat hyv ja kunnollista vke ja
Nivalan Leena on kelpo tytt. On hauskaa kuulla, ett olet joutunut
hyvn seuraan."

"Olisiko rouva niin hyv ja neuvoisi, mit minun pit tehd", sanoi
Miina ujosti. "Kyll Nivalan Leena suostuu siihen, ett me laitamme
ruokaa."

"Mielellni tahdon sen tehd", sanoi papinrouva ystvllisesti.

"*Puhutaan nyt ensin ruuasta.*

*Kahvia* sinun ei pid juoda enemp, kuin kerta tai kahdesti pivss.

Seulomattomista jauhoista leivottu *ruis-* ja *hiivaleip* on
ravitsevampaa kuin seulotuista jauhoista laitettu leip.

*Vehnleip* voit syd kahvia juodessasi.

*Maito* ja maitoruoka on terveellist.

*Lihaa*, tuoretta, suolattua tai savustettua, voit kyll joskus hankkia
itsellesi.

*Silli* ja *suolattu silakka* antaa ruokahalua, kun on kauan tehnyt
tyt sisll.

*Perunoita* olet tottunut symn jo lapsuudesta asti. Niist voit
laittaa perunapuuroa, muhennusta, voit keitt ne kokonaisina tahi
paistaa tuhassa.

Is laittaa sinulle vhn pienemmn, mutta muuten samanlaisen
heinlaatikon kuin tll kotonakin on. Sit paitsi tytyy sinun hankkia
tulikivi, jonka panet kamarisi uuniin. Kun talvella lmmitt uunia,
tulee tulikivi tulikuumaksi. Silloin panet lkkilaatikkoon perunakeittoa
tahi manna- tai tattaripuuroa, jonka sit ennen olet kiehauttanut,
suljet pellit ja menet tyhsi. Kun tulet kotiin, on ruoka valmista,
sill tulikivi pysyy lmpimn monta tuntia.

Jos tahdot keitt heinlaatikossa, niin keitt ensin veden tai maidon
ja ryynit kamarisi uunissa tahi, jos leipurinvki sallii, niin keitt
heidn hellallaan. Kun puuro tai velli kiivaasti kiehuu, pistt padan
heinlaatikkoon. Mutta padan plle tytyy panna tiukasti sopiva kansi
ja tmn plle tytyy viel asettaa heintyyny. Laatikon kansi
suljetaan spill. Ja sitten voit menn tyhsi. Ruoka ei pala pohjaan,
sit ei tarvitse hmment, siihen ei tarvitse list mitn. Se on
valmista, kun tulet kotiin,"

"Mithn Leena sanoo!" huudahti Miina hmmstyneen.

"Voit myskin laittaa lihamuhennusta", jatkoi rouva, "mutta liha tytyy
leikata pieniksi palasiksi. Perunat kuoritaan, leikataan palasiksi,
pannaan pataan samalla kuin lihapalat, vesi, suola ja vhn
vehnjauhoja. Kun muhennus hyvsti kiehuu, nostat sen tulelta, pistt
heinlaatikkoon ja annat sen hautua siell, kunnes tulet kotiin. Jos
olet keittnyt maitoruokaa, voit ensin syd suolaista lihaa tai kalaa
ja leip; jos olet laittanut lihamuhennusta, saatat juoda kaljaa tai
maitoa plle.

Jos kerran tai kahdesti pivss sy keittoruokaa, saattaa hyvsti
tyyty maitoon ja leipn tai kahviin ja leipn aamulla.

Tm olkoon sanottu ruuasta.

*Trke asia on raitis ilma.* Ne, jotka tekevt tyt tehtaassa tahi
muuten sisss, eivt ole niin onnellisessa asemassa kuin maatyntekijt
ja maalaispalvelijat, joiden ty parhaasta pst tapahtuu raittiissa
ilmassa ja on sit paitsi vaihtelevaa. Siksi on erittin trket, ett
tyntekijt jrjestvt vapaa-aikansa -- -- --"

"Neljtoista tuntia", mutisi Antti katsahtaen merkitsevsti Miinaan.

-- -- -- "vapaa-aikansa niin, ett heidn keuhkonsa saavat sit, mit
niilt tyhuoneessa puuttuu. Onnellista on, jos tehdas on maalla, sill
maalla tarvitsee vain avata huoneensa ikkunan, niin raitis ilma virtaa
sisn. Maalla eivt puut ole kalliit. Maalla on vuokra halvempi kuin
kaupungeissa. Ikkuna avataan aamulla niin, ett makuuvaatteet voi
tuulettaa yn jlkeen, keskipivll, jotta ruuanhaju menee ulos, sek
illalla juuri ennen maatapanoa, koska uni sitten on terveellisemp ja
rauhallisempaa.

*Ruumiinliikunto* on hyvin trket niille, joitten ty on
yksitoikkoista. Kulkiessasi tehtaaseen ja sielt kotiin, et saa kylliksi
liikuntoa, jollei matka ole kovin pitk, vaan pit sinun sit paitsi
viel kvell ulko-ilmassa..."

"Ne kvelevt sulhasensa kanssa", huusi Tiina innokkaasti.

"Ole hiljaa, tytt!" virkkoi Miina hmilln kaikkien muiden
sydmellisesti nauraessa.

"No niin", sanoi papinrouva hyvntahtoisesti, "voivathan he kvell
sulhasensa kanssa, jos heill kerran on sulhanen. Luulisi, ettei se,
joka on seisonut koko pivn, en jaksa kvell, mutta kyll sit
jaksaa, kun ensin on istunut ja levnnyt vhn aikaa tahi loikonut
pitknn.

*Vhn voimistelua* tarvittaisiin joka piv, mutta sen pit tapahtua
ulkona tai hyvin tuuletetussa huoneessa.

*Puhtaus on ylen trke seikka.* Ei ole tarpeeksi, ett kerran viikossa
menee saunaan. Sen, joka tekee tyt tomuisessa tehtaassa tai
tyhuoneessa, pit joka ilta pest kasvonsa, kaulansa, ktens,
ksivartensa, kainalonsa ja jalkansa lmpimll vedell ja saippualla.
Virkistv ja terveellist on joka aamu kki pyyhkist koko ruumiinsa
semmoiseen veteen kastetulla ksiliinalla, joka on ollut yn
tavallisessa huoneen lmpimss. On luonnollista, ett usein tytyy
vaihtaa alusvaatteita, mutta senkin voi tehd, jos hankkii itselleen
vain yksinkertaisia, mutta lujia ja hyvi liinavaatteita. Reipas tytt
pesee vikkelsti paidan ja sukkaparin, varsinkin jos asuu aivan kosken
partaalla."

"Sitten on viel yksi seikka", jatkoi papinrouva vakavasti. "Nuori tytt
tahtoo mielelln huvitella. Sehn on luonnollista, eihn sit muuten
jaksa tehd tyt pivst pivn ja viikosta viikkoon.

*Mutta tytyy valita huvituksensa samoinkuin ystvnskin.* Ei pid
ruveta ystvksi huonon, epsiveellisen tytn, eik kevytmielisen,
viinaan menevn miehen kanssa. Sitten ei myskn pid kyd huonoissa
tansseissa, ei kytt vkevi juomia, ei laulaa rumia lauluja, ei lukea
huonoja kirjoja, eik ottaa osaa raakoihin huvituksiin. Hyv tytt
valitsee ystvikseen sellaisia henkilit, jotka vaikuttavat hneen
niin, ett hnest tulee *hyv*, *iloinen* ja *tyytyvinen* ihminen. Hn
valitsee semmoisia huveja, jotka *jalostuttavat hnt* ja *vaikuttavat
siten, ett hn aamuisin tuntee itsens virkistyneeksi ja valmiiksi
hyvll mielin ja uusin voimin taas alkamaan tytns*.

On olemassa tuhansia nuoria tyttj, jotka ovat yksin maailmalla ilman
suojaa ja ilman hyv perustusta. Heill ei koskaan ole ollut hyv
kotia, heill ei ole ollut is eik iti, jotka olisivat opettaneet ja
neuvoneet heit. Ei kukaan pid huolta heist, ei kukaan ohjaa heit, ei
kukaan varoita heit. Siksi ei ole ihmeellist, ett niin monet nuoret
tytt tulevat sairaiksi, lankeevat syntiin tahi perustavat onnettomia,
kyhi koteja ja kuolevat suruun ja kurjuuteen.

Sin, Miina, olet kahdeksannentoista ikvuoteesi asti saanut kasvaa
hyvss kodissa, jossa olet oppinut rukoilemaan ja tekemn tyt. Sinun
pit nyt olla hyvn esimerkkin tuolla tehtaassa. Sinun ja Nivalan
Leenan pit tehd kotinne puhtaaksi ja terveelliseksi, teidn pit
laittaa itsellenne snnllinen pieni talous. Ja sitten kun huomaatte,
ett kaikki ky hyvin, niin pit sinun puhua muutamien muiden
ymmrtvisen tyttjen kanssa ja nytt heille teidn kotinne ja
ruuanlaittonne ja kehoittaa heit seuraamaan teidn esimerkkinne. Siten
saatte ehk monen muuttamaan elmns ja saavuttamaan jlleen
terveytens.

Lauletaan nyt virsi ja sitten minun tytyy menn kotiin."

       *       *       *       *       *

Ensimiset pivt, jolloin Miina taas teki tyt tehtaassa, tuntuivat
pitkilt ja ikvilt ja, kun hn iltaisin istui pieness kamarissaan
Leenan kanssa, itki hn ja ajatteli kaipauksella kotia, vanhempia ja
siskoja. Mutta sitten hn muisti papinrouvan sanat ja rupesi kertomaan
Leenalle heinlaatikosta, raittiista ilmasta ja muista hydyllisist
asioista. Ensiksi tytt hankkivat tulikiven uuniinsa. He lainasivat
leipurin vaimolta, lkkilaatikon, sitten he kiehauttivat maitoa ja
mannaryyni pieness padassa, voitelivat lkkilaatikon pohjan voilla,
kaasivat puuron siihen, asettivat sen uuniin kuumalle tiilikivelle ja
sulkivat pellit. Kun he tulivat pivlliseksi kotiin, oli puuro valmis.
Hyvll halulla he sivt sen ja olivat sek ravitut ett tyytyviset.
Kun he saivat heinlaatikon, ei Leena tahtonut uskoa, ett keittminen
siin onnistuisi. He laittoivat siin puuroa ensi kerran ern
sunnuntaina. Sill aikaa kun he olivat kirkossa, kypsyi puuro, ja Leenan
suureksi ihmeeksi oli se todellakin valmista. Kolme heidn tuttavataan
tytt oli seurannut heit kirkosta leipurin taloon ja he saivat myskin
maistaa puuroa. Kulovalkean tavoin levisi koko tehtaaseen tieto siit,
ett Tervolan Miina keitti puuroa heinlaatikossa. Leipurin vaimo oli
ensiminen, joka laitatti itselleen heinlaatikon. Hnell oli monta
pient lasta, hn auttoi miestn leipomisessa, sit paitsi hnell oli
kaksi lehm, porsas ja perunamaa, ja hn oli aina kiinni tyss.
Heinlaatikosta oli hnelle suunnaton apu, sill nyt ei hnen en
tarvinnut seist velli hmmentmss.

Kun heinlaatikolla oli niin hyv menestys, rupesi Miina vhitellen
kertomaan toisille myskin raittiista ilmasta, ruumiinliikunnosta,
puhtaudesta ja jrkevist, hyvist huveista. Tosin tapahtui usein, ett
molemmille tytille naurettiin, monet olivat tietysti liian laiskat
laittaakseen ruokaa, ja monet tahtoivat mieluummin koreita vaatteita
kuin kelvollista ravintoa, mutta suuri joukko nuoria tyttj sai halun
koettaa ja he seurasivat monessa asiassa Miinan ja Leenan esimerkki.
Viisitoista tytt oli myskin muodostanut pienen yhdistyksen. He
kokoontuivat lauantai-iltaisin ja pttivt lukea neen hyvi kirjoja.
He lukivat Terveydenhoitolehte, Koti ja Yhteiskuntaa, raittiuskirjasia
ja hyvi kertomuskirjoja. Kaikki nmt olivat olemassa tehtaan
lukusalissa. Sit paitsi siell oli laulukirjoja, ja Leena, joka oli
oikea laululintunen, opetti muille monta kaunista laulua.

       *       *       *       *       *

Miina oli todellakin tullut terveeksi ja punaposkiseksi, mutta hn ei
kuitenkaan viihtynyt tehtaassa. Vihdoin hn ern kevtpivn tuli
kotiin Tervolaan ja sanoi, ett jos is ja iti antaisivat hnen jd
kotiin, niin tekisi hn mielelln kauemminkin tyt kuin tehtaassa, kun
hn vain saisi lyps lehmi, haravoida, panna perunoita ja leikata
viljaa. Se olisi sittenkin hauskempaa, kuin koko pivn seist
tomuisessa tehtaassa.

"Saathan toki jd", sanoi iti iloisena. "Tyt on kesll kylliksi.
Ja talvisin emme ehdi kutoa niin paljon, kuin muut haluavat meilt ostaa
ksiliina-, palttina- ja puolivillaista kangasta."

Voi, miten iloisena Miina seuraavana aamuna hameet ylskrittyin
levitteli pellolla lantaa! Kki kukkui ja koivut tuoksuivat, Matti
vihelteli iloista laulua ja is kynti vhn matkan pss. Kumaraksi ja
vanhaksi ukko oli kynyt, mutta hn oli tyytyvisen nkinen, kun hn
piippuaan tyttessn antoi hevosen hetkeksi levt ja katseli, miten
reippaasti hnen vanhin tyttrens piteli tadikkoa.

"Kai ne kaupungin kadut sopivat kaupungin lapsille, jotka eivt ole
nhneet mitn parempaa", sanoi Miina Matille, "mutta kun on kasvanut
maalla, niin nyttvt koivut paremmilta kuin tehtaanpiiput ja
kenkukunta kuuluu kauniimmalta kuin hyrypillin vihellys."

       *       *       *       *       *

Tervolan naapuritorpan isntn oli jo pari vuotta ollut ers nuori
mies, Salmelan Lauri. Hn oli vlist ollut Tervolassa talkoossa, ja
Tervolan vki oli ollut hnen luonaan talkoossa. Hn oli raivannut
itselleen aivan samanlaisen puutarhan, kuin Tervolassakin oli, ja oli
saanut Annalta ohjeita ja neuvoja. Taloutta hoiti hnen sisarensa,
reipas ja iloinen tytt, josta heti tuli Tervolan tyttjen hyv ystv.
Mutta syksyll sisar aikoi menn naimisiin, ja silloin Lauri rupesi
ajattelemaan, ett hnenkin tytyi hankkia itselleen vaimo. Nhdessn
Miinan liikkuvan niin reippaana ja iloisena tyssn, arveli hn, ett
siinhn oli tytt hnt varten.

Ja elonkorjuun jlkeen tulivat kuuliaiset ja ht.

"Kas tuota", sanoi Antti istuessaan tupansa nurkassa rakas piippunys
ksissn, "talollisen poika ei kelvannut, vaan torppari se hnelle
kelpasi."

"Torppari on kelpo mies", sanoi Anna.

"Niin on, ja Miina on viisas tytt, Lintulan talo rnstyy mink
enntt, mutta Salmelan torppa vaurastuu niin, ett sit ilokseen
katselee."

"Ja me hankimme puutarhan ja kanoja ja kaikkea, mit Tervolassakin on",
sanoi Miina.

       *       *       *       *       *

Kun Pekka oli tyttnyt 21 vuotta, otti hn haltuunsa yhden pappilan
muista torpista. Ja hn, joka lapsena oli leikkirattaillaan vetnyt
hiekkaa Tervolan puutarhaan, alkoi heti jrjestykseen pstyn raivata
itselleen puutarhaa. Liisa meni hnt auttamaan, kun hn vain
hetkeksikn psi Tervolasta. Ja kun Pekka meni naimisiin, neuvoi ja
opasti Liisa klyn, sill Anna alkoi kyd vanhaksi ja askaroitsi
mieluimmin sisll.

Papinrouvana oli paljon iloa uusista pikku kodeista. Hn iloitsi
sydmestn, kun pikku Tiina toi hnelle korillisen punaposkisia omenia,
kun Miina lahjoitti hnelle tiun tuoreita munia, tahi kun Pekan nuori
vaimo toi hnelle kevn ensimiset narsissit.

"Jos min osaisin kirjoittaa kirjan," sanoi Anna kerran papinrouvalle,
"niin kirjoittaisin, mit hyv rouva on tehnyt Tervolassa ja miten
rouva on opastanut meidn lapsiamme, joilla nyt on kullakin oma kotinsa;
mutta kyllhn hyvn rouvan nimi on kirjoitettu suureen kirjaan tuolla
ylhll taivaassa."





End of the Project Gutenberg EBook of Tehtaan tytt, by Maria Furuhjelm

*** END OF THIS PROJECT GUTENBERG EBOOK TEHTAAN TYTT ***

***** This file should be named 16068-8.txt or 16068-8.zip *****
This and all associated files of various formats will be found in:
        http://www.gutenberg.org/1/6/0/6/16068/

Produced by Matti Jrvinen and Tuija Lindholm.

Updated editions will replace the previous one--the old editions
will be renamed.

Creating the works from public domain print editions means that no
one owns a United States copyright in these works, so the Foundation
(and you!) can copy and distribute it in the United States without
permission and without paying copyright royalties.  Special rules,
set forth in the General Terms of Use part of this license, apply to
copying and distributing Project Gutenberg-tm electronic works to
protect the PROJECT GUTENBERG-tm concept and trademark.  Project
Gutenberg is a registered trademark, and may not be used if you
charge for the eBooks, unless you receive specific permission.  If you
do not charge anything for copies of this eBook, complying with the
rules is very easy.  You may use this eBook for nearly any purpose
such as creation of derivative works, reports, performances and
research.  They may be modified and printed and given away--you may do
practically ANYTHING with public domain eBooks.  Redistribution is
subject to the trademark license, especially commercial
redistribution.



*** START: FULL LICENSE ***

THE FULL PROJECT GUTENBERG LICENSE
PLEASE READ THIS BEFORE YOU DISTRIBUTE OR USE THIS WORK

To protect the Project Gutenberg-tm mission of promoting the free
distribution of electronic works, by using or distributing this work
(or any other work associated in any way with the phrase "Project
Gutenberg"), you agree to comply with all the terms of the Full Project
Gutenberg-tm License (available with this file or online at
http://gutenberg.net/license).


Section 1.  General Terms of Use and Redistributing Project Gutenberg-tm
electronic works

1.A.  By reading or using any part of this Project Gutenberg-tm
electronic work, you indicate that you have read, understand, agree to
and accept all the terms of this license and intellectual property
(trademark/copyright) agreement.  If you do not agree to abide by all
the terms of this agreement, you must cease using and return or destroy
all copies of Project Gutenberg-tm electronic works in your possession.
If you paid a fee for obtaining a copy of or access to a Project
Gutenberg-tm electronic work and you do not agree to be bound by the
terms of this agreement, you may obtain a refund from the person or
entity to whom you paid the fee as set forth in paragraph 1.E.8.

1.B.  "Project Gutenberg" is a registered trademark.  It may only be
used on or associated in any way with an electronic work by people who
agree to be bound by the terms of this agreement.  There are a few
things that you can do with most Project Gutenberg-tm electronic works
even without complying with the full terms of this agreement.  See
paragraph 1.C below.  There are a lot of things you can do with Project
Gutenberg-tm electronic works if you follow the terms of this agreement
and help preserve free future access to Project Gutenberg-tm electronic
works.  See paragraph 1.E below.

1.C.  The Project Gutenberg Literary Archive Foundation ("the Foundation"
or PGLAF), owns a compilation copyright in the collection of Project
Gutenberg-tm electronic works.  Nearly all the individual works in the
collection are in the public domain in the United States.  If an
individual work is in the public domain in the United States and you are
located in the United States, we do not claim a right to prevent you from
copying, distributing, performing, displaying or creating derivative
works based on the work as long as all references to Project Gutenberg
are removed.  Of course, we hope that you will support the Project
Gutenberg-tm mission of promoting free access to electronic works by
freely sharing Project Gutenberg-tm works in compliance with the terms of
this agreement for keeping the Project Gutenberg-tm name associated with
the work.  You can easily comply with the terms of this agreement by
keeping this work in the same format with its attached full Project
Gutenberg-tm License when you share it without charge with others.

1.D.  The copyright laws of the place where you are located also govern
what you can do with this work.  Copyright laws in most countries are in
a constant state of change.  If you are outside the United States, check
the laws of your country in addition to the terms of this agreement
before downloading, copying, displaying, performing, distributing or
creating derivative works based on this work or any other Project
Gutenberg-tm work.  The Foundation makes no representations concerning
the copyright status of any work in any country outside the United
States.

1.E.  Unless you have removed all references to Project Gutenberg:

1.E.1.  The following sentence, with active links to, or other immediate
access to, the full Project Gutenberg-tm License must appear prominently
whenever any copy of a Project Gutenberg-tm work (any work on which the
phrase "Project Gutenberg" appears, or with which the phrase "Project
Gutenberg" is associated) is accessed, displayed, performed, viewed,
copied or distributed:

This eBook is for the use of anyone anywhere at no cost and with
almost no restrictions whatsoever.  You may copy it, give it away or
re-use it under the terms of the Project Gutenberg License included
with this eBook or online at www.gutenberg.net

1.E.2.  If an individual Project Gutenberg-tm electronic work is derived
from the public domain (does not contain a notice indicating that it is
posted with permission of the copyright holder), the work can be copied
and distributed to anyone in the United States without paying any fees
or charges.  If you are redistributing or providing access to a work
with the phrase "Project Gutenberg" associated with or appearing on the
work, you must comply either with the requirements of paragraphs 1.E.1
through 1.E.7 or obtain permission for the use of the work and the
Project Gutenberg-tm trademark as set forth in paragraphs 1.E.8 or
1.E.9.

1.E.3.  If an individual Project Gutenberg-tm electronic work is posted
with the permission of the copyright holder, your use and distribution
must comply with both paragraphs 1.E.1 through 1.E.7 and any additional
terms imposed by the copyright holder.  Additional terms will be linked
to the Project Gutenberg-tm License for all works posted with the
permission of the copyright holder found at the beginning of this work.

1.E.4.  Do not unlink or detach or remove the full Project Gutenberg-tm
License terms from this work, or any files containing a part of this
work or any other work associated with Project Gutenberg-tm.

1.E.5.  Do not copy, display, perform, distribute or redistribute this
electronic work, or any part of this electronic work, without
prominently displaying the sentence set forth in paragraph 1.E.1 with
active links or immediate access to the full terms of the Project
Gutenberg-tm License.

1.E.6.  You may convert to and distribute this work in any binary,
compressed, marked up, nonproprietary or proprietary form, including any
word processing or hypertext form.  However, if you provide access to or
distribute copies of a Project Gutenberg-tm work in a format other than
"Plain Vanilla ASCII" or other format used in the official version
posted on the official Project Gutenberg-tm web site (www.gutenberg.net),
you must, at no additional cost, fee or expense to the user, provide a
copy, a means of exporting a copy, or a means of obtaining a copy upon
request, of the work in its original "Plain Vanilla ASCII" or other
form.  Any alternate format must include the full Project Gutenberg-tm
License as specified in paragraph 1.E.1.

1.E.7.  Do not charge a fee for access to, viewing, displaying,
performing, copying or distributing any Project Gutenberg-tm works
unless you comply with paragraph 1.E.8 or 1.E.9.

1.E.8.  You may charge a reasonable fee for copies of or providing
access to or distributing Project Gutenberg-tm electronic works provided
that

- You pay a royalty fee of 20% of the gross profits you derive from
     the use of Project Gutenberg-tm works calculated using the method
     you already use to calculate your applicable taxes.  The fee is
     owed to the owner of the Project Gutenberg-tm trademark, but he
     has agreed to donate royalties under this paragraph to the
     Project Gutenberg Literary Archive Foundation.  Royalty payments
     must be paid within 60 days following each date on which you
     prepare (or are legally required to prepare) your periodic tax
     returns.  Royalty payments should be clearly marked as such and
     sent to the Project Gutenberg Literary Archive Foundation at the
     address specified in Section 4, "Information about donations to
     the Project Gutenberg Literary Archive Foundation."

- You provide a full refund of any money paid by a user who notifies
     you in writing (or by e-mail) within 30 days of receipt that s/he
     does not agree to the terms of the full Project Gutenberg-tm
     License.  You must require such a user to return or
     destroy all copies of the works possessed in a physical medium
     and discontinue all use of and all access to other copies of
     Project Gutenberg-tm works.

- You provide, in accordance with paragraph 1.F.3, a full refund of any
     money paid for a work or a replacement copy, if a defect in the
     electronic work is discovered and reported to you within 90 days
     of receipt of the work.

- You comply with all other terms of this agreement for free
     distribution of Project Gutenberg-tm works.

1.E.9.  If you wish to charge a fee or distribute a Project Gutenberg-tm
electronic work or group of works on different terms than are set
forth in this agreement, you must obtain permission in writing from
both the Project Gutenberg Literary Archive Foundation and Michael
Hart, the owner of the Project Gutenberg-tm trademark.  Contact the
Foundation as set forth in Section 3 below.

1.F.

1.F.1.  Project Gutenberg volunteers and employees expend considerable
effort to identify, do copyright research on, transcribe and proofread
public domain works in creating the Project Gutenberg-tm
collection.  Despite these efforts, Project Gutenberg-tm electronic
works, and the medium on which they may be stored, may contain
"Defects," such as, but not limited to, incomplete, inaccurate or
corrupt data, transcription errors, a copyright or other intellectual
property infringement, a defective or damaged disk or other medium, a
computer virus, or computer codes that damage or cannot be read by
your equipment.

1.F.2.  LIMITED WARRANTY, DISCLAIMER OF DAMAGES - Except for the "Right
of Replacement or Refund" described in paragraph 1.F.3, the Project
Gutenberg Literary Archive Foundation, the owner of the Project
Gutenberg-tm trademark, and any other party distributing a Project
Gutenberg-tm electronic work under this agreement, disclaim all
liability to you for damages, costs and expenses, including legal
fees.  YOU AGREE THAT YOU HAVE NO REMEDIES FOR NEGLIGENCE, STRICT
LIABILITY, BREACH OF WARRANTY OR BREACH OF CONTRACT EXCEPT THOSE
PROVIDED IN PARAGRAPH F3.  YOU AGREE THAT THE FOUNDATION, THE
TRADEMARK OWNER, AND ANY DISTRIBUTOR UNDER THIS AGREEMENT WILL NOT BE
LIABLE TO YOU FOR ACTUAL, DIRECT, INDIRECT, CONSEQUENTIAL, PUNITIVE OR
INCIDENTAL DAMAGES EVEN IF YOU GIVE NOTICE OF THE POSSIBILITY OF SUCH
DAMAGE.

1.F.3.  LIMITED RIGHT OF REPLACEMENT OR REFUND - If you discover a
defect in this electronic work within 90 days of receiving it, you can
receive a refund of the money (if any) you paid for it by sending a
written explanation to the person you received the work from.  If you
received the work on a physical medium, you must return the medium with
your written explanation.  The person or entity that provided you with
the defective work may elect to provide a replacement copy in lieu of a
refund.  If you received the work electronically, the person or entity
providing it to you may choose to give you a second opportunity to
receive the work electronically in lieu of a refund.  If the second copy
is also defective, you may demand a refund in writing without further
opportunities to fix the problem.

1.F.4.  Except for the limited right of replacement or refund set forth
in paragraph 1.F.3, this work is provided to you 'AS-IS' WITH NO OTHER
WARRANTIES OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO
WARRANTIES OF MERCHANTIBILITY OR FITNESS FOR ANY PURPOSE.

1.F.5.  Some states do not allow disclaimers of certain implied
warranties or the exclusion or limitation of certain types of damages.
If any disclaimer or limitation set forth in this agreement violates the
law of the state applicable to this agreement, the agreement shall be
interpreted to make the maximum disclaimer or limitation permitted by
the applicable state law.  The invalidity or unenforceability of any
provision of this agreement shall not void the remaining provisions.

1.F.6.  INDEMNITY - You agree to indemnify and hold the Foundation, the
trademark owner, any agent or employee of the Foundation, anyone
providing copies of Project Gutenberg-tm electronic works in accordance
with this agreement, and any volunteers associated with the production,
promotion and distribution of Project Gutenberg-tm electronic works,
harmless from all liability, costs and expenses, including legal fees,
that arise directly or indirectly from any of the following which you do
or cause to occur: (a) distribution of this or any Project Gutenberg-tm
work, (b) alteration, modification, or additions or deletions to any
Project Gutenberg-tm work, and (c) any Defect you cause.


Section  2.  Information about the Mission of Project Gutenberg-tm

Project Gutenberg-tm is synonymous with the free distribution of
electronic works in formats readable by the widest variety of computers
including obsolete, old, middle-aged and new computers.  It exists
because of the efforts of hundreds of volunteers and donations from
people in all walks of life.

Volunteers and financial support to provide volunteers with the
assistance they need, is critical to reaching Project Gutenberg-tm's
goals and ensuring that the Project Gutenberg-tm collection will
remain freely available for generations to come.  In 2001, the Project
Gutenberg Literary Archive Foundation was created to provide a secure
and permanent future for Project Gutenberg-tm and future generations.
To learn more about the Project Gutenberg Literary Archive Foundation
and how your efforts and donations can help, see Sections 3 and 4
and the Foundation web page at http://www.pglaf.org.


Section 3.  Information about the Project Gutenberg Literary Archive
Foundation

The Project Gutenberg Literary Archive Foundation is a non profit
501(c)(3) educational corporation organized under the laws of the
state of Mississippi and granted tax exempt status by the Internal
Revenue Service.  The Foundation's EIN or federal tax identification
number is 64-6221541.  Its 501(c)(3) letter is posted at
http://pglaf.org/fundraising.  Contributions to the Project Gutenberg
Literary Archive Foundation are tax deductible to the full extent
permitted by U.S. federal laws and your state's laws.

The Foundation's principal office is located at 4557 Melan Dr. S.
Fairbanks, AK, 99712., but its volunteers and employees are scattered
throughout numerous locations.  Its business office is located at
809 North 1500 West, Salt Lake City, UT 84116, (801) 596-1887, email
business@pglaf.org.  Email contact links and up to date contact
information can be found at the Foundation's web site and official
page at http://pglaf.org

For additional contact information:
     Dr. Gregory B. Newby
     Chief Executive and Director
     gbnewby@pglaf.org


Section 4.  Information about Donations to the Project Gutenberg
Literary Archive Foundation

Project Gutenberg-tm depends upon and cannot survive without wide
spread public support and donations to carry out its mission of
increasing the number of public domain and licensed works that can be
freely distributed in machine readable form accessible by the widest
array of equipment including outdated equipment.  Many small donations
($1 to $5,000) are particularly important to maintaining tax exempt
status with the IRS.

The Foundation is committed to complying with the laws regulating
charities and charitable donations in all 50 states of the United
States.  Compliance requirements are not uniform and it takes a
considerable effort, much paperwork and many fees to meet and keep up
with these requirements.  We do not solicit donations in locations
where we have not received written confirmation of compliance.  To
SEND DONATIONS or determine the status of compliance for any
particular state visit http://pglaf.org

While we cannot and do not solicit contributions from states where we
have not met the solicitation requirements, we know of no prohibition
against accepting unsolicited donations from donors in such states who
approach us with offers to donate.

International donations are gratefully accepted, but we cannot make
any statements concerning tax treatment of donations received from
outside the United States.  U.S. laws alone swamp our small staff.

Please check the Project Gutenberg Web pages for current donation
methods and addresses.  Donations are accepted in a number of other
ways including including checks, online payments and credit card
donations.  To donate, please visit: http://pglaf.org/donate


Section 5.  General Information About Project Gutenberg-tm electronic
works.

Professor Michael S. Hart is the originator of the Project Gutenberg-tm
concept of a library of electronic works that could be freely shared
with anyone.  For thirty years, he produced and distributed Project
Gutenberg-tm eBooks with only a loose network of volunteer support.


Project Gutenberg-tm eBooks are often created from several printed
editions, all of which are confirmed as Public Domain in the U.S.
unless a copyright notice is included.  Thus, we do not necessarily
keep eBooks in compliance with any particular paper edition.


Most people start at our Web site which has the main PG search facility:

     http://www.gutenberg.net

This Web site includes information about Project Gutenberg-tm,
including how to make donations to the Project Gutenberg Literary
Archive Foundation, how to help produce our new eBooks, and how to
subscribe to our email newsletter to hear about new eBooks.

$,=42;for(34,0,-3,9,-11,11,-17,7,-5){$*.=pack'c'=>$,+=$_}for(reverse split//=>$*
){$%++?$ %%2?push@C,$_,$":push@c,$_,$":(push@C,$_,$")&&push@c,$"}$C[$#C]=$/;($#C
>$#c)?($ c=\@C)&&($ C=\@c):($ c=\@c)&&($C=\@C);$%=$|;for(@$c){print$_^$$C[$%++]}
-p $_=1+$_.$/for@;[9-$_..8]}{print@
-ln0 ($~+=s~$=~~g)&&print$~while--$=
-ln0 $~+=s~$=~~gand print$~while--$=
-p $_=++$_.$/for@a[9-$_..8]}for(@a){
-n $_=++$_.$/for@a[9-$_..8]}{print@a
-ln0 ($,+=s/$=//g)&&print$,while--$=
-pl $_++for@s[1..$_]}while($_=pop@s){
-lp $_++for@_[1..$_]}while($_=pop@_){
-pl ++$_[--$_]while$_}for(reverse@_){
-pl $_++for@_[1..$_]}while($_=pop@_){
-n map$_=++$_.$/,@p[9-$_..8]}{print@p
-nl ++$$[--$_]}{map{print$t+=pop@$}@$
-ln0 /$=/?print s//$=-1/eg:3while--$=
-p $x[--$_]++while$_}{$\=$_.$/.$\for@x
-p $k[--$_]++while$_}{$\=~s//$_\n/for@k
-nl $_[9-$_]++for 1..$_}{$_&&print for@_
-p $d[$_-1]++for 1..$_}{$\=$_.$/.$\for@d
-l map++$o[$_-1],<>;map{print$o+=pop@o}@o
-nl ++$o[$_-1];END{map{print$o+=pop@o}@o}
-l map{++$a[--$_]}<>;map{print$o+=pop@a}@a
-ln $_[$_]++while$_--}{map{print}reverse@_
-nl ++$o[9-$_--]while$_;END{map$_&&print,@o}
-p $z.=a.1x$_}{$_="$a\n$_"while$a=$z=~s/a1/a/g
-ln $a[$_]++while$_--;END{print for+reverse@a}
$x[$_]++for map{1..$_}<>;print join$/,reverse@x
-nl $i=0;$a[$i++]++for 1..$_}{print for reverse@a
-n END{print join"\n",reverse@a}$a[$_]++for(1..$_)
map{for(1..$_){$a[$_]++}}<>;print join"\n",reverse@a
for(;<>=~/\d+/;){for(@a[1..$&]){$_++}}print join("\n",reverse@a)
sub x{$_=shift;$v="";while($_){if(/^(\D*)/){$v.=$&;$_=$'}if(/^(\d+)/){$v.=sprintf("%09d",$&),$_=$'}};$v}map{print}sort{x($a)cmp x($b)}<>;
sub K($$){@a=@_;$*=ord((sort+map{chr(length)}"@_"=~/\d+/g)[-1]);s/\d+/sprintf"%0$*s",$&/eg for@a;$a[0]cmp$a[1]}print+sort K<>
-n $c++;$e=$_;s/(\d+)/$a=length $1;''x(9999-$a).$1/ge;$a{lc($_.$c)}=$e;}foreach $b(sort keys %a){print $a{$b};
print/([^\0]*)$/for sort map{$b=$_;lc;$_=$`.0 x(length@b-length$&)."$&\0$'"while/\d+(?!.*\0)/;"$_\0$b"}@b=<>
$c++;$e=$_;s/(\d+)/$a=length $1;' 'x(99-$a).$1/ge;$a{lc($_.$c)}=$e;}foreach$b(sort keys %a){print $a{$b};
sub K($$){@a=@_;$*=length"@_";s/\d+/sprintf"%0$*s",$&/eg for@a;$a[0]cmp$a[1]}print+sort K<>
$;|=y===cfor@f=<>;sub f{$_=lc$_[0];s/\d+/sprintf"%$;s",$&/eg;$_}print+sort{f($a)cmp f$b}@f
sub f{$_=pop;s/\d+/$a=$&+0;pack("N",length$a)."-$a"/eg;$_}print sort{f($a)cmp f $b}<>
print+sort{@_=($a,$b);$*=length"@_";s/\d+/sprintf"%0$*s",$&/eg for@_;$_[0]cmp$_[1]}<>
print+sort{s|\d+|0 x(length($a.$b)-length$&).$&|eg,for@_=($a,$b);$_[0]cmp$_[1]}<>
print sort{($$_=lc${lc$_})=~s/\d+|$/$"x(1e4-length$&).$&/ge for A,B;$A cmp$B}<>
($a=uc)=~s/\d+/$|x($=-length$&).$&/eg,s/^/$a/for@l=<>;s/.*\n//,print for sort@l
print+sort{s|\d+|0 x(2**07-length$&).$&|eg,for@_=map{lc}$a,$b;$_[0]cmp$_[1]}<>
print sort{($$_=lc${lc$_})=~s/\d+|$/$"x(99-length$&).$&/ge for A,B;$A cmp$B}<>
print/(.*\n)$/for sort map{$x=$_;s#\d+#'0'.pack'w/a*',$&+0#eg;"\U$_\E\n$x"}<>
print map/\n(.+)/s,sort map{($a=lc)=~s/\d+/$[.chr(length$&).$&/eg;"$a$_"}<>
sub Z{$_=pop;s/\d+/0 .pack(N,length$&).$&/eg;uc}print sort{Z($a)cmp Z$b}<>
-n $a=$_;s/\d+/sprintf"%099s",$&/ge;$b{$:.uc}.=$a}{print map{$b{$_}}sort%b
b"=~/^(.*\D)?(\d+).*\n\1(\d+)/i&&$2<=>$3||lc$a cmp lc$b}<>
or sort map{$x=$_;s#\d+|\n#pack'xN/a*',$&#eg;"\U$_\E$x"}<>
ort{s|\d+|0 x(2**07-length$&).$&|eg,for@_=($a,$b);$_[0]cmp$_[1]}<>
/\d+/0 .pack(N,length$&).$&/eg;uc}print sort{Z($_=$a)cmp Z$_=$b}<>
|\d+|0 x(2**07-length$&).$&|eg;lc}print+sort{_($_=$a)cmp _$_=$b}<>
b"=~/^(.*\D)?(\d+).*\n\1(\d+)/i;$2<=>$3||lc$a cmp lc$b}<>
or sort map{$x=$_;s#\d+|\n#pack'N/a*',$&#eg;"\U$_\E$x"}<>
ap/\n(.+)/s,sort map{($a=lc)=~s/\d+/0${\chr length$&}$&/g;$a.$_}<>
_=pop;s/(\d+)/sprintf"%.99d",$1/eg;uc}print sort{Z($a)cmp Z$b}<>
 sub a{$_=pop;s#\d+#0 .pack'N/A*',$&#ge;lc$_}print sort{a($a)cmp a$b}<>
b"=~/^(.*)(\d+).*\n\1(\d+)/i&&$2<=>$3||lc$a cmp lc$b}<>
/\d+/0 .pack(N,$+[0]).$&/eg;uc}print sort{Z($_=$a)cmp Z$_=$b}<>
b"=~/^(.*)(\d+).*\n\1(\d+)/?$2<=>$3:$a cmp$b}map lc,<>
/\d+/(':'x length$&).$&/eg;uc}print sort{Z($_=$a)cmp Z$_=$b}<>
b"=~/^(.*)(\d+).*\n\1(\d+)/i&&$2-$3||lc$a cmp lc$b}<>
b"=~/^(.*)(\d+)(.*)\n\1(\d+)\3$/i?$2<=>$4:$a cmp$b}<>
 sub a{$_=pop;s#\d+#0 .pack'N/A*',$&#ge;lc}print sort{a($a)cmp a$b}<>
 sub a{$_=pop;s#\d+#_ x(length$&).$&#ge;lc}print sort{a($a)cmp a$b}<>
r sort map{$x=$_;s#\d+|\n#pack'xN/a*',$&#eg;lc().$x}<>
/\d+/0 .(A x$+[0]).$&/eg;uc}print sort{Z($_=$a)cmp Z$_=$b}<>
 sub a{$_=lc pop;s#\d+#A x$+[0].$&#ge;$_}print sort{a($a)cmp a$b}<>
\d+;~0/3+$+[0].$&;eg;lc}print+sort{f($a)cmp+f$b}<>
 sub a{$_=pop;s#\d+#8x$+[0].$/.$&#ge;lc}print sort{a($a)cmp a$b}<>
/\d+/0 .A x$+[0].$&/eg;uc}print sort{Z($_=$a)cmp Z$_=$b}<>
_=pop;s/\d+/length($&).$&/eg;uc}print sort{Z($a)cmp Z$b}<>
_;s/\d+/sprintf"%99s",$&/ge;$b{$:.uc}.=$a}{print@b{sort%b}
_;s!|\d+!pack'AN/Z*',0,$&!eg;$;{lc,}.=$k}for(@;{sort%;}){
/\d+/': 'x$+[0].$&/eg;uc}print sort{Z($_=$a)cmp Z$_=$b}<>
/\d+/':0'x$+[0].$&/eg;uc}print sort{Z($_=$a)cmp Z$_=$b}<>
 sub a{$_=lc pop;s#\d+#0 x$&.$/#ge;$_}print sort{a($a)cmp a$b}<>
/\d+/':'x$+[0].$&/eg;uc}print sort{Z($_=$a)cmp Z$_=$b}<>
\d+!pack'AN/Z*',0,$&!eg;$;{lc,}.="@F\n"}for(@;{sort%;}){
_=shift;s/\d+/chr$&/g;$_}print+sort{_($a)cmp _ $b}<>
 print sort{"$a$b"=~('(\D+)(\d*)\n'x 2);$1cmp$3||$2<=>$4}<>
{$r=0;$j=$a;$k=$b;$d=$j=~/\d/?1:0;until($r){$u=$v=1;$e=$d?'\d':'[a-z]';($p,$q)=map{s/^($e+)//i?lc$1:''}$j,$k;($x,$y)=map/\w/?0:1,$j,$k;if($p&&$q){if($d){($h,$i)=map{length}$p,$q;;if(!($r=($h<=>$i))){($u,$v)=map{s/(.)//?$1:''}$p,$q until($u==''||($r=$u<=>$v))}}$r=($p cmp$q)if!$d}else{$r=$p?1:-1;$r=!$r if$d}$r||($y&&$r++)||$x&&$r--;$d=$d?0:1}$r}<>
{chop($j=$a);chop($k=$b);do{$e=($d=$j=~/^\d/)?'\d':'[a-z]';($p,$q)=map{s/^($e+)//i?lc$1:''}$j,$k;if($p&&$q){if($d&&!($r=length$p<=>length$q)){do{($u,$v)=map{s/(.)//?$1:''}$p,$q}until($u==''||($r=$u<=>$v))}$r=($p cmp$q)if!$d}else{$r=$p?1:-1;$r=!$r if$d}$r||(!$k&&$r++)||!$j&&$r--}until($r)}<>
;print sort{g($a,$b)}<>;sub g{my($j,$k,$z,$x)=@_;for($j,$k){my@c;{$e=/^\d/?'\d':$w;$p=$z?'':'+';s/($e$p)//i;push@c,lc$1;$1ne''&&redo}$_=+\@c}for(@$j){$v=$$k[$x++];last if$r=/\d/?$z?$_<=>$v:g($_,$v,1):$_ cmp$v}if($z){$r=($s=@$j<=>@$k)?$s:$r;$r=(grep/$w/,@$k)?-1:$r}$r}
;print sort{g($a,$b)}<>;sub g{my($j,$k,$z,$x)=@_;for($j,$k){my@c;{$e=/^\d/?'\d':$w;$p=$z?'':'+';s/($e$p)//i;push@c,lc$1;$1ne''&&redo}$_=\@c}for(@$j){$v=$$k[$x++];last if$r=/\d/?$z?$_<=>$v:g($_,$v,1):$_ cmp$v}if($z){$r=($s=@$j<=>@$k)?$s:$r;$r=(grep/$w/,@$k)?-1:$r}$r}
{$u=uc$a;$v=uc$b;@x=$u=~/\d+|\D+/g;@y=$v=~/\d+|\D+/g;return$u cmp$v if@x<2||@y<2or$x[0]=~/\d/^$y[0]=~/\d/;for(0..(@x<@y?@x:@y)){$c=$x[$_];$d=$y[$_];$i=length$c;$j=length$d;return$i<=>$j if$c=~/\d/&&$i!=$j;return$c cmp$d if$c ne$d}@x<=>@y}<>
{my@z;($;=$a)=~s/\d+/push@z,$&;1/eg;$_=$b;s/\d+/1-(length($*=shift@z)<=>length$&||$*cmp$&)/eg;lc$;cmp+lc}<>
~/^((.*\D)?)(\d+).*\n\1(\d+)/i&&length$3<=>length$4||lc$a cmp lc$b}<>
~/^(.*)(\d+).*\n\1(\d+)/i&&length$2<=>length$3||lc$a cmp lc$b}<>
{($a.$b)=~/(.*)(\d+).*\n\1(\d+)/i&&length$2<=>length$3||uc$a cmp uc$b}<>
op;s/\d+/sprintf("%010d",length$&).$&/eg;uc}print sort{Z($a)cmp Z$b}<>
printf"%".length("@_")."s",$&|egfor@_=($a,$b);$_[0]cmp$_[1]}<>
b a{$_=lc pop;s#\d+#0 .pack(N,length$&).$&#ge;$_}print sort{a($a)cmp a$b}<>
int sort{s/\d+/sprintf"%9d$&",length$&/egfor($",$;)=(uc$a,uc$b);$"cmp$;}<>
 x length("$@").$&|egfor@_=($a,lc$b);lc$_[0]cmp$_[1]}<>
\n(.+)/s,sort map{($a=lc)=~s|\d+|0${\pack'N/a*',$&}$&|g;$a.$_}<>
+/0 .(':'x length$&).$&/eg;uc}print sort{Z($_=$a)cmp Z$_=$b}<>
b a{$_=lc pop;s#\d+#0 .pack'N/A*',$&#ge;$_}print sort{a($a)cmp a$b}<>
+/0 .(A x length$&).$&/eg;uc}print sort{Z($_=$a)cmp Z$_=$b}<>
sort map{($x=lc)=~s#\d+|\n#pack'xN/a*',$&#eg;$x.$_}<>
op;s/\d+/(1e9+length$&).$&/ge;lc}print sort{t($a)cmp t$b}<>
_=lc;s!|\d+!pack'AN/Z*',0,$&!eg;$;{$_}.=$k}for(@;{sort%;}){
int sort{s!\d+!pack'AN/A*',0,$&!egfor($",$;)=(uc$a,uc$b);$"cmp$;}<>
=~s!|\d+!pack'AN/A*',0,$&!eg;$;{$*}.=$_}for(@;{sort%;}){
;9 x9+$+[0].$&;eg;lc}print+sort{f($a)cmp+f$b}<>
int sort{s!\d+!pack'AN/A*',0,$&!egfor$"=uc$a,$;=uc$b;$"cmp$;}<>
sub f{$_=pop;s;\d+;1e9+$+[0].$&;eg;uc}print+sort{f($a)cmp+f$b}<>
sub f{$_=pop;s|\d+|9x9+$+[0].$&|eg;lc}print+sort{f($a)cmp+f$b}<>
sub f{s;\d+;1e9+$+[0].$&;eg;uc}print+sort{f($_=$a)cmp+f$_=$b}<>
sub f{s;\d+;$^T+$+[0].$&;eg;uc}print+sort{f($_=$a)cmp+f$_=$b}<>
print sort{s!\d+!1e9+$+[0].$&!egfor$"=uc$a,$;=uc$b;$"cmp$;}<>
print sort{s!\d+!$^T+$+[0].$&!egfor$"=uc$a,$;=uc$b;$"cmp$;}<>
-p $k=$_;s!|\d+!1e9+$+[0].$&!eg;$;{+uc}.=$k}for(@;{sort%;}){
-p $k=$_;s!|\d+!$^T+$+[0].$&!eg;$;{+uc}.=$k}for(@;{sort%;}){
-paF s!|\d+!1e9+$+[0].$&!eg;$;{+uc}.="@F\n"}for(@;{sort%;}){
-paF s!|\d+!$^T+$+[0].$&!eg;$;{+uc}.="@F\n"}for(@;{sort%;}){
-w @a=<>;for(@INC){open F,$_."/pod/perlfaq4.pod"or next;undef$/;$_=<F>;($_)=/(my\$arr.*?\})/s;s'shift'\@a's;eval;print@a} doesn't seem to pick up the right code in my perl)
@a=<>;for(@INC){open F,$_."/pod/perlfaq4.pod"or next;undef$/;$_=<F>;($_)=/(my\$arr.*?\})/s;s'shift'\@a's;eval;print@a} doesn't seem to pick up the right code in my perl)
-n $a{$..rand}=$_}{print values%a
e@_,rand@_,0,$_}{print@_
e@a,rand@a,0,$_}for(@a){
and,$_}<>;print values%C
and}=$_}{print values%_
for(values%a){
_}for(@a{%a}){
for(@a{%a}){
and}=$_}{print@_{%_}
@A=<>;while(@A){print splice @A,int rand @A,1}
int splice@a,int rand$#a+1,1 while@a
ce(@f,rand(@f),1)while@f
ile(@a){print splice@a,rand@a,1}
int splice@a,int rand@a,1while@a
ce@x,rand@x,1 while@x
int splice @x,rand@x,1while@x
ce@a,rand@a,1while@a
int splice@a,rand@a,1while@a
@a=<>;print splice@a,rand@a,1while@a
int splice@x,rand@x,1while@x
int splice@a,rand@a,1while@a
int+delete$_[rand@_]while@_
and@a,1 for@b=@a=<>
e@_,rand@_+1,0,$_}{print@_
and@,,1for@==@,=<>
print splice@a,rand@a,1for@b=@a=<>
e@a,rand@a+1,0,$_}for(@a){
e@F,rand@F+1,0,$_}for(@F){
@x,rand@x,1}@x=<>
p{splice@x,rand@x,1}@x=<>
$.,0,$_}print@,;{
-p splice@a,rand$.,0,$_}for(@a){
$.,0,$_}{print@F
e@x,rand$.,0,$_}{print@x
-n splice@_,rand$.,0,$_}{print@_
e@a,rand$.,0,$_}{print@a
e@.,rand$.,0,$_}for(@.){
@a=<>;splice@a,rand@a,1while@a>2;print@a
e@_,rand@_,0,$_}{print@_[0,1]
e@a,rand@a,0,$_}for(@a[0,1]){
int+splice@F,rand@F,1,for$,,1
-n $a{$..rand}=$_}{print+(%a)[1,3]
_}for((%a)[1,3]){
and}=$_}{print+(%_)[1,3]
for((%a)[1,3]){
=2;while($a--){print splice@a,rand@a,1}
@A=<>;for(1,2){print splice @A,int rand @A,1}
int splice@a,int rand$#a+1,1 for+1,2
print splice(@a,rand(@a=<>),1),$a[rand@a]
p{print splice@a,int rand@a,1}0,0
e@a,rand@a+1,0,$_}for(@a[0,1]){
al'print splice@x,rand@x,1;'x2
p{print+splice@_,rand@_,1}1,2
ce@x,rand@x,1 for 1,1
ce@a,rand@a,1 for 1,2
int splice@a,rand@a,1for 1..2
int splice@x,rand@x,1for 1..2
int+splice@F,rand@F,1,for$,,1
e@a,rand$.,0,$_}{print@a[0,1]
p{print splice@a,rand@a,1}1,1
@a=<>;print splice@a,rand@a,1for 1,2
ce@_,rand@_,1for+1,2
and@x,1 for[@x=<>],1
@a=<>;print splice@a,rand@a,1for a,b
int splice@x,rand@x,1for 1,2
int splice@a,rand@a,1for 1,2
@_=<>;print splice@_,rand@_,1for 0,0
and@,,1for[@,=<>],f
-p splice@a,rand$.,0,$_}{($_,$\)=@a
e@x,rand$.,0,$_}{($_,$\)=@x
-p0i(.{10}|) $Q=$_;$==rand 4,/$&$^I$=|$=$^I$&/s?$_=$Q:s/$&/$=/gwhile/[A-Z]/
-p0aF% $==rand 4,/$&(.{10}|)$=|$=(.{10}|)$&/s?($_)=@F:s/$&/$=/gwhile/[A-Z]/
-0p $${$.^=2}^=rand 4while/(.)(\C{10})?(?!\1)(.)(??{$$1!=$$3})/;s/(.)/3-$$1/ge
-p0i(.{10}|) $Q=$_;$==rand 4,/$&$^I$=|$=$^I$&/s?$=||=$_=$Q:s/$&/$=/gwhile/[A-Z]/
-n0i(.{10}|) for$n(!s/$&/$n/g..3){s#$#/\pL/?!/$&$^I$n|$n$^I$&/s&&do$0:exit print#e}
-0p s/./$&0/g;$==rand 4,s/(${1+3*$|--})./$1$=/gwhile/(.)(\d)(\C{19})?(?!\1)(.)\2/;y/A-Z//d
-n0i(.{10}|) sub f{y/0-3/1230/;/$&$^I0|0$^I$&/s||map{s/$&/0/g*/[A-Z]/?&f+&f+&f+&f:exit print}"$_"}f/./
-l print map$_=$ARGV[($.+=!--$.[$.])%2],@.=(0)x pop
-l print map$.[$!++]=$ARGV[1&($.+=!--$.[$.])],1..pop
-l print map$$[$.++]=$ARGV[--$$[$;]||++$;,$;&1],1..pop
s/.?/$ARGV[1&pos]x$&||2/ge>>9?print$_&'?'x pop,$/:do$0
print$_?$.[$!++]=$ARGV[--$.[$.]||++$.,$.%2]:$/for-pop..0
-l for$$(1..pop){$_.=$ARGV[1&grep$|<($$-=$_),/./g]}print
-l print eval'($_.=chop()x$+.$ARGV[$|--])=~/$&(.)/,'x pop
s/.?/$ARGV[1&pos]x($&||1)/geuntil/.{$ARGV[2]}/;print$&,$/
$;=pop;s/.?/$ARGV[1&pos]x($&||1)/eguntil/.{$;}/;print"$&
-l s/.?/$ARGV[1&pos]x($&||1)/eg until/.{$ARGV[2]}/;print$&
-l $_.=2while$|=s/./$ARGV[--$|]x$&/ge<999;print$_&'?'x pop
s/.?/$ARGV[1&pos]x$&||2/ge<999?do$0:print/(.{${\pop}})/,$/
s/.?/$ARGV[$|--]x($&||1)/eguntil$|=/.{$ARGV[2]}/;print"$&
map{@;[0..@;]=map{($ARGV[$|--])x$_}@;,@;;print}@;=1..pop,$/
s/.?/$ARGV[1&pos]x$&||1/eg until/(.{$ARGV[2]})./;print"$1
s/.?/$ARGV[$-[0]%2]x($&||1)/ge until/.{$ARGV[2]}/;print$&,$/
s/.|/$ARGV[(pos)%2]x$&||9/ge<999?do$0:printf"%.${\pop}s
",$_
$%[$_]=$ARGV[$"],$*||=$%[++$.],$"^=!--$*for 1..pop;print@%,$/
$_=2;{s/./$ARGV[$-[0]%2]x$&/eg;/.{$ARGV[2]}/?print"$&
-l print map{-@@+push@@,($==$ARGV[$|--])x($@[$.++]||$=)}1..pop
s/.?/$ARGV[$"++%2]x($&||1)/eg until$"=/.{$ARGV[2]}/;print$&.$/
$_[$_]=$ARGV[$|-=!--$z],$z>0or$z=$_[++$*]for 1..pop;print@_,$/
-l print map{@.=(($?=$ARGV[$|--])x($.[-1]||$?),@.);pop@.}1..pop
-l print map{(map@/=(($_)x($/[--$%]||$_),@/),@ARGV)[-$_]}1..pop
-l print map{push@@,($%=$ARGV[--$_%2])x($@=$@[$_]||$%);$@}1..pop
-li1 map{push@,,$ARGV[$^I^=!$h];($h||=$,[$m++])--}1..pop;print@,
-l print map{push@_,($n=$ARGV[$i%2])x($c=$_[$i++]||$n);$c}1..pop
-l print+map+chop($*=($.=$ARGV[1&~$_])x chop($_=$..$*).$*),1..pop
-l $_.=($d=$ARGV[$|--])x(/./g,$d)[$f++]until/.{$ARGV[2]}/;print$&
-l $_.=($k=$ARGV[$i&1])x(/./g,$k)[$i++]until/.{$ARGV[2]}/;print$&
-l print map{push@a,($%=$ARGV[$_%2])x($n=$a[$_]||$%);$n}0..-1+pop
-l $n=pop;push@_,($_)x(@_,$_)[$i++]for(@ARGV)x$n--;print@_[0..$n]
-l push@,,($.=$ARGV[$|--])x($,[$_]||$.)for@/=0..-1+pop;print@,[@/]
print+(map{push@_,($-=$ARGV[$|--])x($==$_[--$_]||$-);$=}1..pop),$/
-l push@r,($/=$ARGV[1&$i])x($s[$i++]=$r[$i]||$/)for 1..pop;print@s
-l $l=pop;push@s,($_)x($s[$i++]||$_)for(@ARGV)x$l;print@s[0..--$l]
-l $o=pop;push@_,($_)x($_[$l++]||$_)for(@ARGV)x$o--;print@_[0..$o]
push@>,($.=@ARGV[$|--])x(@>,$.)[$_]for 0..500;print@>[0..-1+pop],$/
-l $$=pop;s/.?/$ARGV[1&pos]x$&||$ARGV[0]/eg until/(.{$$})./;print$1
$_.=($,=$ARGV[$%%2])x((/./g)[$%++]||$,)until/.{$ARGV[2]}/;print$&.$/
push@$,($$=$ARGV[$|--])x($$[$_]||$$)for 0..500;$#$=-1+pop;print@$,$/
-l print map{push@_,($%=$ARGV[$/^=1])x($\xa7=$_[$_-1]||$%);$\xa7}++$/..pop
push@_,($"=$ARGV[$_&1])x($_[$_]||$")for+0..500;$#_=-1+pop;print@_,$/
push@@,($@=$ARGV[$_%2])x($@[$_]||$@)for 0..333;print@@[0..(pop)-1],$/
$_=11;s!.!$ARGV[$-[0]%2]x$&!eg,s!(.{$ARGV[2]}).*!$1
!swhile--$=;print
-l push@_,($~=$ARGV[$|--])x($_[$-++]||$~)for a..kn;print@_[0..pop()-1]
-l map{push@_,($%=$ARGV[$_%2])x($_[$_]||$%)}0..500;print@_[0..(pop)-1]
-l print map{push@v,($_)x($v[0]||$_);shift@v}map$ARGV[$_%2^1],(1..pop)
-l @.=@ARGV;$.=1,s/./$.[$.^=1]x$&/ge,$_.=$.[!$.]until/.{$.[2]}/;print$&
for$"(1..pop){/.$/;$_=($-=$ARGV[$"-1&1])x($&||$-).$_;print chop}print$/
-l $_.=($x=$ARGV[$i%2])x(/./g,$x)[$i++]while$i<500;print substr$_,0,pop
$$=pop;$.=$ARGV[$|--],$_.=$.x substr$_.$.,$*++,1while!/.{$$}/;print$&,$/
-l /.{$i}(.)/,$;=$ARGV[$i++%2],$_.=$;x($1||$;)until/.{$ARGV[2]}/;print$&
-l push@a,($ARGV[$_%2])x($a[$_]||$ARGV[$_])for 0..999;print@a[0..-1+pop]
-l $l=pop;@l=(@l,($m=$ARGV[$|--])x($l[$_]||$m))for 0..$l;print@l[0..$l-1]
push@1,($ARGV[$|--])x($1[$_]or$ARGV[$;++])for$1..332;print@1[0..-1+pop],$/
@t=@ARGV;for(1..pop){print$u=$f[$p++]||$t[$|];push@f,($t[$|--])x$u}die"\n"
-l print map{$.=~s/.//;$..=($=^=$%||=($==pop)^pop)x($&||$=-1);$&||$=}1..pop
-l $.=pop;push@*,($==$ARGV[$%%2])x($*[$%++]||$=)while$%<$.;print@*[0..$.-1]
-l substr($@.=$ARGV[$|--],-1)x=substr$@,$_,1for 0..500;print substr$@,0,pop
-l print map{$x=$a.$x;$e||=chop$x;--$e?$a:($a^=$b)^$b}2..pop,$b=pop^($a=pop)
-l push@b,($ARGV[$_%2])x($b[$_]||$ARGV[$_%2])for(0..500);print@b[0..pop()-1]
-l ($a,$b)=@ARGV;print map{push@s,($l=$_%2?$a:$b)x($s[0]||$l);shift@s}1..pop
-l until(/.{$ARGV[2]}/&&print$&){/.{$b}(.)/;$^=$ARGV[$b++%2];$_.=$^x($1||$^)}
$/=$ARGV[1-$_%2],$*.=$/x($2||$/),$*=~s/(.)(.?)/$2/,print$1for 1..pop;print'
-l map{$s.=($a=$ARGV[$_%2])x(substr($s,$_,1)||$a)}0..999;print substr$s,0,pop
-l $n=pop;@l=@a=@ARGV;$i=0until(@l=map{($a[$i++&1])x$_}@l)>$n;print@l[0..--$n]
-l --$|,push@l,map$ARGV[!$|],1..$l[$_]||$ARGV[$_]for 0..500;print@l[0..pop()-1]
@a=@ARGV;s//@a/;while($i<666){$i=0;s/./$a[$i++&1]x$&/ge}s|.{$a[2]}|print$&,$/|e
-l *,=*ARGV;($,.=$,[$|])=~s,.,,,$,.=$,[$|--]x($&-
1),$_.=$&while$,[2]>y|||c;print
-l @A=@ARGV;push@a,($A[$_%2])x($a[$_]||$A[$_%2])for 0..$A[2];print@a[0..$A[2]-
-l @A=@ARGV;$z=$A[$_%2],push@a,($z)x($a[$_]||$z)for 0..$A[2];print@a[0..$A[2]-
-l for(0..pop){@s=(@ARGV)x999;push@a,($s[$i++])x($a[$_]||$s[$_])}print@a[0..$i-
-l @K=@ARGV;for$i(0..500){for(1..$K[$i]){$K[$p++]=$ARGV[$i%2]}}print@K[0..-
-l @a=@ARGV;print map{$n=$a[$_%2];push@d,$n for 1..$d[0]||$n;shift@d;}0..$a[2]-
-l @d=@ARGV;while($d[2]--){$b[$n++]=$d[$m%2];if($i++==$b[$m]-
1){$i=0;$m++}}print@b
-l ($a,$b,$t)=@ARGV;map{push@a,($c=$|--
?$b:$a)x($a[$_]||$c)}0..$t;print@a[0..$t-1]
-l $?=pop;$_.=($"=$ARGV[$x&1])x($:=($/=(/./g)[$x++]||$")>$??$?:$/)while$?-
=$:;print
-l for(;@o<501;++$c,$|--){push@o,($ARGV[$|])x($o[$c]||$ARGV[$|])}print@o[0..-
-l $n=pop;do{/.{$i}(.)/,$b=$ARGV[$i%2],$_.=$b
x($1||$b)}while$i++<$n;print/(.{$n})/
-l @a=@ARGV;map{$/=$a[$_%2];push@d,$/for
1..$d[$_]||$/}0..$a[2];print@d[0..$a[2]-1]
-l sub x{push@t,$ARGV[$i%2];$;--}$;=pop;while($;){x;$;&&x for
2..$t[$i];$i++}print@t
-l ($s,$t,$n)=@ARGV;$_=$s.$t;$p="$t$s"x$n,s/./chop($p)x$&/eg
until/(.{$n})./;print$1
-l ($x,$y,$a)=@ARGV;push@f,($|--?$y:$x)x($f[$_]||$|*$x||$y)for
0..$a;print@f[0..$a-1]
-l ($%,$.,$=)=@ARGV;($.,$%)=($%,$.),push@.,($.)x($.[$_]||$.)for
0..$=;print@.[0..$=-1]
@a=@ARGV;push@c,($a[$e&1])x@{$e<=@c?@c:@a}[$e++]while(@c<$a[2]);print@c[0..--
$a[2]],$/
-l $==pop;push@],($_)x($-++?$-<3?$%>1?$%:$_:$][$--
1]:($%=$_))for(@ARGV)x$=;print@][0..$=-1]
-l ($/,$b)=@ARGV;for(0..999){$;=$_%2?$b:$/;$k.=$;x(substr($k,$_,1)||$;)}print
substr$k,0,pop
$l=pop;@s=@ARGV;while(@l<$l){@l=(@l,($s[$c%2])x($l[$c]||$s[$c%2]));$c++}prin
t@l[
0..--$l]
-l @x=@ARGV;$i=shift;$z.=$x[$_%2]x$i,$i=substr$z.$x[1],$_+1,1for 0..567;print
substr$z,0,pop
($a,$b,$n)=@ARGV;$b^=$k=$a;$k||($a^=$b,$k=$R[++$p]||$a),(push@R,$a),$k--
while$n--;print@R,'
-l print+map{$c--||($v=$ARGV[$|--],$c=$_<1?$v:$_-1?$s[$_-$d]:$v,$d+=--
$c);$s[$_]=$v}0..-1+pop
($a,$b,$l)=@ARGV;push@a,($_%2?$b:$a)x($_<2?$a<2*$_?$b:$a:$a[$_])for
0..$l;print@a[0..$l-1],$/
($a,$b,$c)=@ARGV;for$i(0..$c){pos=$i;/./g;$_.=($i%2?$b:$a)x($_==1?$b:$&||$a)}pr
int/(.{$c})/,$/
($a,$b,$c)=@ARGV;while(@_<$c){map{push+_,$a}1..$_[$l++]||$a;$a^=$b^=$a^=$b}p
rint@_[0..$c-1]
b:if(@b==$ARGV[2]){print@b,"
";exit}push @b,$ARGV[$i%2];$k++;$k<$b[$i]&&goto b;$k=0;$i++;goto b
($a,$b,$c)=@ARGV;for(0..$c){$s.=($_%2?$b:$a)x(substr($s,$_,1)||shift)}print
substr($s,0,$c)."
($,,$;,$")=@ARGV;$_=$,x$,;$_.=(/$,$/?$;:$,)x(substr($_,++$i,1)||$;)while$i<$
";/.{$"}/;print$&
-l ($:,$;,$%)=@ARGV;$_=$:x$:;$_.=$;
x(substr$_,++$x,1or$;),($:,$;)=($;,$:)while$%>$x;/.{$%}/;print$&
@a=@ARGV;@b="";for$i(1..$a[2]){for$j(1..($b[$i]||$a[$t])){push(@b,$a[$t])}$t
=!$t;$_.=$b[$i]}print
-l ($a,$b,$l)=@ARGV;$b+=$a;for(1..$l){$p=$a-
1;$s.=@n?($p=pop@n):$a;@n=(($a)x$p,@n);$a=$b-$a;}print$s;
($n,$s,$i)=@ARGV;$l=0;map{push@r,(@ARGV[$l])x$n;$l=$l?0:1;$n=@r[$_]?@r[$_]:$
s;}1..500;print@r[0..--$i]
-l ($.,$/,$")=@ARGV;split'',$.x$..$/;for(0..$"){$_[$%++]=$-
?$/:$.for(1..$_[$?++]);$-=1-$-}$#_=$"-1;print@_
@k=@ARGV;for(0..pop){splice(@k,$o,$k[$i],($x=shift)x$k[$i]),$o+=$k[$i++],pus
h@ARGV,$x}print @k[0..$i-2]
($a,$b,$c)=@ARGV;for$d(0..$c){push@e,$a;$f=$e[$d];for(2..$f){push@e,$a}($a,$
b)=($b,$a)}print@e[0..$c-1]
-l ($a)=@a=@ARGV;@s=($a,$a[$a-
1?0:1]);map{$e.=$d=$s[$x];map{$s[$j++]=$a[$x%2]}1..$d;$x++}1..$a[-1];print$e
-l ($a,$b,$c)=@ARGV;$o=$a x$a.$b x($a>1?$a:$b);$o.=$ARGV[$_%2]x substr$o,$_,1
for 2..$c;print substr$o,0,$c
-l ($%,$/)=@ARGV;$@=$%x$%.$/x($%==1?$/:$%);map{$@.=($_%2?$/:$%)x substr
$@,$_,1}2..500;print substr $@,0,pop
@a=@ARGV;while($a[2]--){if($_){s/.//;print$&;$_.=$a[$|--
]x$&}else{$_=$a[$|]x$a[$|--];s/.//;print$&}}print"
-l ($b,$a,$d)=@ARGV;do{push@l,split//,$b x($l[$c++]?$l[$c-
1]:$b);($a,$b)=($b,$a)}while@l<$d;print@l[0..$d-1]
@t=shift;$b=shift;for(1..pop){for(1..$t[$n]){@t[$i++]=$n%2?$b:$t[0]}$t[1]=$t[1]
||$b;$f.=$t[$n++]}print"$f\n"
@t=@ARGV;$l=pop@t;$"='';for($s="@t";$n<999;$i=0){$s=~s/(.)/$t[++$n,$i++%2]x$1/g
e;}print substr($s,0,$l),"\n";
($.,$/,$,)=@ARGV;$_=($;=$.)x$.;while((length)<$,){$;=$:++%2?$.:$/;/.{$:}(.)/
;$_.=$;x($+||$;)}print/(.{$,})/
for(@*=@ARGV;@/<$*[2];){@/<2?push@/,($*[$/])x$*[$/++]:push@/,($*[$*%2])x$/[$/++
];$*++;}print@/[0..$*[2]-1],"
-l (@n[0,1],$c)=@ARGV;while($c>0){$c-
=$l=(substr($o,$j,1)||$n[$i]);$o.=$n[$i]x$l;$i=!$i;$j++;}print
substr$o,0,pop
-l @z=((@0=@ARGV)[0])x$0[0];$#z or@z=(1,($0[--$|])x$0[++$"]);@z=(@z,($0[--
$|])x$z[++$"])for 0..666;print@z[0..--$0[2]]
-l @z=(@0=@ARGV)[0]==1?(1,($0[--$|])x$0[++$"]):($0[0])x$0[0];@z=(@z,($0[--
$|])x$z[++$"])for 0..666;print@z[0..--$0[2]]
($a,$b,$c)=@ARGV;do{$r=substr$k,$i++,1;$r=$a if!$r;$k.=$a
x$r;($a,$b)=($b,$a)}until$c<length$k;print substr($k,0,$c)."\n"
-l ($=,$-)=@ARGV,@a=($=)x$=;$=<2&&($y=1)&&push@a,($-)x$-;map{push@a,($_%2?$-
:$=)x$a[$_]}1+$y..999;$"=!splice@a,pop;print"@a";
-l ($A,$B,$C)=@ARGV;$x=$A x$A;if($A<2){$x.=$B
x$B;$i++}for($i+1..$C){$c=$ARGV[$_%2];$x.=$c x substr$x,$_,1}print
substr$x,0,$C
-l ($e,$d)=(shift,shift);for($s=pop;$s;$s--
){s/(.)//;$m=$1||$e;for$i(1..$m){s/$/$e/}$1?1:s/(.)//;$q.=$1;($e,$d)=($d,$e)
}print$q
($a,$b,$l)=@ARGV;@a=(($a)x$a,($b)x($a==1?$b:$a));for(;($j+=2)<$l;){@a=(@a,($
a)x$a[$j]);@a=(@a,($b)x$a[$j+1])}print@a[0..$l-1]
-l while($l=$ARGV[2]-
length($s)){$d=$ARGV[($e++)%2];push@l,split//,"$d"x($l[0]||$d)
;$n=shift@l||$d;$s.="$d"x($n>$l?$l:$n)}print$s
$h=($n=shift)+shift;$l=pop;do{if(@s>1){$j=$s[$i++];}else{$j=$n;++$i;}push@s,
($n)x$j;$n=$h-$n;}while(@s<$l);splice@s,$l;print@s;
$l=pop;@A=@ARGV;L:$a.=$A[$j%2]x$A[$j++%2];goto L
if($a<2);while($j<$l){$a.=$A[$j%2]x substr($a,$j++,1);}print
substr($a,0,$l)."\n";
$c=pop;$b=pop;$a=pop;$_=$a;while($c--){print;@s=((split//,$a
x--$_),@s);($#s==-1)?$_=$b:($_=pop@s,@s=($b,@s));$t=$a;$a=$b;$b=$t}print"
($A,$R,$G)=@ARGV;$_=$A x$A;if($A<2){$_.=$R
x$R;$x++}for(;$x<$G;$x++){$t=$R;$t=$A if$x%2;$_.=$t x
substr$_,$x+1,1}print((substr$_,0,$G),"\n");
$x=$ARGV[0];$y=$ARGV[1];$p=0;while(length($_)<=$ARGV[2]){$_.=$x;m/(.{$p})(\d)/;
$_.=$x x($2-1);($x,$y)=($y,$x);$p++}chop
while(length($_)>$ARGV[2]);print$_."\n";
$a=$ARGV[0];$b=$ARGV[1];$c=$ARGV[2];$d=0;$e=$a;$f=$a;$o='';while(length
$o<$c){$o.=$e x$f;if($e==$a){$e=$b}else{$e=$a};$f=substr
$o,++$d,1;if(!$f){$f=$b}}$o=substr $o,0,$c;print "$o\n";
($a,$b,$c)=@ARGV;sub w{$e=$_[0];$d[$_]=$e for(@d..@d+$_[1]-
1);}w($a,$a);if($a<2){w($b,$b);$f++}while(@d<$c){$f++;if($e!=$a){w($a,$d[$f]
)}else{w($b,$d[$f])}}print substr(join("",@d),0,$c),"\n";
($x,$y,$c)=@ARGV;if ($x==$y&&$y==1){print"1"x$c,"\n";exit;}$o=$x
x$x;$z=$y;$i=1;if($x==1){$o.=$y x$y;$i++;$z=$x}while(length($o)<=$c){$o.=$z
x substr($o,$i,1);$i++;$z=($z eq $x)?$y:$x}print substr($o,0,$c),"\n";
($o,$e,$n)=@ARGV;for($x=0;$x<$o;$x++){g($o);$p++;}if($o==1){for($x=0;$x<$e;$x++
){g($e);$p++;}}$c=substr$s,$p,1;while($l<$n){g($c);$p++;$c=substr$s,$p,1;}pr
int substr$s,0,$n;print"\n";sub
g{($z)=@_;$l+=$z;$r=$ARGV[$w++%2];for($x=0;$x<$z;$x++){$s.=$r;}}
-l print map@@[$.++]=$ARGV[--@@[$@]||++$@,$@&1],1..pop
-l eval'$l=@a;map$l-=$_*!!$l,@a;push@a,$d=$ARGV[!!$l^$d==$ARGV[0]];'x
pop;print@a
-l eval'$l=$s++;map$l-=$_*!!$l,/./g;s/$/$d=$ARGV[!!$l^$d==$ARGV[0]]/e;'x
-l eval'$l=@a=/./g;map$l-=$_*!!$l,@a;s/$/$ARGV[!!$l^$a[-1]==$ARGV[0]]/;'x
-l $,=pop;$a=\substr$_="@ARGV "x$,,0,$,;s/(.) /$+x
substr$_,$i++,1/ewhile$i<$,;print$$a
-l $c=pop;$a=\substr$_="@ARGV "x$c,0,$c;eval's/(.) /$+x
substr$_,$i++,1/e;'x500;print$$a
-l $_=\substr$@=1x pop,0;$@="";substr($@.=$ARGV[$|--],-
1)x=substr$@,$_,1for$"..500;print$$_
-l eval'if($l=@a=/./g){$i++until($l-=$a[$i])<1}
$i=!s/$/$ARGV[($a[-1]==$ARGV[0])^!!$l]/;'x
-l print map$_=$ARGV[($.+=!--$.[$.])%2],@.=(0)x pop
-l print map$.[$!++]=$ARGV[1&($.+=!--$.[$.])],1..pop
-l print map$$[$.++]=$ARGV[--$$[$;]||++$;,$;&1],1..pop
s/.?/$ARGV[1&pos]x$&||2/ge>>9?print$_&'?'x pop,$/:do$0
print$_?$.[$!++]=$ARGV[--$.[$.]||++$.,$.%2]:$/for-pop..0
-l for$$(1..pop){$_.=$ARGV[1&grep$|<($$-=$_),/./g]}print
-l print eval'($_.=chop()x$+.$ARGV[$|--])=~/$&(.)/,'x pop
s/.?/$ARGV[1&pos]x($&||1)/geuntil/.{$ARGV[2]}/;print$&,$/
$;=pop;s/.?/$ARGV[1&pos]x($&||1)/eguntil/.{$;}/;print"$&
-l s/.?/$ARGV[1&pos]x($&||1)/eg until/.{$ARGV[2]}/;print$&
-l $_.=2while$|=s/./$ARGV[--$|]x$&/ge<999;print$_&'?'x pop
s/.?/$ARGV[1&pos]x$&||2/ge<999?do$0:print/(.{${\pop}})/,$/
s/.?/$ARGV[$|--]x($&||1)/eguntil$|=/.{$ARGV[2]}/;print"$&
map{@;[0..@;]=map{($ARGV[$|--])x$_}@;,@;;print}@;=1..pop,$/
s/.?/$ARGV[1&pos]x$&||1/eg until/(.{$ARGV[2]})./;print"$1
s/.?/$ARGV[$-[0]%2]x($&||1)/ge until/.{$ARGV[2]}/;print$&,$/
s/.|/$ARGV[(pos)%2]x$&||9/ge<999?do$0:printf"%.${\pop}s
",$_
$%[$_]=$ARGV[$"],$*||=$%[++$.],$"^=!--$*for 1..pop;print@%,$/
$_=2;{s/./$ARGV[$-[0]%2]x$&/eg;/.{$ARGV[2]}/?print"$&
-l print map{-@@+push@@,($==$ARGV[$|--])x($@[$.++]||$=)}1..pop
s/.?/$ARGV[$"++%2]x($&||1)/eg until$"=/.{$ARGV[2]}/;print$&.$/
$_[$_]=$ARGV[$|-=!--$z],$z>0or$z=$_[++$*]for 1..pop;print@_,$/
-l print map{@.=(($?=$ARGV[$|--])x($.[-1]||$?),@.);pop@.}1..pop
-l print map{(map@/=(($_)x($/[--$%]||$_),@/),@ARGV)[-$_]}1..pop
-l print map{push@@,($%=$ARGV[--$_%2])x($@=$@[$_]||$%);$@}1..pop
-li1 map{push@,,$ARGV[$^I^=!$h];($h||=$,[$m++])--}1..pop;print@,
-l print map{push@_,($n=$ARGV[$i%2])x($c=$_[$i++]||$n);$c}1..pop
-l print+map+chop($*=($.=$ARGV[1&~$_])x chop($_=$..$*).$*),1..pop
-l $_.=($d=$ARGV[$|--])x(/./g,$d)[$f++]until/.{$ARGV[2]}/;print$&
-l $_.=($k=$ARGV[$i&1])x(/./g,$k)[$i++]until/.{$ARGV[2]}/;print$&
-l print map{push@a,($%=$ARGV[$_%2])x($n=$a[$_]||$%);$n}0..-1+pop
-l $n=pop;push@_,($_)x(@_,$_)[$i++]for(@ARGV)x$n--;print@_[0..$n]
-l push@,,($.=$ARGV[$|--])x($,[$_]||$.)for@/=0..-1+pop;print@,[@/]
print+(map{push@_,($-=$ARGV[$|--])x($==$_[--$_]||$-);$=}1..pop),$/
-l push@r,($/=$ARGV[1&$i])x($s[$i++]=$r[$i]||$/)for 1..pop;print@s
-l $l=pop;push@s,($_)x($s[$i++]||$_)for(@ARGV)x$l;print@s[0..--$l]
-l $o=pop;push@_,($_)x($_[$l++]||$_)for(@ARGV)x$o--;print@_[0..$o]
push@>,($.=@ARGV[$|--])x(@>,$.)[$_]for 0..500;print@>[0..-1+pop],$/
-l $$=pop;s/.?/$ARGV[1&pos]x$&||$ARGV[0]/eg until/(.{$$})./;print$1
$_.=($,=$ARGV[$%%2])x((/./g)[$%++]||$,)until/.{$ARGV[2]}/;print$&.$/
push@$,($$=$ARGV[$|--])x($$[$_]||$$)for 0..500;$#$=-1+pop;print@$,$/
-l print map{push@_,($%=$ARGV[$/^=1])x($\xa7=$_[$_-1]||$%);$\xa7}++$/..pop
push@_,($"=$ARGV[$_&1])x($_[$_]||$")for+0..500;$#_=-1+pop;print@_,$/
push@@,($@=$ARGV[$_%2])x($@[$_]||$@)for 0..333;print@@[0..(pop)-1],$/
$_=11;s!.!$ARGV[$-[0]%2]x$&!eg,s!(.{$ARGV[2]}).*!$1
!swhile--$=;print
-l push@_,($~=$ARGV[$|--])x($_[$-++]||$~)for a..kn;print@_[0..pop()-1]
-l map{push@_,($%=$ARGV[$_%2])x($_[$_]||$%)}0..500;print@_[0..(pop)-1]
-l print map{push@v,($_)x($v[0]||$_);shift@v}map$ARGV[$_%2^1],(1..pop)
-l @.=@ARGV;$.=1,s/./$.[$.^=1]x$&/ge,$_.=$.[!$.]until/.{$.[2]}/;print$&
for$"(1..pop){/.$/;$_=($-=$ARGV[$"-1&1])x($&||$-).$_;print chop}print$/
-l $_.=($x=$ARGV[$i%2])x(/./g,$x)[$i++]while$i<500;print substr$_,0,pop
$$=pop;$.=$ARGV[$|--],$_.=$.x substr$_.$.,$*++,1while!/.{$$}/;print$&,$/
-l /.{$i}(.)/,$;=$ARGV[$i++%2],$_.=$;x($1||$;)until/.{$ARGV[2]}/;print$&
-l push@a,($ARGV[$_%2])x($a[$_]||$ARGV[$_])for 0..999;print@a[0..-1+pop]
-l $l=pop;@l=(@l,($m=$ARGV[$|--])x($l[$_]||$m))for 0..$l;print@l[0..$l-1]
push@1,($ARGV[$|--])x($1[$_]or$ARGV[$;++])for$1..332;print@1[0..-1+pop],$/
@t=@ARGV;for(1..pop){print$u=$f[$p++]||$t[$|];push@f,($t[$|--])x$u}die"\n"
-l print map{$.=~s/.//;$..=($=^=$%||=($==pop)^pop)x($&||$=-1);$&||$=}1..pop
-l $.=pop;push@*,($==$ARGV[$%%2])x($*[$%++]||$=)while$%<$.;print@*[0..$.-1]
-l substr($@.=$ARGV[$|--],-1)x=substr$@,$_,1for 0..500;print substr$@,0,pop
-l print map{$x=$a.$x;$e||=chop$x;--$e?$a:($a^=$b)^$b}2..pop,$b=pop^($a=pop)
-l push@b,($ARGV[$_%2])x($b[$_]||$ARGV[$_%2])for(0..500);print@b[0..pop()-1]
-l ($a,$b)=@ARGV;print map{push@s,($l=$_%2?$a:$b)x($s[0]||$l);shift@s}1..pop
-l until(/.{$ARGV[2]}/&&print$&){/.{$b}(.)/;$^=$ARGV[$b++%2];$_.=$^x($1||$^)}
$/=$ARGV[1-$_%2],$*.=$/x($2||$/),$*=~s/(.)(.?)/$2/,print$1for 1..pop;print'
-l map{$s.=($a=$ARGV[$_%2])x(substr($s,$_,1)||$a)}0..999;print substr$s,0,pop
-l $n=pop;@l=@a=@ARGV;$i=0until(@l=map{($a[$i++&1])x$_}@l)>$n;print@l[0..--$n]
-l --$|,push@l,map$ARGV[!$|],1..$l[$_]||$ARGV[$_]for 0..500;print@l[0..pop()-1]
@a=@ARGV;s//@a/;while($i<666){$i=0;s/./$a[$i++&1]x$&/ge}s|.{$a[2]}|print$&,$/|e
-l *,=*ARGV;($,.=$,[$|])=~s,.,,,$,.=$,[$|--]x($&-
1),$_.=$&while$,[2]>y|||c;print
-l @A=@ARGV;push@a,($A[$_%2])x($a[$_]||$A[$_%2])for 0..$A[2];print@a[0..$A[2]-
-l @A=@ARGV;$z=$A[$_%2],push@a,($z)x($a[$_]||$z)for 0..$A[2];print@a[0..$A[2]-
-l for(0..pop){@s=(@ARGV)x999;push@a,($s[$i++])x($a[$_]||$s[$_])}print@a[0..$i-
-l @K=@ARGV;for$i(0..500){for(1..$K[$i]){$K[$p++]=$ARGV[$i%2]}}print@K[0..-
-l @a=@ARGV;print map{$n=$a[$_%2];push@d,$n for 1..$d[0]||$n;shift@d;}0..$a[2]-
-l @d=@ARGV;while($d[2]--){$b[$n++]=$d[$m%2];if($i++==$b[$m]-
1){$i=0;$m++}}print@b
-l ($a,$b,$t)=@ARGV;map{push@a,($c=$|--
?$b:$a)x($a[$_]||$c)}0..$t;print@a[0..$t-1]
-l $?=pop;$_.=($"=$ARGV[$x&1])x($:=($/=(/./g)[$x++]||$")>$??$?:$/)while$?-
=$:;print
-l for(;@o<501;++$c,$|--){push@o,($ARGV[$|])x($o[$c]||$ARGV[$|])}print@o[0..-
-l $n=pop;do{/.{$i}(.)/,$b=$ARGV[$i%2],$_.=$b
x($1||$b)}while$i++<$n;print/(.{$n})/
-l @a=@ARGV;map{$/=$a[$_%2];push@d,$/for
1..$d[$_]||$/}0..$a[2];print@d[0..$a[2]-1]
-l sub x{push@t,$ARGV[$i%2];$;--}$;=pop;while($;){x;$;&&x for
2..$t[$i];$i++}print@t
-l ($s,$t,$n)=@ARGV;$_=$s.$t;$p="$t$s"x$n,s/./chop($p)x$&/eg
until/(.{$n})./;print$1
-l ($x,$y,$a)=@ARGV;push@f,($|--?$y:$x)x($f[$_]||$|*$x||$y)for
0..$a;print@f[0..$a-1]
-l ($%,$.,$=)=@ARGV;($.,$%)=($%,$.),push@.,($.)x($.[$_]||$.)for
0..$=;print@.[0..$=-1]
@a=@ARGV;push@c,($a[$e&1])x@{$e<=@c?@c:@a}[$e++]while(@c<$a[2]);print@c[0..--
$a[2]],$/
-l $==pop;push@],($_)x($-++?$-<3?$%>1?$%:$_:$][$--
1]:($%=$_))for(@ARGV)x$=;print@][0..$=-1]
-l ($/,$b)=@ARGV;for(0..999){$;=$_%2?$b:$/;$k.=$;x(substr($k,$_,1)||$;)}print
substr$k,0,pop
$l=pop;@s=@ARGV;while(@l<$l){@l=(@l,($s[$c%2])x($l[$c]||$s[$c%2]));$c++}prin
t@l[
0..--$l]
-l @x=@ARGV;$i=shift;$z.=$x[$_%2]x$i,$i=substr$z.$x[1],$_+1,1for 0..567;print
substr$z,0,pop
($a,$b,$n)=@ARGV;$b^=$k=$a;$k||($a^=$b,$k=$R[++$p]||$a),(push@R,$a),$k--
while$n--;print@R,'
-l print+map{$c--||($v=$ARGV[$|--],$c=$_<1?$v:$_-1?$s[$_-$d]:$v,$d+=--
$c);$s[$_]=$v}0..-1+pop
($a,$b,$l)=@ARGV;push@a,($_%2?$b:$a)x($_<2?$a<2*$_?$b:$a:$a[$_])for
0..$l;print@a[0..$l-1],$/
($a,$b,$c)=@ARGV;for$i(0..$c){pos=$i;/./g;$_.=($i%2?$b:$a)x($_==1?$b:$&||$a)}pr
int/(.{$c})/,$/
($a,$b,$c)=@ARGV;while(@_<$c){map{push+_,$a}1..$_[$l++]||$a;$a^=$b^=$a^=$b}p
rint@_[0..$c-1]
b:if(@b==$ARGV[2]){print@b,"
";exit}push @b,$ARGV[$i%2];$k++;$k<$b[$i]&&goto b;$k=0;$i++;goto b
($a,$b,$c)=@ARGV;for(0..$c){$s.=($_%2?$b:$a)x(substr($s,$_,1)||shift)}print
substr($s,0,$c)."
($,,$;,$")=@ARGV;$_=$,x$,;$_.=(/$,$/?$;:$,)x(substr($_,++$i,1)||$;)while$i<$
";/.{$"}/;print$&
-l ($:,$;,$%)=@ARGV;$_=$:x$:;$_.=$;
x(substr$_,++$x,1or$;),($:,$;)=($;,$:)while$%>$x;/.{$%}/;print$&
@a=@ARGV;@b="";for$i(1..$a[2]){for$j(1..($b[$i]||$a[$t])){push(@b,$a[$t])}$t
=!$t;$_.=$b[$i]}print
-l ($a,$b,$l)=@ARGV;$b+=$a;for(1..$l){$p=$a-
1;$s.=@n?($p=pop@n):$a;@n=(($a)x$p,@n);$a=$b-$a;}print$s;
($n,$s,$i)=@ARGV;$l=0;map{push@r,(@ARGV[$l])x$n;$l=$l?0:1;$n=@r[$_]?@r[$_]:$
s;}1..500;print@r[0..--$i]
-l ($.,$/,$")=@ARGV;split'',$.x$..$/;for(0..$"){$_[$%++]=$-
?$/:$.for(1..$_[$?++]);$-=1-$-}$#_=$"-1;print@_
@k=@ARGV;for(0..pop){splice(@k,$o,$k[$i],($x=shift)x$k[$i]),$o+=$k[$i++],pus
h@ARGV,$x}print @k[0..$i-2]
($a,$b,$c)=@ARGV;for$d(0..$c){push@e,$a;$f=$e[$d];for(2..$f){push@e,$a}($a,$
b)=($b,$a)}print@e[0..$c-1]
-l ($a)=@a=@ARGV;@s=($a,$a[$a-
1?0:1]);map{$e.=$d=$s[$x];map{$s[$j++]=$a[$x%2]}1..$d;$x++}1..$a[-1];print$e
-l ($a,$b,$c)=@ARGV;$o=$a x$a.$b x($a>1?$a:$b);$o.=$ARGV[$_%2]x substr$o,$_,1
for 2..$c;print substr$o,0,$c
-l ($%,$/)=@ARGV;$@=$%x$%.$/x($%==1?$/:$%);map{$@.=($_%2?$/:$%)x substr
$@,$_,1}2..500;print substr $@,0,pop
@a=@ARGV;while($a[2]--){if($_){s/.//;print$&;$_.=$a[$|--
]x$&}else{$_=$a[$|]x$a[$|--];s/.//;print$&}}print"
-l ($b,$a,$d)=@ARGV;do{push@l,split//,$b x($l[$c++]?$l[$c-
1]:$b);($a,$b)=($b,$a)}while@l<$d;print@l[0..$d-1]
@t=shift;$b=shift;for(1..pop){for(1..$t[$n]){@t[$i++]=$n%2?$b:$t[0]}$t[1]=$t[1]
||$b;$f.=$t[$n++]}print"$f\n"
@t=@ARGV;$l=pop@t;$"='';for($s="@t";$n<999;$i=0){$s=~s/(.)/$t[++$n,$i++%2]x$1/g
e;}print substr($s,0,$l),"\n";
($.,$/,$,)=@ARGV;$_=($;=$.)x$.;while((length)<$,){$;=$:++%2?$.:$/;/.{$:}(.)/
;$_.=$;x($+||$;)}print/(.{$,})/
for(@*=@ARGV;@/<$*[2];){@/<2?push@/,($*[$/])x$*[$/++]:push@/,($*[$*%2])x$/[$/++
];$*++;}print@/[0..$*[2]-1],"
-l (@n[0,1],$c)=@ARGV;while($c>0){$c-
=$l=(substr($o,$j,1)||$n[$i]);$o.=$n[$i]x$l;$i=!$i;$j++;}print
substr$o,0,pop
-l @z=((@0=@ARGV)[0])x$0[0];$#z or@z=(1,($0[--$|])x$0[++$"]);@z=(@z,($0[--
$|])x$z[++$"])for 0..666;print@z[0..--$0[2]]
-l @z=(@0=@ARGV)[0]==1?(1,($0[--$|])x$0[++$"]):($0[0])x$0[0];@z=(@z,($0[--
$|])x$z[++$"])for 0..666;print@z[0..--$0[2]]
($a,$b,$c)=@ARGV;do{$r=substr$k,$i++,1;$r=$a if!$r;$k.=$a
x$r;($a,$b)=($b,$a)}until$c<length$k;print substr($k,0,$c)."\n"
-l ($=,$-)=@ARGV,@a=($=)x$=;$=<2&&($y=1)&&push@a,($-)x$-;map{push@a,($_%2?$-
:$=)x$a[$_]}1+$y..999;$"=!splice@a,pop;print"@a";
-l ($A,$B,$C)=@ARGV;$x=$A x$A;if($A<2){$x.=$B
x$B;$i++}for($i+1..$C){$c=$ARGV[$_%2];$x.=$c x substr$x,$_,1}print
substr$x,0,$C
-l ($e,$d)=(shift,shift);for($s=pop;$s;$s--
){s/(.)//;$m=$1||$e;for$i(1..$m){s/$/$e/}$1?1:s/(.)//;$q.=$1;($e,$d)=($d,$e)
}print$q
($a,$b,$l)=@ARGV;@a=(($a)x$a,($b)x($a==1?$b:$a));for(;($j+=2)<$l;){@a=(@a,($
a)x$a[$j]);@a=(@a,($b)x$a[$j+1])}print@a[0..$l-1]
-l while($l=$ARGV[2]-
length($s)){$d=$ARGV[($e++)%2];push@l,split//,"$d"x($l[0]||$d)
;$n=shift@l||$d;$s.="$d"x($n>$l?$l:$n)}print$s
$h=($n=shift)+shift;$l=pop;do{if(@s>1){$j=$s[$i++];}else{$j=$n;++$i;}push@s,
($n)x$j;$n=$h-$n;}while(@s<$l);splice@s,$l;print@s;
$l=pop;@A=@ARGV;L:$a.=$A[$j%2]x$A[$j++%2];goto L
if($a<2);while($j<$l){$a.=$A[$j%2]x substr($a,$j++,1);}print
substr($a,0,$l)."\n";
$c=pop;$b=pop;$a=pop;$_=$a;while($c--){print;@s=((split//,$a
x--$_),@s);($#s==-1)?$_=$b:($_=pop@s,@s=($b,@s));$t=$a;$a=$b;$b=$t}print"
($A,$R,$G)=@ARGV;$_=$A x$A;if($A<2){$_.=$R
x$R;$x++}for(;$x<$G;$x++){$t=$R;$t=$A if$x%2;$_.=$t x
substr$_,$x+1,1}print((substr$_,0,$G),"\n");
$x=$ARGV[0];$y=$ARGV[1];$p=0;while(length($_)<=$ARGV[2]){$_.=$x;m/(.{$p})(\d)/;
$_.=$x x($2-1);($x,$y)=($y,$x);$p++}chop
while(length($_)>$ARGV[2]);print$_."\n";
$a=$ARGV[0];$b=$ARGV[1];$c=$ARGV[2];$d=0;$e=$a;$f=$a;$o='';while(length
$o<$c){$o.=$e x$f;if($e==$a){$e=$b}else{$e=$a};$f=substr
$o,++$d,1;if(!$f){$f=$b}}$o=substr $o,0,$c;print "$o\n";
($a,$b,$c)=@ARGV;sub w{$e=$_[0];$d[$_]=$e for(@d..@d+$_[1]-
1);}w($a,$a);if($a<2){w($b,$b);$f++}while(@d<$c){$f++;if($e!=$a){w($a,$d[$f]
)}else{w($b,$d[$f])}}print substr(join("",@d),0,$c),"\n";
($x,$y,$c)=@ARGV;if ($x==$y&&$y==1){print"1"x$c,"\n";exit;}$o=$x
x$x;$z=$y;$i=1;if($x==1){$o.=$y x$y;$i++;$z=$x}while(length($o)<=$c){$o.=$z
x substr($o,$i,1);$i++;$z=($z eq $x)?$y:$x}print substr($o,0,$c),"\n";
($o,$e,$n)=@ARGV;for($x=0;$x<$o;$x++){g($o);$p++;}if($o==1){for($x=0;$x<$e;$x++
){g($e);$p++;}}$c=substr$s,$p,1;while($l<$n){g($c);$p++;$c=substr$s,$p,1;}pr
int substr$s,0,$n;print"\n";sub
g{($z)=@_;$l+=$z;$r=$ARGV[$w++%2];for($x=0;$x<$z;$x++){$s.=$r;}}
-l print map@@[$.++]=$ARGV[--@@[$@]||++$@,$@&1],1..pop
-l eval'$l=@a;map$l-=$_*!!$l,@a;push@a,$d=$ARGV[!!$l^$d==$ARGV[0]];'x
pop;print@a
-l eval'$l=$s++;map$l-=$_*!!$l,/./g;s/$/$d=$ARGV[!!$l^$d==$ARGV[0]]/e;'x
-l eval'$l=@a=/./g;map$l-=$_*!!$l,@a;s/$/$ARGV[!!$l^$a[-1]==$ARGV[0]]/;'x
-l $,=pop;$a=\substr$_="@ARGV "x$,,0,$,;s/(.) /$+x
substr$_,$i++,1/ewhile$i<$,;print$$a
-l $c=pop;$a=\substr$_="@ARGV "x$c,0,$c;eval's/(.) /$+x
substr$_,$i++,1/e;'x500;print$$a
-l $_=\substr$@=1x pop,0;$@="";substr($@.=$ARGV[$|--],-
1)x=substr$@,$_,1for$"..500;print$$_
-l eval'if($l=@a=/./g){$i++until($l-=$a[$i])<1}
$i=!s/$/$ARGV[($a[-1]==$ARGV[0])^!!$l]/;'x
51 (post-mortem) 
-l print map$_=$ARGV[($.+=!--$.[$.])%2],@.=(0)x pop
-l print map$.[$!++]=$ARGV[1&($.+=!--$.[$.])],1..pop
-l print map$$[$.++]=$ARGV[--$$[$;]||++$;,$;&1],1..pop
s/.?/$ARGV[1&pos]x$&||2/ge>>9?print$_&'?'x pop,$/:do$0
print$_?$.[$!++]=$ARGV[--$.[$.]||++$.,$.%2]:$/for-pop..0
-l for$$(1..pop){$_.=$ARGV[1&grep$|<($$-=$_),/./g]}print
-l print eval'($_.=chop()x$+.$ARGV[$|--])=~/$&(.)/,'x pop
s/.?/$ARGV[1&pos]x($&||1)/geuntil/.{$ARGV[2]}/;print$&,$/
$;=pop;s/.?/$ARGV[1&pos]x($&||1)/eguntil/.{$;}/;print"$&
-l s/.?/$ARGV[1&pos]x($&||1)/eg until/.{$ARGV[2]}/;print$&
-l $_.=2while$|=s/./$ARGV[--$|]x$&/ge<999;print$_&'?'x pop
s/.?/$ARGV[1&pos]x$&||2/ge<999?do$0:print/(.{${\pop}})/,$/
s/.?/$ARGV[$|--]x($&||1)/eguntil$|=/.{$ARGV[2]}/;print"$&
map{@;[0..@;]=map{($ARGV[$|--])x$_}@;,@;;print}@;=1..pop,$/
s/.?/$ARGV[1&pos]x$&||1/eg until/(.{$ARGV[2]})./;print"$1
s/.?/$ARGV[$-[0]%2]x($&||1)/ge until/.{$ARGV[2]}/;print$&,$/
s/.|/$ARGV[(pos)%2]x$&||9/ge<999?do$0:printf"%.${\pop}s
",$_
$%[$_]=$ARGV[$"],$*||=$%[++$.],$"^=!--$*for 1..pop;print@%,$/
$_=2;{s/./$ARGV[$-[0]%2]x$&/eg;/.{$ARGV[2]}/?print"$&
-l print map{-@@+push@@,($==$ARGV[$|--])x($@[$.++]||$=)}1..pop
s/.?/$ARGV[$"++%2]x($&||1)/eg until$"=/.{$ARGV[2]}/;print$&.$/
$_[$_]=$ARGV[$|-=!--$z],$z>0or$z=$_[++$*]for 1..pop;print@_,$/
-l print map{@.=(($?=$ARGV[$|--])x($.[-1]||$?),@.);pop@.}1..pop
-l print map{(map@/=(($_)x($/[--$%]||$_),@/),@ARGV)[-$_]}1..pop
-l print map{push@@,($%=$ARGV[--$_%2])x($@=$@[$_]||$%);$@}1..pop
-li1 map{push@,,$ARGV[$^I^=!$h];($h||=$,[$m++])--}1..pop;print@,
-l print map{push@_,($n=$ARGV[$i%2])x($c=$_[$i++]||$n);$c}1..pop
-l print+map+chop($*=($.=$ARGV[1&~$_])x chop($_=$..$*).$*),1..pop
-l $_.=($d=$ARGV[$|--])x(/./g,$d)[$f++]until/.{$ARGV[2]}/;print$&
-l $_.=($k=$ARGV[$i&1])x(/./g,$k)[$i++]until/.{$ARGV[2]}/;print$&
-l print map{push@a,($%=$ARGV[$_%2])x($n=$a[$_]||$%);$n}0..-1+pop
-l $n=pop;push@_,($_)x(@_,$_)[$i++]for(@ARGV)x$n--;print@_[0..$n]
-l push@,,($.=$ARGV[$|--])x($,[$_]||$.)for@/=0..-1+pop;print@,[@/]
print+(map{push@_,($-=$ARGV[$|--])x($==$_[--$_]||$-);$=}1..pop),$/
-l push@r,($/=$ARGV[1&$i])x($s[$i++]=$r[$i]||$/)for 1..pop;print@s
-l $l=pop;push@s,($_)x($s[$i++]||$_)for(@ARGV)x$l;print@s[0..--$l]
-l $o=pop;push@_,($_)x($_[$l++]||$_)for(@ARGV)x$o--;print@_[0..$o]
push@>,($.=@ARGV[$|--])x(@>,$.)[$_]for 0..500;print@>[0..-1+pop],$/
-l $$=pop;s/.?/$ARGV[1&pos]x$&||$ARGV[0]/eg until/(.{$$})./;print$1
$_.=($,=$ARGV[$%%2])x((/./g)[$%++]||$,)until/.{$ARGV[2]}/;print$&.$/
push@$,($$=$ARGV[$|--])x($$[$_]||$$)for 0..500;$#$=-1+pop;print@$,$/
-l print map{push@_,($%=$ARGV[$/^=1])x($\xa7=$_[$_-1]||$%);$\xa7}++$/..pop
push@_,($"=$ARGV[$_&1])x($_[$_]||$")for+0..500;$#_=-1+pop;print@_,$/
push@@,($@=$ARGV[$_%2])x($@[$_]||$@)for 0..333;print@@[0..(pop)-1],$/
$_=11;s!.!$ARGV[$-[0]%2]x$&!eg,s!(.{$ARGV[2]}).*!$1
!swhile--$=;print
-l push@_,($~=$ARGV[$|--])x($_[$-++]||$~)for a..kn;print@_[0..pop()-1]
-l map{push@_,($%=$ARGV[$_%2])x($_[$_]||$%)}0..500;print@_[0..(pop)-1]
-l print map{push@v,($_)x($v[0]||$_);shift@v}map$ARGV[$_%2^1],(1..pop)
-l @.=@ARGV;$.=1,s/./$.[$.^=1]x$&/ge,$_.=$.[!$.]until/.{$.[2]}/;print$&
for$"(1..pop){/.$/;$_=($-=$ARGV[$"-1&1])x($&||$-).$_;print chop}print$/
-l $_.=($x=$ARGV[$i%2])x(/./g,$x)[$i++]while$i<500;print substr$_,0,pop
$$=pop;$.=$ARGV[$|--],$_.=$.x substr$_.$.,$*++,1while!/.{$$}/;print$&,$/
-l /.{$i}(.)/,$;=$ARGV[$i++%2],$_.=$;x($1||$;)until/.{$ARGV[2]}/;print$&
-l push@a,($ARGV[$_%2])x($a[$_]||$ARGV[$_])for 0..999;print@a[0..-1+pop]
-l $l=pop;@l=(@l,($m=$ARGV[$|--])x($l[$_]||$m))for 0..$l;print@l[0..$l-1]
push@1,($ARGV[$|--])x($1[$_]or$ARGV[$;++])for$1..332;print@1[0..-1+pop],$/
@t=@ARGV;for(1..pop){print$u=$f[$p++]||$t[$|];push@f,($t[$|--])x$u}die"\n"
-l print map{$.=~s/.//;$..=($=^=$%||=($==pop)^pop)x($&||$=-1);$&||$=}1..pop
-l $.=pop;push@*,($==$ARGV[$%%2])x($*[$%++]||$=)while$%<$.;print@*[0..$.-1]
-l substr($@.=$ARGV[$|--],-1)x=substr$@,$_,1for 0..500;print substr$@,0,pop
-l print map{$x=$a.$x;$e||=chop$x;--$e?$a:($a^=$b)^$b}2..pop,$b=pop^($a=pop)
-l push@b,($ARGV[$_%2])x($b[$_]||$ARGV[$_%2])for(0..500);print@b[0..pop()-1]
-l ($a,$b)=@ARGV;print map{push@s,($l=$_%2?$a:$b)x($s[0]||$l);shift@s}1..pop
-l until(/.{$ARGV[2]}/&&print$&){/.{$b}(.)/;$^=$ARGV[$b++%2];$_.=$^x($1||$^)}
$/=$ARGV[1-$_%2],$*.=$/x($2||$/),$*=~s/(.)(.?)/$2/,print$1for 1..pop;print'
-l map{$s.=($a=$ARGV[$_%2])x(substr($s,$_,1)||$a)}0..999;print substr$s,0,pop
-l $n=pop;@l=@a=@ARGV;$i=0until(@l=map{($a[$i++&1])x$_}@l)>$n;print@l[0..--$n]
-l --$|,push@l,map$ARGV[!$|],1..$l[$_]||$ARGV[$_]for 0..500;print@l[0..pop()-1]
@a=@ARGV;s//@a/;while($i<666){$i=0;s/./$a[$i++&1]x$&/ge}s|.{$a[2]}|print$&,$/|e
-l *,=*ARGV;($,.=$,[$|])=~s,.,,,$,.=$,[$|--]x($&-
1),$_.=$&while$,[2]>y|||c;print
-l @A=@ARGV;push@a,($A[$_%2])x($a[$_]||$A[$_%2])for 0..$A[2];print@a[0..$A[2]-
-l @A=@ARGV;$z=$A[$_%2],push@a,($z)x($a[$_]||$z)for 0..$A[2];print@a[0..$A[2]-
-l for(0..pop){@s=(@ARGV)x999;push@a,($s[$i++])x($a[$_]||$s[$_])}print@a[0..$i-
-l @K=@ARGV;for$i(0..500){for(1..$K[$i]){$K[$p++]=$ARGV[$i%2]}}print@K[0..-
-l @a=@ARGV;print map{$n=$a[$_%2];push@d,$n for 1..$d[0]||$n;shift@d;}0..$a[2]-
-l @d=@ARGV;while($d[2]--){$b[$n++]=$d[$m%2];if($i++==$b[$m]-
1){$i=0;$m++}}print@b
-l ($a,$b,$t)=@ARGV;map{push@a,($c=$|--
?$b:$a)x($a[$_]||$c)}0..$t;print@a[0..$t-1]
-l $?=pop;$_.=($"=$ARGV[$x&1])x($:=($/=(/./g)[$x++]||$")>$??$?:$/)while$?-
=$:;print
-l for(;@o<501;++$c,$|--){push@o,($ARGV[$|])x($o[$c]||$ARGV[$|])}print@o[0..-
-l $n=pop;do{/.{$i}(.)/,$b=$ARGV[$i%2],$_.=$b
x($1||$b)}while$i++<$n;print/(.{$n})/
-l @a=@ARGV;map{$/=$a[$_%2];push@d,$/for
1..$d[$_]||$/}0..$a[2];print@d[0..$a[2]-1]
-l sub x{push@t,$ARGV[$i%2];$;--}$;=pop;while($;){x;$;&&x for
2..$t[$i];$i++}print@t
-l ($s,$t,$n)=@ARGV;$_=$s.$t;$p="$t$s"x$n,s/./chop($p)x$&/eg
until/(.{$n})./;print$1
-l ($x,$y,$a)=@ARGV;push@f,($|--?$y:$x)x($f[$_]||$|*$x||$y)for
0..$a;print@f[0..$a-1]
-l ($%,$.,$=)=@ARGV;($.,$%)=($%,$.),push@.,($.)x($.[$_]||$.)for
0..$=;print@.[0..$=-1]
@a=@ARGV;push@c,($a[$e&1])x@{$e<=@c?@c:@a}[$e++]while(@c<$a[2]);print@c[0..--
$a[2]],$/
-l $==pop;push@],($_)x($-++?$-<3?$%>1?$%:$_:$][$--
1]:($%=$_))for(@ARGV)x$=;print@][0..$=-1]
-l ($/,$b)=@ARGV;for(0..999){$;=$_%2?$b:$/;$k.=$;x(substr($k,$_,1)||$;)}print
substr$k,0,pop
$l=pop;@s=@ARGV;while(@l<$l){@l=(@l,($s[$c%2])x($l[$c]||$s[$c%2]));$c++}prin
t@l[
0..--$l]
-l @x=@ARGV;$i=shift;$z.=$x[$_%2]x$i,$i=substr$z.$x[1],$_+1,1for 0..567;print
substr$z,0,pop
($a,$b,$n)=@ARGV;$b^=$k=$a;$k||($a^=$b,$k=$R[++$p]||$a),(push@R,$a),$k--
while$n--;print@R,'
-l print+map{$c--||($v=$ARGV[$|--],$c=$_<1?$v:$_-1?$s[$_-$d]:$v,$d+=--
$c);$s[$_]=$v}0..-1+pop
($a,$b,$l)=@ARGV;push@a,($_%2?$b:$a)x($_<2?$a<2*$_?$b:$a:$a[$_])for
0..$l;print@a[0..$l-1],$/
($a,$b,$c)=@ARGV;for$i(0..$c){pos=$i;/./g;$_.=($i%2?$b:$a)x($_==1?$b:$&||$a)}pr
int/(.{$c})/,$/
($a,$b,$c)=@ARGV;while(@_<$c){map{push+_,$a}1..$_[$l++]||$a;$a^=$b^=$a^=$b}p
rint@_[0..$c-1]
b:if(@b==$ARGV[2]){print@b,"
";exit}push @b,$ARGV[$i%2];$k++;$k<$b[$i]&&goto b;$k=0;$i++;goto b
($a,$b,$c)=@ARGV;for(0..$c){$s.=($_%2?$b:$a)x(substr($s,$_,1)||shift)}print
substr($s,0,$c)."
($,,$;,$")=@ARGV;$_=$,x$,;$_.=(/$,$/?$;:$,)x(substr($_,++$i,1)||$;)while$i<$
";/.{$"}/;print$&
-l ($:,$;,$%)=@ARGV;$_=$:x$:;$_.=$;
x(substr$_,++$x,1or$;),($:,$;)=($;,$:)while$%>$x;/.{$%}/;print$&
@a=@ARGV;@b="";for$i(1..$a[2]){for$j(1..($b[$i]||$a[$t])){push(@b,$a[$t])}$t
=!$t;$_.=$b[$i]}print
-l ($a,$b,$l)=@ARGV;$b+=$a;for(1..$l){$p=$a-
1;$s.=@n?($p=pop@n):$a;@n=(($a)x$p,@n);$a=$b-$a;}print$s;
($n,$s,$i)=@ARGV;$l=0;map{push@r,(@ARGV[$l])x$n;$l=$l?0:1;$n=@r[$_]?@r[$_]:$
s;}1..500;print@r[0..--$i]
-l ($.,$/,$")=@ARGV;split'',$.x$..$/;for(0..$"){$_[$%++]=$-
?$/:$.for(1..$_[$?++]);$-=1-$-}$#_=$"-1;print@_
@k=@ARGV;for(0..pop){splice(@k,$o,$k[$i],($x=shift)x$k[$i]),$o+=$k[$i++],pus
h@ARGV,$x}print @k[0..$i-2]
($a,$b,$c)=@ARGV;for$d(0..$c){push@e,$a;$f=$e[$d];for(2..$f){push@e,$a}($a,$
b)=($b,$a)}print@e[0..$c-1]
-l ($a)=@a=@ARGV;@s=($a,$a[$a-
1?0:1]);map{$e.=$d=$s[$x];map{$s[$j++]=$a[$x%2]}1..$d;$x++}1..$a[-1];print$e
-l ($a,$b,$c)=@ARGV;$o=$a x$a.$b x($a>1?$a:$b);$o.=$ARGV[$_%2]x substr$o,$_,1
for 2..$c;print substr$o,0,$c
-l ($%,$/)=@ARGV;$@=$%x$%.$/x($%==1?$/:$%);map{$@.=($_%2?$/:$%)x substr
$@,$_,1}2..500;print substr $@,0,pop
@a=@ARGV;while($a[2]--){if($_){s/.//;print$&;$_.=$a[$|--
]x$&}else{$_=$a[$|]x$a[$|--];s/.//;print$&}}print"
-l ($b,$a,$d)=@ARGV;do{push@l,split//,$b x($l[$c++]?$l[$c-
1]:$b);($a,$b)=($b,$a)}while@l<$d;print@l[0..$d-1]
@t=shift;$b=shift;for(1..pop){for(1..$t[$n]){@t[$i++]=$n%2?$b:$t[0]}$t[1]=$t[1]
||$b;$f.=$t[$n++]}print"$f\n"
@t=@ARGV;$l=pop@t;$"='';for($s="@t";$n<999;$i=0){$s=~s/(.)/$t[++$n,$i++%2]x$1/g
e;}print substr($s,0,$l),"\n";
($.,$/,$,)=@ARGV;$_=($;=$.)x$.;while((length)<$,){$;=$:++%2?$.:$/;/.{$:}(.)/
;$_.=$;x($+||$;)}print/(.{$,})/
for(@*=@ARGV;@/<$*[2];){@/<2?push@/,($*[$/])x$*[$/++]:push@/,($*[$*%2])x$/[$/++
];$*++;}print@/[0..$*[2]-1],"
-l (@n[0,1],$c)=@ARGV;while($c>0){$c-
=$l=(substr($o,$j,1)||$n[$i]);$o.=$n[$i]x$l;$i=!$i;$j++;}print
substr$o,0,pop
-l @z=((@0=@ARGV)[0])x$0[0];$#z or@z=(1,($0[--$|])x$0[++$"]);@z=(@z,($0[--
$|])x$z[++$"])for 0..666;print@z[0..--$0[2]]
-l @z=(@0=@ARGV)[0]==1?(1,($0[--$|])x$0[++$"]):($0[0])x$0[0];@z=(@z,($0[--
$|])x$z[++$"])for 0..666;print@z[0..--$0[2]]
($a,$b,$c)=@ARGV;do{$r=substr$k,$i++,1;$r=$a if!$r;$k.=$a
x$r;($a,$b)=($b,$a)}until$c<length$k;print substr($k,0,$c)."\n"
-l ($=,$-)=@ARGV,@a=($=)x$=;$=<2&&($y=1)&&push@a,($-)x$-;map{push@a,($_%2?$-
:$=)x$a[$_]}1+$y..999;$"=!splice@a,pop;print"@a";
-l ($A,$B,$C)=@ARGV;$x=$A x$A;if($A<2){$x.=$B
x$B;$i++}for($i+1..$C){$c=$ARGV[$_%2];$x.=$c x substr$x,$_,1}print
substr$x,0,$C
-l ($e,$d)=(shift,shift);for($s=pop;$s;$s--
){s/(.)//;$m=$1||$e;for$i(1..$m){s/$/$e/}$1?1:s/(.)//;$q.=$1;($e,$d)=($d,$e)
}print$q
($a,$b,$l)=@ARGV;@a=(($a)x$a,($b)x($a==1?$b:$a));for(;($j+=2)<$l;){@a=(@a,($
a)x$a[$j]);@a=(@a,($b)x$a[$j+1])}print@a[0..$l-1]
-l while($l=$ARGV[2]-
length($s)){$d=$ARGV[($e++)%2];push@l,split//,"$d"x($l[0]||$d)
;$n=shift@l||$d;$s.="$d"x($n>$l?$l:$n)}print$s
$h=($n=shift)+shift;$l=pop;do{if(@s>1){$j=$s[$i++];}else{$j=$n;++$i;}push@s,
($n)x$j;$n=$h-$n;}while(@s<$l);splice@s,$l;print@s;
$l=pop;@A=@ARGV;L:$a.=$A[$j%2]x$A[$j++%2];goto L
if($a<2);while($j<$l){$a.=$A[$j%2]x substr($a,$j++,1);}print
substr($a,0,$l)."\n";
$c=pop;$b=pop;$a=pop;$_=$a;while($c--){print;@s=((split//,$a
x--$_),@s);($#s==-1)?$_=$b:($_=pop@s,@s=($b,@s));$t=$a;$a=$b;$b=$t}print"
($A,$R,$G)=@ARGV;$_=$A x$A;if($A<2){$_.=$R
x$R;$x++}for(;$x<$G;$x++){$t=$R;$t=$A if$x%2;$_.=$t x
substr$_,$x+1,1}print((substr$_,0,$G),"\n");
$x=$ARGV[0];$y=$ARGV[1];$p=0;while(length($_)<=$ARGV[2]){$_.=$x;m/(.{$p})(\d)/;
$_.=$x x($2-1);($x,$y)=($y,$x);$p++}chop
while(length($_)>$ARGV[2]);print$_."\n";
$a=$ARGV[0];$b=$ARGV[1];$c=$ARGV[2];$d=0;$e=$a;$f=$a;$o='';while(length
$o<$c){$o.=$e x$f;if($e==$a){$e=$b}else{$e=$a};$f=substr
$o,++$d,1;if(!$f){$f=$b}}$o=substr $o,0,$c;print "$o\n";
($a,$b,$c)=@ARGV;sub w{$e=$_[0];$d[$_]=$e for(@d..@d+$_[1]-
1);}w($a,$a);if($a<2){w($b,$b);$f++}while(@d<$c){$f++;if($e!=$a){w($a,$d[$f]
)}else{w($b,$d[$f])}}print substr(join("",@d),0,$c),"\n";
($x,$y,$c)=@ARGV;if ($x==$y&&$y==1){print"1"x$c,"\n";exit;}$o=$x
x$x;$z=$y;$i=1;if($x==1){$o.=$y x$y;$i++;$z=$x}while(length($o)<=$c){$o.=$z
x substr($o,$i,1);$i++;$z=($z eq $x)?$y:$x}print substr($o,0,$c),"\n";
($o,$e,$n)=@ARGV;for($x=0;$x<$o;$x++){g($o);$p++;}if($o==1){for($x=0;$x<$e;$x++
){g($e);$p++;}}$c=substr$s,$p,1;while($l<$n){g($c);$p++;$c=substr$s,$p,1;}pr
int substr$s,0,$n;print"\n";sub
g{($z)=@_;$l+=$z;$r=$ARGV[$w++%2];for($x=0;$x<$z;$x++){$s.=$r;}}
-l print map@@[$.++]=$ARGV[--@@[$@]||++$@,$@&1],1..pop
-l eval'$l=@a;map$l-=$_*!!$l,@a;push@a,$d=$ARGV[!!$l^$d==$ARGV[0]];'x
pop;print@a
-l eval'$l=$s++;map$l-=$_*!!$l,/./g;s/$/$d=$ARGV[!!$l^$d==$ARGV[0]]/e;'x
-l eval'$l=@a=/./g;map$l-=$_*!!$l,@a;s/$/$ARGV[!!$l^$a[-1]==$ARGV[0]]/;'x
-l $,=pop;$a=\substr$_="@ARGV "x$,,0,$,;s/(.) /$+x
substr$_,$i++,1/ewhile$i<$,;print$$a
-l $c=pop;$a=\substr$_="@ARGV "x$c,0,$c;eval's/(.) /$+x
substr$_,$i++,1/e;'x500;print$$a
-l $_=\substr$@=1x pop,0;$@="";substr($@.=$ARGV[$|--],-
1)x=substr$@,$_,1for$"..500;print$$_
-l eval'if($l=@a=/./g){$i++until($l-=$a[$i])<1}
$i=!s/$/$ARGV[($a[-1]==$ARGV[0])^!!$l]/;'x
$$a=$a=pop;$b=pop;s/(.+) (.+)/$2 $1/,$$2||=$$1&&"$2 $$1"for(<>)x2e3;print"$$b
-l map$_=pop|$$_,$b,$a;/ (.*)/,$$1=$`for<>;s/,|$/ $a,$b /;s/( .+
).+\1/$1/?print/ (.*) /:do$0
$$a=$a=pop;$b=pop;/(.+) (.+)/,$$2||=$$1&&"$2 $$1",$$1||=$$2&&"$1
$$2"for(@F=<>)x@F;print"$$b
95, mtve (would be rejected after 2.5 years, due to $ARGV problem) 
-lp INIT{$0=pop;$x=pop}/ /,${$'}=$`}{s/.+/${$&}/guntil$_="$x
INIT{$l=pop;$c=pop}%r=%R=reverse@F;0while$R{$c}=$p,$c=$r{$p=$c};$_=$l;s//$l
/while$l=$R{$l}
-lp / /;${$'}=$`}INIT{$l=pop;$f=pop}{do{@$f=@t=(@t,$f)}while$f=$$f;s//
$l/,$l=$$l until@$l;s//@$l/
-l $_=pop|$$_ for$b,$a;/ (.*)/,$$1=$`for<>;s/0|^$/$a 0 $b/;$a|$b?do$0:s/( .+
|\bRo).+\b\1/$1/+print
-lp / /;${$'}=$`}BEGIN{$l=pop;$f=pop}{do{@$f=@t=(@t,$f)}while$f=$$f;s//
$l/,$l=$$l until@$l;s//@$l/
-l $_=pop|$$_ for$b,$a;/ (.*)/,$$1=$`for<>;s/0|^$/$a 0 $b/;$a|$b?do$0:s/( .+
|\bRo).+\b\1/$1/+print
-l $_=pop|$$_ for$b,$a;/ (.*)/,$$1=$`for<>;s/0|^$/$a 0 $b/;$a|$b?do$0:s/( .+
|\bRo).+\b\1/$1/+print
$/+=$a=pop;$b=pop;$x=<>;sub k{print"@_\n"x/^$b/;s/ *$_[0]
*//^/^$_[1]$/&&k($_,@_)for$x=~/.+$/mg}k$a
-l map$_=pop|$$_,$b,$a;/ (.*)/,$$1=$`for<>;s/,|^$/ $a,$b /,$a|$b?do$0:s/( .+
$"=/ (.+)/,$$1=$`for<STDIN>;s//@ARGV
/;s/1/ @{[map$_=$$_,@ARGV]} /until
-0 sub f{@_&&f(/(.+) @_
/),@_}$_=<STDIN>;$_=" @{[reverse(f shift),f pop]}
";s/( .+ ).*\1/$1/;s/^ | $//g;print
-p0 BEGIN{$o=pop;$i=pop}sub f{"@_",/(.+) @_$/m&&f($1)}$_=" @{[f($i),reverse
";s/( .* ).*\1/$1/;s/^ | $//g
sub f{@_&&f("@c"=~/(\S+) @_
/),@_}@c=<STDIN>;s// @{[reverse(f shift),f pop]}
/;s/( .+ ).*\1/$1/;s/^ | $//g;print
-lp / /;$b{$'}=$`}BEGIN{$l=pop;$f=pop}{{s/ ?$/ $f/;$$f=$_;redo
if$f=$b{$f}}$_='';s// $l/,$l=$b{$l}until$$l;s//$$l/
-l $t=pop;$f=pop;/
(.*)/,$$1=$`for<>;s##$f\xA3$t#;while(($t=$$t)|($f=$$f)){s#\xA3# $f\xA3$t
#}s#( .+ |\bRo).+\b\1#$1#;print
-lp0 INIT{@a=pop;@b=pop}for$x(\@a,\@b){push@$x,$1while/(.+) $$x[-
1]$/m}pop@a;$_="@{[@b,reverse@a]}";s/( .+ ).*\1/$1/
-lp0 BEGIN{$R=$r=pop;$L=$l=pop}$L.=$".($l=$1)while s/(.+) $l$//m;$R=($r=$1)."
$R"while/(.+) $r$/m;$_=$L;s/\b$r.*/$R/
-p0 INIT{$;=pop;@$=$:=pop}splice@$,++$%,0,$:while$%-=$|,$:=/(.+) $:
/?$1:$;x--$|;$_="@$
-l @g=pop;@f=pop;/ $g[0]$/?@g=($`,@g):push@f,/(.*) $f[-
1]$/for(<>)x1e3;$f="@f"=~/(.*( |^)$_)( |$)/?$1:"$f $_"for@g;print$f
-pl INIT{$;=pop;$f=pop}/ /;$;{$'}=$`}{$_=$f.$;while$f=~s/\S+$/$&
$;{$&}/+$;=~s/^\S+/$;{$&} $&/;s/(^| )(.+) .* \2($| )/$1$2$3/
-lnaF BEGIN{$d=pop;$s=pop}push@{$r{$_}},@F for@F}{sub d{print"@_"if($_=@_[-
1])eq$d;local$v{$_}=1;$v{$_}||d(@_,$_)for@{$r{$_}}}d$s
@c=<STDIN>;for(t,f){@$_=$$_=pop;push@$_,$$_=$1while"@c"=~/(\S+) $$_
/;$a{$_}++for@$_}@a=grep{$a{$_}<2or!$i++}@f,reverse@t;print"@a
-l $e=pop;@c=pop;chop(@h=<>);for$c(@c){$c=~/\S+$/;$p=$&;map{push@c,"$c
$m",$_=''if/ /,$m=$`eq$p?$':$' eq$p&&$`}@h}print+(grep/$e/,@c)[0]
-l /(.*) (.*)/,$t{$2}=$1for<STDIN>;$r='Roma';sub
k{@x=($x=pop);push@x,$x=$t{$x}while$x ne$r;@x}@j=(k(shift),reverse k
pop);for$l(@j){@_=@j[$p+1..@j];if(grep/^$l$/,@_){do{splice@j,$p,1}until$j[$p
]eq$l}++$p}print
join' ',@j
$$a=$a=pop;$b=pop;s/(.+) (.+)/$2 $1/,$$2||=$$1&&"$2 $$1"for(<>)x2e3;print"$$b
-l map$_=pop|$$_,$b,$a;/ (.*)/,$$1=$`for<>;s/,|$/ $a,$b /;s/( .+
).+\1/$1/?print/ (.*) /:do$0
$$a=$a=pop;$b=pop;/(.+) (.+)/,$$2||=$$1&&"$2 $$1",$$1||=$$2&&"$1
$$2"for(@F=<>)x@F;print"$$b
95, mtve (would be rejected after 2.5 years, due to $ARGV problem) 
-lp INIT{$0=pop;$x=pop}/ /,${$'}=$`}{s/.+/${$&}/guntil$_="$x
INIT{$l=pop;$c=pop}%r=%R=reverse@F;0while$R{$c}=$p,$c=$r{$p=$c};$_=$l;s//$l
/while$l=$R{$l}
-lp / /;${$'}=$`}INIT{$l=pop;$f=pop}{do{@$f=@t=(@t,$f)}while$f=$$f;s//
$l/,$l=$$l until@$l;s//@$l/
-l $_=pop|$$_ for$b,$a;/ (.*)/,$$1=$`for<>;s/0|^$/$a 0 $b/;$a|$b?do$0:s/( .+
|\bRo).+\b\1/$1/+print
-lp / /;${$'}=$`}BEGIN{$l=pop;$f=pop}{do{@$f=@t=(@t,$f)}while$f=$$f;s//
$l/,$l=$$l until@$l;s//@$l/
-l $_=pop|$$_ for$b,$a;/ (.*)/,$$1=$`for<>;s/0|^$/$a 0 $b/;$a|$b?do$0:s/( .+
|\bRo).+\b\1/$1/+print
-l $_=pop|$$_ for$b,$a;/ (.*)/,$$1=$`for<>;s/0|^$/$a 0 $b/;$a|$b?do$0:s/( .+
|\bRo).+\b\1/$1/+print
$/+=$a=pop;$b=pop;$x=<>;sub k{print"@_\n"x/^$b/;s/ *$_[0]
*//^/^$_[1]$/&&k($_,@_)for$x=~/.+$/mg}k$a
-l map$_=pop|$$_,$b,$a;/ (.*)/,$$1=$`for<>;s/,|^$/ $a,$b /,$a|$b?do$0:s/( .+
$"=/ (.+)/,$$1=$`for<STDIN>;s//@ARGV
/;s/1/ @{[map$_=$$_,@ARGV]} /until
-0 sub f{@_&&f(/(.+) @_
/),@_}$_=<STDIN>;$_=" @{[reverse(f shift),f pop]}
";s/( .+ ).*\1/$1/;s/^ | $//g;print
-p0 BEGIN{$o=pop;$i=pop}sub f{"@_",/(.+) @_$/m&&f($1)}$_=" @{[f($i),reverse
";s/( .* ).*\1/$1/;s/^ | $//g
sub f{@_&&f("@c"=~/(\S+) @_
/),@_}@c=<STDIN>;s// @{[reverse(f shift),f pop]}
/;s/( .+ ).*\1/$1/;s/^ | $//g;print
-lp / /;$b{$'}=$`}BEGIN{$l=pop;$f=pop}{{s/ ?$/ $f/;$$f=$_;redo
if$f=$b{$f}}$_='';s// $l/,$l=$b{$l}until$$l;s//$$l/
-l $t=pop;$f=pop;/
(.*)/,$$1=$`for<>;s##$f\xA3$t#;while(($t=$$t)|($f=$$f)){s#\xA3# $f\xA3$t
#}s#( .+ |\bRo).+\b\1#$1#;print
-lp0 INIT{@a=pop;@b=pop}for$x(\@a,\@b){push@$x,$1while/(.+) $$x[-
1]$/m}pop@a;$_="@{[@b,reverse@a]}";s/( .+ ).*\1/$1/
-lp0 BEGIN{$R=$r=pop;$L=$l=pop}$L.=$".($l=$1)while s/(.+) $l$//m;$R=($r=$1)."
$R"while/(.+) $r$/m;$_=$L;s/\b$r.*/$R/
-p0 INIT{$;=pop;@$=$:=pop}splice@$,++$%,0,$:while$%-=$|,$:=/(.+) $:
/?$1:$;x--$|;$_="@$
-l @g=pop;@f=pop;/ $g[0]$/?@g=($`,@g):push@f,/(.*) $f[-
1]$/for(<>)x1e3;$f="@f"=~/(.*( |^)$_)( |$)/?$1:"$f $_"for@g;print$f
-pl INIT{$;=pop;$f=pop}/ /;$;{$'}=$`}{$_=$f.$;while$f=~s/\S+$/$&
$;{$&}/+$;=~s/^\S+/$;{$&} $&/;s/(^| )(.+) .* \2($| )/$1$2$3/
-lnaF BEGIN{$d=pop;$s=pop}push@{$r{$_}},@F for@F}{sub d{print"@_"if($_=@_[-
1])eq$d;local$v{$_}=1;$v{$_}||d(@_,$_)for@{$r{$_}}}d$s
@c=<STDIN>;for(t,f){@$_=$$_=pop;push@$_,$$_=$1while"@c"=~/(\S+) $$_
/;$a{$_}++for@$_}@a=grep{$a{$_}<2or!$i++}@f,reverse@t;print"@a
-l $e=pop;@c=pop;chop(@h=<>);for$c(@c){$c=~/\S+$/;$p=$&;map{push@c,"$c
$m",$_=''if/ /,$m=$`eq$p?$':$' eq$p&&$`}@h}print+(grep/$e/,@c)[0]
-l /(.*) (.*)/,$t{$2}=$1for<STDIN>;$r='Roma';sub
k{@x=($x=pop);push@x,$x=$t{$x}while$x ne$r;@x}@j=(k(shift),reverse k
pop);for$l(@j){@_=@j[$p+1..@j];if(grep/^$l$/,@_){do{splice@j,$p,1}until$j[$p
BEGIN{$^H<<=map$~.=$_%5&&pop,0..76}s/./.{1,3}(.{5}){6,8}$&/g;$_="$`"x($~x17)
=~/$_.*(??{grep$c{$_%38}++,%c=@+})/x
BEGIN{$^H=1<<map$~.=$_%5&&pop,0..20}s/./(.{5}){4,6}$&.{0,2}/g;$_="$`"x($~x17
)=~/$_.?(??{grep$c{$_%27}++,%c=@+})/x
sub f{$\=~/@ARGV[@_]$/x&&!$`|grep!@_|abs"@_"-~$_<6&abs"@_"%4-
~$_%4<2&"@_"!~~$_&&f(~$_,@_),0..15}f&&print while$\=<STDIN>
-p INIT{\$$_{--$=*5>>2}while$_=pop}sub b{local$p=-
$_.$p;!@_!=grep$p!~$_&&b(@_)&($_+$p)=~/$_|\b[1456]$/,%{+pop}}$_ x=b/./g
print grep{@a=0;@a=map$&eq$ARGV[$n=$_]?map$_&&/ $n /|1<abs$n%4-$_%4|5<abs$n-
$_?@0:" $n $_",@a:@0,0..15while/./g;@a}<STDIN>
-p INIT{push@$_,--$=*5>>2while$_=pop}sub b{local$p=-
$_.$p;!($n=pop)!=grep$p!~$_&($_+$p)=~/$_|\b[1456]$/&b(@_),@$n}$_ x=b/./g
-p INIT{push@$_,32|$;++/4+$;while$_=pop}sub
b{my($p,$n,@L)=@_;!$n|!!grep$p!~$_&b("$_ $p",@L)&($_-
$p)=~/$_|\b[1456]$/,@$n}$_ x=b/^|./g
sub r{my$i;map{$_=$l++,r($i-1),$_=$b[--$l]if(abs$i-"@_"<6&abs$i++%4-
"@_"%4<2|!$l)&$b[$l]eq$_}@ARGV;$f|=$l==@b}@b=/./g,r&&print,$f=0for<STDIN>
sub f{my($l,$x,@s)=($_,@_);grep{local@u=@u;!@u|abs($l%4-$_%4)<2&abs($l-
$_)<6&&$ARGV[$_]eq$x&!$u[$_]++&&!@s|f(@s)}0..15}print grep{f/./g}<STDIN>
sub c{@_<3||grep$_[1]eq$ARGV[$_]&abs$_%4-$_[0]%4<2&abs$_-
$_[0]<6&&c(local$ARGV[$_]=$_,@_[2..$#_]),0..15}print
grep{split//;grep{c$_,@_}0..15}<STDIN>
push@{$z{pop||$/}},int$_/.8for-19..0;sub
r{local$_=$_;for$d(@{$z{$f&&=chop}}){r(local$c=$d,$d-
=25),$d+=25if!$c|1<<$c+6-$d&7335}$f}$f=1,r||print for<>
sub k{my($a,$b,$i)=@_;ord==ord$a&(!$#_|2>abs$i%4-$b%4&6>abs$i-
$b)&&($_=uc,k(substr($a,1),$i),$_=lc),$i++for@ARGV;$s|=$a!~/./}print
grep{$s=0,k$_}<STDIN>
-naF// INIT{@a=splice@ARGV}sub
g{my$n=$_;if((E^$F[$i++])eq($a[$n]^=E)){$.*=$#F!=$i;(abs($_-
$n)>5|abs(($n&3)-($_&3))>>1or&g)for@I}$a[$n]^=E;$i--}g for@I=0..42;$.||print
push@L,shift,++$x%4&&()for%::;for$w(<>){map(f($_,$w),0..18)&&print$w}sub
f{my($p,$w)=@_;$w!~s/.//||$p>=0&&$L[$p]eq$&&&!local$L[$p]&&map f($p+$_,$w),-
sub r{my($c,$R)=@_;$ARGV[$c]ne chop$R?():local$ARGV[$c]|$R?map{r($c+$_,$R)}(-
5,-1,3)x($c%4),-4,4,(-3,1,5)x($c%4!=3):1}$#ARGV=42;map{print if
map{r$_,$`}(!/$/..15)}<STDIN>
-p sub n{local$b[$s=pop];local@f=map{$_+$s,$s-
$_}1,4,5,6;!($l=shift)||&p}INIT{@b=((1)x5,map{$_%4&&(),pop}0..15)}($l,@_)=/.
/g;@f=0..@b;$_ x=!!&p;sub p{map{n@_,$_}grep$b[$_]eq$l,@f}
-n BEGIN{1while($a[$i++/4*5]=pop)}sub
R{my($i,@a)=@_;ord($a[$i]^=$s[$j++])?$j<@s?0:print pop@x:map{R($i+$_,@a)}(-
6..-4,-1,1,4..6);--$j}@x=$_;@s=split//;$#a=$i=30;R($i,@a)while($i--)
d{my($p,$w,@l)=@_;if($w=~s/^$l[$p]//){$l[$p]=0;print($o),$o=''if$/eq$w;d($p+
$_,$w,@l)for-6..-4,-
1,1,4..6}}while($o=<STDIN>){d$_,$o,(0,@ARGV)[1..4,0,5..8,0,9..12,0,13..16,(0
-ln BEGIN{map$b.=pop,1..16}sub r{local($_,$c,$d)=($_,$d);for$l(chop
or$f=0){until(($d=index$b,$l,$d)<0){(0,$w=4&(~$c^$d),0,!$w,1,!$w)[$c+1?abs$c
-$d:4]&&r(substr(local$b=$b,$d)^=A),$d++}}$f}$d=$f=-1,r||print
I:for(<STDIN>){for$y(0..3){for$x(0..3){t($y,$x,$_,@ARGV)&&print&&next I}}}sub
t{my($y,$x,$w,@g)=@_;${for$Y(-1..1){for$X(-
1..1){t($y+$Y,$x+$X,$w,@g)|!$w&&return
1}}}if($;=chop$w)eq$/|!(($x|$y)&4)&$g[$y*4+$x]=~s/$;/_/}
($i="@ARGV")=~s/(.{5} .)/ $1/g;sub i{my($l,$r,$j,$i)=($_[0]=~/(.)(.*)/)or
print,next i;$_[2]&&($i-$_[2])!~/^-
?(2|7|9|11)$/||(substr($j=$_[1],$i,1)=0,i($r,$j,$i))while($i=index$_[1],$l,+
+$i)>0}i:while(<STDIN>){i$_,$i}
INIT{(@g,@ARGV)=@ARGV}$i=!pop@F;for$@(@F){@;=$i++?map{/\d+/;map$g[$;=$&+$_]e
q$@&$;>-1&!(1+index$'," $; ")?"$; $& $'":(),$&%4>2?(-5,-4,-1,3,4):$&%4?(-
5..-3,-1,1,3..5):(-4,-3,1,4,5)}@;:grep$g[$_]eq$@,0..@g}$_=""if!@
-n INIT{@a=@ARGV;@ARGV=()}sub f{if($_[0]-(@w=/./g)){for
my$i(0..$#a){if($a[$i]eq$w[$_[0]]&&!$f{$i}){local$f{$i}=1;if($_[1]==-
1||(($b=abs$i-
$_[1])!=2&&$b<6&&!(($i%4==0&&$_[1]%4==3)||($i%4==3&&$_[1]%4==0)))){f($_[0]+1
,$i)}}}}else{$m++||print}}f($m=0,-1)
-l for(0..15){$r=$_%4;my@a;if($_>3){push@a,$_-4;push@a,$_-5if$r;push@a,$_-
3if$r!=3}push@a,$_-
1if$r;push@a,$_+1if$r!=3;if($_<12){push@a,$_+4;push@a,$_+3if$r;push@a,$_+5if
$r!=3}$v[$_]=\@a}W:for(<STDIN>){chomp;@n=map{[$_]}0..15;for$l(split//,$_){my
@e;for$r(@c=grep{$ARGV[$_->[-1]]eq$l}@n){@a=@{$r};for$c(@{$v[$a[-
1]]}){push@e,[@a,$c]unless grep/^$c$/,@a}}@n=@e;next W unless@c}print}
-paF^...| $a[$`]=@;[@a[@F]]-=@;=$&+s/ .*/$"x@;."-"x$&/e*@
-pa $a[$`]=@;[@a[@F[2..9]]]-=@;=$&*s/ .*/$"x@;."-"x$&/e+@
-pa \@F[@a[@F[2..9]]];$a[$_]=$&- s/ .*/$"x$#F."-"x$&/e+@F
-lpa \@;[@e[@F[2..9]]];@;=$e[$_=$..$"x@;."-"x$']=$'-/ /+@
-pa \@;[@a[@F[2..9]]];@;=$a[$`]=$&- s/ .*/$"x@;."-"x$&/e+@
-lpa \@q[@e[@F[2..9]]];@q=$e[$_=$..$"x@q."-"x$']=@q-/ /+$'
-lpa \@F[@e[@F[2..9]]];$e[$.]=@F-/ /+$';$_=$..$"x$#F."-"x$'
-lpa @s=++$a;\$s[@$_]for/^...|./g;$_="@s ".'-'x$F[1];@$a=//g
-ap @a=!s! .*!\@a[@p{@F[2..9]}];$p{$`}=$#a+$&;" @a".'-'x$&!e
-pa s^ .*^(sort@L[@F[2..9]],b)[8].a
x$&^e;$L[$.]=b
-pl $a[$.]|=$"x$a[chop]=~y///cwhile/ . /;s/.$/$a[$.].="-"x$&/e
-lpa @q=/ /;\@q[@e[@F[2..9]]];$e[$_]=$#q+$';$_=$..$"x@q."-"x$'
-pla ($m,$n,@f)=@F;$m|=$_&$"x70for@l[@f],pp;$_=$l[$.]=$m.'-'x$n
-pla $e[$_="$. $n"]=($n=(sort@e[@F[2..9]])[-1]."-"x$F[1])&$"x80
-ap s# .*#$p{$`}|=$"x y///cfor@p{@F[2..9]};$".($p{$`}.='-'x$&)#e
-apl $_=(sort map"$. @$_",@F[2..9])[-1].'-'x$F[1];$#{$.}=y///c-2
-pal $h[$_="$. $x"]=$"x99&($x=(sort@h[@F[2..$#F]])[-1].'-'x$F[1])
-lp $,=s/ .//;$_>$,?$,=$_:0for@a[split];$a[$_=$`.$"x$,.'-'x$&]=$&+$,
-lpa / ./;$_="$` ".$"x(sort{$b-$a}@l[@F[2..9]])[0].'-'x$&;$l[$`]=y|||c-2
-lpa $s=(sort{$b-$a}@e[@F[2..9]])[0];$e[$_=$F[0].$"x++$s."-"x$F[1]]=$F[1]+$s
-pla $_=(sort map{$"x$g[$_-1]}@F[2..$#F])[-1]."-"x$F[1];push@g,y///c;s/^/$. /
-lna $s=(sort{$a-$b}@e[@F[2..9]])[-1];print$.,$",$"x$s,'-
'x$F[1];$e[$.]=$s+$F[1]
-lpa $s=1;map{$s=$e[$_]if$e[$_]>$s}@F[2..9];$e[$_=$F[0].$"x$s."-
"x$F[1]]=$F[1]+$s
-lna $s=0;($i,$l,@d)=@F;map{$s=$_ if$s<$_}@e[@d];print"$i ",' 'x$s,'-
'x$l;$e[$i]=$s+$l
-anl ($n,$l,@F)=@F;$m=0;map{$m=$t[$_]if$t[$_]>$m}@F;$t[$n]=$m+$l;print$n,'
'x($m+1),'-'x$l
-lna ($i,$l,@d)=@F;map{$e[$i]=$_}sort{$a-$b}@e[@d];print"$i ".' 'x$e[$i].'-
'x$l;$e[$i]+=$l
-lna my$s;map{$s=$e[$_]if$e[$_]>$s}@F[2..9];$e[$F[0]]=$s+$F[1];print$F[0]."
"x++$s."-"x$F[1]
split;$i=shift@_;$l=shift@_;my$s;map{$s=$e[$_]if($e[$_]>$s)}@_;$e[$i]=$l+$s;
print$i,(map" ",0..$s),(map"-",1..$l),"\n"
-p0 s!\w+!$_.=$=.$&;s/0$&6//?$'=~y/0//:$&!eg
-p0 s^\w+^$_.=$=.$&;s/0$&6//?$'=~y/0//:$&^ge
-p0 s!\w+!$_.=$=.$&;s/0$&6//?split 6,$':$&!eg
-p s/\w+/($a.=-$&)=~s!-$&-!-!?-$'=~y!-!!:$&/eg
-p0 s/\w+/$_.="0$&";s!0$&0!0!?split 0,$':$&/eg
-p0 s/\w+/$_.="\x00$&";s!\x00$&\x00!\x00!+$'=~y!\x00!!||$&/eg
-p0 s!\w+!$_.="$&
";s/^$&
^//m?$'=~y/
//:$&!ge
-p s!\w+!($s.=-$&)=~s#\b$&-##?-$'=~y/-//:$&!eg
-p s#\w+#($a.=" 1$&")=~s!1$& !!?$'=~y/1//:$&#ge
-p s!\w+!($/.="$&
")=~s/^$&
^//m?$'=~y/
//:$&!ge
-p s!\w+!($n.="$&,")=~s/\b$&,\b//?$'=~y/,//:$&!ge
-p s!\w+!($w.=$&.$")=~s/\b$& \b//?$'=~y/ //:$&!eg
-p s#\w+#($a.="
$&")=~s/\b$&
//?$'=~y/
//+1:$&#ge
s^\w+^($s.=_.$&)=~s/_$&_/_/?1+$'=~y/_//:$&^ge
s^\w+^($s.=$".$&)=~s/\b$& //?1+$'=~y/ //:$&^ge
-p0 s#\w+#($l.=";$&")!~s/;$&;/;/?$&:1+$'=~y/;//#eg
-p0 s!\w+!$s.=" $&";$s=~s#\b$& ##?1+$'=~y/ //:$&!eg
-p0 s#\w+#s!\b($&)\b.*\G!$&^$1!se?map/\W+/g,$&:$&#eg
-p s/\w+/$_+=~$_>~($a=$w{$&})for%w;$w{$&}=1;$a|$&/ge
s/\w+/map$_+=$_<($z=$x{$&})|!$z,%x;$x{$&}=1;$z|$&/eg
-p s/\w+/$_+=!$x|$_<($x=$M{$&})for%M;$M{$&}=1;$x|$&/ge
-p0 s#\w+#$`=~/.*\b$&\b/s?1+keys%{{$'=~/\b\w*/g}}:$&#eg
-p0 s/\w+/$_+=!$z|$_<($z=$x{$&})for%x;$x{$&}=1;$z|$&/eg
-p s/\w+/$*=$h{$&};$_+=$_<$*|!$*for%h;$h{$&}=1;$*|$&/eg
-p s/\w+/$_+=!($,=$w{$&})||$_<$,for%w;$w{$&}=1;$,||$&/ge
-p s/\w+/$H=$w{$&};map$_+=$_<$H|!$H,%w;$w{$&}=1;$H|$&/ge
-p s/\w+/$H=$w{$&};map$_+=$_<$H|!$H,%w;$w{$&}=1;$H or$&/ge
-p s/\w+/$_+=$_<($x=$M{$&})for%M;$M{$&}=++$w;$x?$w-$x:$&/ge
-p s#\w+#$x=keys%{$M{$&}};$M{$&}={};++$_->{$&}for%M;$x||$&#eg
-p s%\w+%$i=$j=0;@a=($&,grep++$i*!s/^$&$/$j=$i/e,@a);$j||$&%eg
-p0 s#\w+#my%s;$`=~/.*\b$&\b/s?grep!$s{$_}++,$'=~/\w+|/g:$&#eg
-p s'\w+'@a{@a=($&,@a)}=0..@a;splice@a,$i,1if$i=$a{$&};$i||$&'ge
-p0 s/\w+/map{$_++if!($z=$x{$&})||$_<$z}values%x;$x{$&}=1;$z||$&/eg
-p0 s/\w+/map{$_++if!($z=$x{$&})||$_<$z}values%x;$x{$&}=1;$z||$&/eg
-p0 s#(.*((\b(\pL|_)+)\b.*))\b\3\b#"$1".(@a=$2=~/[A-Za-z_]+/g)#es&&do$0
-p0 s#(\w+)(?=(.*?\b\1\b))?#$x=keys%$1||$1;%$1=map{$_,1}$2=~/(\w+)/g;$x#ges
-p s/\w+/(($a=(grep{$x[$_]eq$&}1..unshift@x,$&)[0])&&splice@x,$a,1)?$a:$&/eg
s#(.*)(\b[\pL_]+\b)(.+)\b\2\b#"$1$2$3".keys%{{split/([\W\d]+)/,$3}}#se&&redo
-alp0 s!.+!$;[map%$z,@$z{$&,$_}]=$z=$_.$&for@F!eg;$_=pop@
-alp0 s!.+!$;[@$z{$&,$_}=%$z]=$z=$_.$&for@F,@F!eg;$_=pop@
-lp0a $"='|'while$_=$x++,s/.//,grep$'!~/^$_(@F)$|^(@F)$_$/,@F
-p0a $_="$F[$?+=!++$^C]$F[$^C]
"while~-2**@F^($$_|=2**$?|2**$^C)
-ap0 $_="$F[$i=$j]$F[$j=rand@F]
"until($$_|=1<<$i|1<<$j)+1>>@F
-ap0 @F=sort{rand 2}@F until$_="@F ",s! !$/x$|--!eg,/
/,s/^$'//
-lap0 s#.+#$_[$_{$^G=$_.$&}+=map$^G=~/$_/,@F]=$^Gfor@F#eg;$_=pop@_
-ap0 }{@F=sort{$_.="$a$b
"x2;rand 2}@F until($_)=/^(.+
)\1{$#F}/
-alp0 sub f{splice@F,rand@F,1}$;=f.f;$;eq f.f||redo while@F;$_=$
-lp0a s/.+/ @{[map"$&$_ $_$&",@F]} /g;($_)=/(\d+)(.*
.* \1 )*.*$/
-lap0 s#.+#$_[$_{$^G=$_.$&}-=/$&/-map$^G=~/$_/,@F]=$^Gfor@F#eg;$_=pop@_
-lp0a $"='|',$_=glob"{,0,1}"x9until//>grep$'!~/^(@F)$_$|^$_(@F)$/,@F
-lap0 for$f(@F){\@{$_.$f}{\$_,\$f}for@F}($_)=grep/\d/&@F==keys%$_,%::
-lp0a $"=',',$_=<{@F}{@F}>until$"='|',//>grep$'!~/^(@F)$_$|^$_(@F)$/,@F
#for$a(@F){$\=$a.$&if!grep{(${$a.$&}.="$a
$&")!~/\b$_
/}@F}#eg
-0ap $_=(map{$i=$_;map{$j=$_;grep/$i/&&++$k{$_}>2*$#F,map$_.$j,@F}@F}@F)[0]
-lp0a *$_=\(sort{"1$a"-"1$b"}@F)[$_-3]for 1..4;"$3$2 $2$3"=~/$4$1|$1$4/;$_=$&
-lp0a for$=(@F){@;=map{$*=$_;grep$*eq$_,@;?@;:@*}@*=map{$_.$=,$=.$_}@F}$_=pop@
-lp0a for$=(@F){@;=grep{$*=$_;grep$*eq$_,@;?@;:@*}@*=map{$_.$=,$=.$_}@F}$_=pop@
-l chomp(@a=<>);0until($a{$_=$a[$i=$j].$a[$j=rand@a]}|=1<<$i|1<<$j)+1>>@a;print
for$=(@F){@;=grep{$*=$_;grep$*eq$_,@;?@;:@*}@*=map{$_.$=,$=.$_}@F}$_=pop@
$"="|";($_)=map{//;map{($t=$'.$_)x!grep$t!~/^$_(@_)$|^(@_)$_$/,@_}@_}@_=spli
\@H{@F};$"=',';for$s(glob"{@{[keys%H]}}"x2){$a=$h{$s}+=grep$s=~$_,@F;$m=$a
if$a>$m}$_={reverse%h}->{$m}
for$"(@_=split){$l+=length$";$h{$".$_}+=$_.$"eq$".$_?0:1for@_}$_=(sort{$h{$b
}<=>$h{$a}}grep{$l/@_*2==length}keys%h)[0]
@X=split;for$i(0..$#X){for(0..$#X){$Y{$X[$i].$X[$_]}++if$i^$_}}z:while(($",$
d)=each%Y){for(@X){next z if$"!~/$_/}$a=$d,$_=$"if$d>$a}
@X=split;for$i(0..$#X){for(0..$#X){$Y{$X[$i].$X[$_]}++if$i^$_}}z:while(($",$
d)=each%Y){for(@X){next z if$"!~/$_/}$a=$d,$_=$"if$d>=$a}
-lp0aF/\n/ sub f{B:while(@_){$s=pop;for$i(@_){$t=pop;next B
if/^($s$t|$t$s)$/;@_=($t,@_)}return}last}$a=pop@F;while(@F){$b=pop@F;$_=$a.$
b;f@F;$_=$b.$a;f@F;@F=($b,@F)}
@X=split;$K=9;for$;(@X){$,=length$;;$K=$,if$,<$K;$G=$,if$,>$G;$Y{$;.$_}++for
(@X)}z:while(($",$d)=each%Y){for(@X){next z
if$"!~/$_/}$a=$d,$_=$"if$d>$a&&length($")==$K+$G}
-lp0 $"="";@i=split;@p=f($#i,@i);$_="@p";sub
f{my($c,$a,$b,@i)=@_;if(@i){($x,$y)=f($#i,@i);(($a.$b)=~/^($x$y|$y$x)$/)?($a
,$b):(($b.$a)=~/^($x$y|$y$x)$/)?($b,$a):$c+1?f($c-
1,$a,@i,$b):()}else{$a,$b}}
-lp0 $"="";@i=split;($p,$q)=f($#i,@i);$_=$p.$q;sub
f{my($c,$a,$b,@i)=@_;if(@i){($x,$y,$z)=f($#i,@i);(($x.$y)=~/^($a$b|$b$a)$/)?
($x,$y):$z&&(($y.$x)=~/^($a$b|$b$a)$/)?($y,$x):$c?f($c-
1,$a,@i,$b):()}else{$a,$b,1}}
-lp0 $"="";@i=split;($p,$q)=f($#i,@i);$_=$p.$q;sub
f{my($c,$a,$b,@i)=@_;if(@i){($x,$y,$z)=f($#i,@i);(($x.$y)=~/^($a$b|$b$a)$/)?
($x,$y,$y.$x eq reverse $1):$z&&(($y.$x)=~/^($a$b|$b$a)$/)?($y,$x):$c?f($c-
1,$a,@i,$b):()}else{$a,$b,1}}

char*_ = "'""/*";
#include <stdio.h>
#define m 21
#define o(l, k) for(l=0; l<k; l++)
#define n(k) o(T, k)


              int E,L,O,R,G[42][m],h[2][42][m],g[3][8],c
              [42][42][2],f[42]; char d[42]; void v( int
              b,int a,int j){ printf("\33[%d;%df\33[4%d"
              "m  ",a,b,j); } void u(){ int T,e; n(42)o(
              e,m)if(h[0][T][e]-h[1][T][e]){ v(e+4+e,T+2
              ,h[0][T][e]+1?h[0][T][e]:0); h[1][T][e]=h[
              0][T][e]; } fflush(stdout); } void q(int l
                            ,int k,int p){
                            int T,e,a; L=0
                            ; O=1; while(O
                            ){ n(4&&L){ e=
                            k+c[l] [T][0];
                            h[0][L-1+c[l][
                            T][1]][p?20-e:
e]=-1; } n(4){                                          e=k+c[l][T][0]; a=L+c[l][T][
1]+1; if(a==42                                          || h[0][a][p?20-e:e]+1){ O=0
; } } n(4){ e=                                          k+c[l][T][0]; h[0][L + c[l][
T][1]][p?20-e:                                          e]=g[1][f[p?19+l:l]]; } L++;
u(); } n(42) {                                          o(e,m)if(h[0][T][e]<0)break;
o(a, m&&e==m){                                          for(L=T; L; L--) { h[0][L][a
]=h[0][L-1] [a                                          ]; } h[0][0][a]=-1; } } u();
}int main(){ int T,e,t,r,i,s              ,D,V,K; printf("\33[2J\33[?25l"); n(8)g[i=
1][T]=7-T; R--; n(42) o(e,m)              G[T][e]--; while(fgets(d,42,stdin)) { r=++
R; n(17){ e=d[T]-48; d[T]=0;              if ((e&7)==e) { g[0][e] ++; G[R][T+2]=e; }
} } n(8)if(g[0][7-T]){ t=g[i              ][O]; g[i][O++]=g[i][T]; g[i][T]=t; } n(8)
g[2][g[i][T]]=T; n(R+i)o(e,m              )if(G[T][e]+i) G[T][e]=g[2][G[T][e]]; n(19
)o(t,2){ f[T+t+T]=(T["+%#,4"              "5>GP9$5-,#C?NX"]-35)>>t*3&7; o(e,4){ c[T]
[e][t]=("5'<$=$8)Ih$=h9i8'9"              "t=)83)l4(99(g9>##>4(" [T+t+T]-35)>>e*2&3;
} } n(15) { s=T>9?m:(T&3)-3?15:36;o(e,s)o(t,2)c[T+19][e][t]="6*6,8*6.608.6264826668\
865::(+;0(6+6-6/8,61638065678469.;88))()3(6,8*6.608.6264826668865:+;4)-*6-6/616365,\
-6715690.5;,89,81+,(023096/:40(8-7751)2)65;695(855(+*8)+;4**+4(((6.608.626482666886\
5:+;4+4)0(8)6/61638065678469.;88)-4,4*8+4(((60(/6264826668865:+;4-616365676993-9:54\
+-14).;./347.+18*):1;-*0-975/)936.+:4*,80987(887(0(*)4.*""/4,4*8+4(((6264826668865:\
+;4/4-4+8-4)0(8)6365678469.;88)1/(6*6,6.60626466686:8)8-8*818.8582/9863(+;/""*6,6.6\
0626466686:4(8)8-8*818.8582/9863(+;/,6.60626466686:8-818.8582/9864*4+4(0())+;/.6062\
6466686:8/8380/7844,4-4*4+4(0())69+;/0626466686:818582/9864.4/4,4-4*4+4(0())+;" [e+E
+e+t]-40; E+=s+s; } n(45){ if(T>i) { v(2,T,7); v(46,T,7); } v(2+T,44,7); } T=0; o(e,
42)o(t,m)h[T][e][t]--; while(R+i) { s = D=0; if (r-R) { n(19) if (G[R+i][T]+i) V=T/2
; else if(G[R][T]+i) s++; if(s) { if(V>4){ V=9-V; D++; } V+=29; n(20) q(c[V][T][0],c
[V][T][i],D); } } n(19) if((L=G[R][T])+i) { O=T-L; e=O>9; t=e?18-O :O; o(K,((t&3)-3?
16:37)){ if(K){ L=c[t+19][K-i][0]; O=c[t+19][K-i][i] ; } q(L,O,K && e); } } if(s) q(
c[V][20][0], c[V][20][i], D); R--; } printf("\33[47;1f\33[?25h\33[40m"); return 0; }

#include <stdlib.h>
#include <curses.h>
#include <time.h>
#include <X11/Xlib.h>
#include <X11/keysym.h>
#define F(x,y,w,h,c) G(c),XFillRectangle(A,B,D,x,y,w,h),G(3)
#define G(c) XSetForeground(A,D,C[c].pixel)
#define H(d) addch(y?y-e?ACS_VLINE:ACS_L##d:ACS_U##d)
#define I(i,c) init_pair(i,COLOR_##c,COLOR_##c)
#define J(a,b) j==X[(int[]){ KEY_##b,XK_##a} ]
#define K(q,r,s,t,u,v,w) (q=!!(w)*z[p v]>>8,(1<<(3*!!((((r)>>t)^(s))&u)))*!!q)
#define L z[p=rand()&63]

int c[9],e,f,g,               h,i,j,k,l,m,n,q               ,r,s,t,u,v,w,x,
y,X, z[64]; GC                D; Display * A;               Window B;  char
o[]="tdpsf\73!"               "&e!&e!&e\1",*Y               =o,b[64];XColor
C[8]; XEvent E;               int  R  (  )  {               XDrawString(A,B
,D,348,58, b, e               ); XNextEvent (               A, &E);  return
XLookupKeysym(&               E.xkey,0)*! (E.               type^KeyPress);
} void P(){ g =               DefaultScreen((               A=XOpenDisplay(
               0 ) ) ) ;   do                XAllocNamedColor
               (    A       ,                DefaultColormap(
               A,g),5*x+"#fff"               "\0#f00\0#0f0\0"
               "#000",C+x,C+4)               ; while(++x^4) ;
               XMapWindow(A,B=              XCreateSimpleWindow
               (A,RootWindow(A               ,g),0,0,460,300
               ,0, C[3].pixel,               C->pixel ) )  ;
XSelectInput(A,               B,KeyPressMask|               ExposureMask);D
=XCreateGC(A,B,               0,0); } void a(               ){ for(y=0; y<=
e; y++)if(X)for               (x=k; y%3==0&&y               ^e&&x<k+t; x+=6
)XDrawRectangle               (A,B,D,3+6*x,6+               12 *y, 36, 36);
else{ move(y,k)               ; H(LCORNER ) ;               for(x=0; ++x^t;
)addch(x%6?y%3?               32:ACS_HLINE: y               &&y-e?ACS_VLINE
: ACS_HLINE)  ;               H(RCORNER); } }               void  Q  ( )  {
               initscr ( )   ;               start_color( );
               keypad(stdscr,1               ); curs_set(0);
               I(1, RED); I(2,               GREEN ) ; I(3 ,
               WHITE); } void                d(){ for(k=!x ;
               k^t; X?F(u,v,6,               12,i):mvaddch(v
               ,u,32|COLOR_PAIR              (i))){ u=X+(1+5
               *X)*(x+((i=~e?!               !e*((((e-1)>>k)
&1)+1):3)>2?4:1               )*(k/2)); v=X+(               1+11*X)*(1+3*y+
k++%2); } } int               S(){ mvaddstr(t               ,58,b); refresh
();return getch               (); } int main(               int p,char**V){
((X=*++V&&**V==               88)?P:Q)(); for               (srand(time(0))
; ( *Y++)--; );               for(f=++n; k^64               ; !L&&(z[p]=++k
)); L|=*z<<8; g               =p&7; h = p /8;               for(--l; j^113;
J(Up,UP) ? m?h?               h--:1:w?w--:i:J               (Down,DOWN)?m?h
               ^7?h++: r :w^7?               w++:l: J( Left,
               LEFT)?m?g?g--:3               : 7 : J (Right,
               RIGHT)?m ? g^7?               g++:9:s:j==10||
               J(Return,ENTER)               ?m?z[p=8*h+g]>>
               8?m--:((((r=K(x               ,x-1,l,t,3,-1,g
               )+K(y,l,y-1,t,3               ,+1,g^7)+K(i,i-
               1,l,1,21,-8,h)+               K(e,l,e-1,1,21,
+8,h^7))+3)&~3)               ==k)?z[p]|= ++l               <<8,c[w]=0, l=~
--m, s += r * (               ")%##!!!!"[--q]               -33),f++:m:c[w]
?l=c[w]-!m++:n^               64?c[w]=z[n++]&               127,q++:X:k){ p
=k=X&&!(F(0, 0,               460,300,0)); t=               48; e=24; a( );
k=t+2; t/=8; a(               ); e=3; k+=8; a               (); for(; p^64;
j^7?(void)j:d()               ){ x=2+t*(j=p%8               ); y=p/8; e=z[p
++]>>8; d( ); x               +=8; e =c[y]; }               x+=8; y=0; e=l+

1; d() ; x+=m*(t*g-50)-9; y=m?h:w; t-=2; e=-1; d(); e=sprintf(b,o,s,f,(f*s)
                 >>6); j=(X?R:S)(); } return X||endwin(); }

#include<stdio.h>
#include<stdlib.h>
#include<ctype.h>

int u,z,q[0400],O[0x101],o[0401],I[257],w[258][0403],W[0x100],Z[0x103],c[0403],k
,i,j,n,l,p,m;const char*J[0416],*M[0400];FILE*K[280],*s[0x102];void f(char*n,int
a){char*e=n;while(*e!='\0'){if(tolower((int)*e)!=*e)fputc(040,stderr);fputc((*e)
-a,stderr);e+=1;}(void)fputc('\n',stderr);}int y(int a,int b);int t(int i,int j)
{int k=i&j,l=i^j,n,m=1;for(n=1;k>=n;n<<=1)if(k&n)m=y(m,1<<n|1<<(n-1));return m>1
?y(m,1<<l):1<<l;}int y(int a,int b){int n,i=0x0,j;if((n=w[a][b]))return n;for(;a
>>i;++i)for(j=0x0;b>>j;j++)if(((a>>i)&1)&&((b>>j)&1))n^=t(i,j);return w[a][b]=w[
b][a]=n;}void a(void){for(i=0;i<z;i++){n=0;if(!i[I]){for(j=0;j<u;++j)if(i[O]==q[
j])n=Z[j];}else for(j=0;j<u;j++)n^=w[Z[j]][w[I[i]][W[w[o[j]][O[i]^q[j]]]]];c[i]=
n;}}void X(int v,int u){char*y=0;v-=1;switch(v){case(0x2):y ="HckngfVqQrgpKprwv"
"Hkng"; BC(4):y="JempihXsStirMrtyxJmpi"; BC(0):y="PointValueTooLarge"; BC 0x1:y=
"EvqmjdbufJoqvuQpjou";BC(6):y="TuOtv{zLorky";BC(3):y="WrrPdq|RxwsxwSrlqwv";BC(5)
:y="GfiFwlzrjsyX~syf}"; BC(07):y="UvV|{w|{Mpslz";}if(u)exit(0); f(y,v);exit(1);}
int main(int t,const char*T[]){for(i=00;i<0x100;++i)for(j=0;j<=i;++j)if(1==y(i,j
))W[i]=j,W[j]=i;for(k=0x1;k<t;k++){p=0;for(l=0;(T[k][l]>=toupper('0'))&&(T[k][l]
<=tolower('9'));l++){p=p*10+(T[k][l]-'0');if(p>=256)X(1,0);}if(T[k][l]=='-'){for
(m=0;m<u;m++)if(q[m]==p)X(2,0);q[u]=p;J[u]=T[k]+l+1;K[u]=fopen(J[u],"r");if(!u[K
])X(3,0);u++;}else if(T[k][l]=='+'){if(z>=256)X(4,0); O[z]=p;M[z]=T[k]+l+1;s[z]=
fopen(M[z],"w");if(!s[z])X(5,0);z++;}else X(6,0);}if(!(u!=0))X(7,0);if(!(z!= 0))
X(8,0);for(i=0;i<u;i++){n=1;for(j=0;j<u; j+=1)if(j!=i)n=w[n][q[i]^q[j]];o[i]=n;}
for(i=0;i<z;i++){n=1;for(j=0;j<u;j++)n=w[n][O[i]^q[j]];I[i]=n;}while(!(0)){for(k
=0;k<u;k++){int n;n=getc(K[k]); if(n==EOF)X(42,1); Z[k]=n;}a();for(k=0;k<z;k++)(
void)putc(c[k],s[k]);}X(11,1);}
